<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Block</title>
    <url>/2021/05/19/Block/</url>
    <content><![CDATA[<h5 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h5><ul>
<li>将<code>函数</code>及其<code>执行上下文（函数执行环境）</code>封装起来的<code>对象</code></li>
<li>Block内部有<code>isa</code> 指针，所以说其本质也是OC对象</li>
<li>Block的调用即是<code>函数的调用</code></li>
</ul>
<p>新建方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>(^blk)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;MCBlock&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>clang</code> 编译器编译 <code>clang -rewrite-objc main.m</code>  将代码转换成 <code>C++</code> 源码</p>
<h5 id="main-block-impl-0"><a href="#main-block-impl-0" class="headerlink" title="__main_block_impl_0"></a>__main_block_impl_0</h5><p>编译后的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;MCBlock&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>(*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先看 <code>Block</code> 语法部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^&#123;</span><br><span class="line">    printf(&quot;MCBlock&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>转换后的源码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MCBlock&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>Block</code> 使用的匿名函数实际上被作为简单的 C 语言函数来处理，<code>__main_block_func_0</code>  <code>main</code> 是 <code>Block</code> 语法所属的函数名，<code>0</code> 是 <code>Block</code> 语法在该函数出现的顺序值</p>
<p><code>__cself</code> 相当于指向自身实例的变量 <code>self</code> ，是指向 <code>Block</code> 值的变量</p>
<p>参数声明部分，结构体 <code>__main_block_impl_0</code> 声明如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>转换后的源码中，一并写入了其构造函数，除去构造函数，该结构体有两个成员变量</p>
<p>第一个成员变量 <code>struct __block_impl impl</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags; 		 <span class="comment">//标记位</span></span><br><span class="line">  <span class="keyword">int</span> Reserved;	 <span class="comment">//预留位</span></span><br><span class="line">  <span class="keyword">void</span> *FuncPtr; <span class="comment">//函数指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第二个成员变量 <code>struct __main_block_desc_0* Desc</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;		<span class="comment">//预留位</span></span><br><span class="line">  <span class="keyword">size_t</span> Block_size;	<span class="comment">//结构体大小</span></span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure>

<p>再看下 <code>__main_block_impl_0</code> 构造函数部分</p>
<p>先看下函数的调用 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>(*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br></pre></td></tr></table></figure>

<p>转换比较多，去掉转换部分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> *<span class="title">blk</span> =</span> </span><br><span class="line">  __main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA)</span><br></pre></td></tr></table></figure>

<p>第一个参数是 C 语言函数指针，第二个参数 block 描述</p>
<p>结构体根据构造函数，会像下面进行初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">Flags = <span class="number">0</span>;</span><br><span class="line">Reserved = <span class="number">0</span>;</span><br><span class="line">FuncPtr = __main_block_func_0;</span><br><span class="line">Desc = &amp;__main_block_desc_0_DATA;</span><br></pre></td></tr></table></figure>

<p>将函数指针 <code>__main_block_func_0</code> 赋值给成员变量 <code>FuncPtr</code></p>
<p>使用 <code>Block</code> 的部分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">blk();</span><br></pre></td></tr></table></figure>

<p>转换成源代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    return 0;</span><br></pre></td></tr></table></figure>

<p>去掉转换的部分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(*blk-&gt;impl.FuncPtr)(blk);</span><br></pre></td></tr></table></figure>

<p>通过函数指针找到函数执行体，这就是简单的使用函数指针调用函数</p>
<h5 id="捕获变量"><a href="#捕获变量" class="headerlink" title="捕获变量"></a>捕获变量</h5><ul>
<li>Block捕获值，内部结构体会新增同名成员变量，保存传进来的值</li>
<li>对基本数据类型的局部变量捕获其值</li>
<li>对于对象类型的局部变量连同所有权修饰符一起截获</li>
<li>以指针形式截获静态局部变量</li>
<li>不截获全局变量、静态全局变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;全局变量</span><br><span class="line">int global_var &#x3D; 4;</span><br><span class="line">&#x2F;&#x2F;静态全局变量</span><br><span class="line">static int static_global_var &#x3D; 5;</span><br><span class="line">- (void)method</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;基本数据类型局部变量</span><br><span class="line">    int var &#x3D; 1;</span><br><span class="line">    &#x2F;&#x2F;对象类型局部变量</span><br><span class="line">    __unsafe_unretained id unsafe_obj &#x3D; nil;</span><br><span class="line">    __strong id strong_obj &#x3D; nil;</span><br><span class="line">    &#x2F;&#x2F;静态局部变量</span><br><span class="line">    static int static_var &#x3D; 3;</span><br><span class="line">    void(^Block)(void) &#x3D; ^(void) &#123;</span><br><span class="line">        NSLog(@&quot;局部变量&lt;基本数据类型&gt; var %d&quot;, var);</span><br><span class="line">        NSLog(@&quot;局部变量&lt;__unsafe_unretained 对象类型&gt; var %@&quot;, unsafe_obj);</span><br><span class="line">        NSLog(@&quot;局部变量&lt;__strong 对象类型&gt; var %@&quot;, strong_obj);</span><br><span class="line">        NSLog(@&quot;静态变量 %d&quot;, static_var);</span><br><span class="line">        NSLog(@&quot;全局变量 %d&quot;, global_var);</span><br><span class="line">        NSLog(@&quot;静态全局变量 %d&quot;, static_global_var);</span><br><span class="line">    &#125;;</span><br><span class="line">    Block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>clang</code> 编译源码 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> global_var = <span class="number">4</span>;</span><br><span class="line"><span class="comment">//对全局变量、静态全局变量不截获</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_global_var = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">MCBlock__method_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">MCBlock__method_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> var; <span class="comment">//捕获局部变量</span></span><br><span class="line">  __unsafe_unretained id unsafe_obj;<span class="comment">//连同所有权修饰符一起截获</span></span><br><span class="line">  __strong id strong_obj;</span><br><span class="line">  <span class="keyword">int</span> *static_var; <span class="comment">//以指针针形式截获静态局部变量</span></span><br><span class="line">  __MCBlock__method_block_impl_0(<span class="keyword">void</span> *fp, struct __MCBlock__method_block_desc_0 *desc, <span class="keyword">int</span> _var, __unsafe_unretained id _unsafe_obj, __strong id _strong_obj, <span class="keyword">int</span> *_static_var, <span class="keyword">int</span> flags=<span class="number">0</span>) : var(_var), unsafe_obj(_unsafe_obj), strong_obj(_strong_obj), static_var(_static_var) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dmy = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">&quot;val = %d&quot;</span>;</span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123; <span class="built_in">printf</span>(fmt, val); &#125;;</span><br><span class="line">    val = <span class="number">2</span>;</span><br><span class="line">    fmt = <span class="string">&quot;value changed. val = %d&quot;</span>;</span><br><span class="line">    blk();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果 <code>val = 10</code></p>
<p><code>clang</code> 编译源码 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *fmt;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">const</span> <span class="keyword">char</span> *_fmt, <span class="keyword">int</span> _val, <span class="keyword">int</span> flags=<span class="number">0</span>) : fmt(_fmt), val(_val) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *fmt = __cself-&gt;fmt; <span class="comment">// bound by copy</span></span><br><span class="line">  <span class="keyword">int</span> val = __cself-&gt;val; <span class="comment">// bound by copy</span></span><br><span class="line"> <span class="built_in">printf</span>(fmt, val); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dmy = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">&quot;val = %d&quot;</span>;</span><br><span class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, fmt, val));</span><br><span class="line">    val = <span class="number">2</span>;</span><br><span class="line">    fmt = <span class="string">&quot;value changed. val = %d&quot;</span>;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_INFO</span> &#123;</span> <span class="keyword">unsigned</span> version; <span class="keyword">unsigned</span> flag; &#125; _OBJC_IMAGE_INFO = &#123; <span class="number">0</span>, <span class="number">2</span> &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到 <code>Block</code> 语法表达式中使用的局部变量追加到了 <code>__main_block_impl_0</code> 中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *fmt;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>Block</code> 的匿名函数实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">^&#123; <span class="built_in">printf</span>(fmt, val); &#125;;</span><br></pre></td></tr></table></figure>

<p>转换成以下函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *fmt = __cself-&gt;fmt; <span class="comment">// bound by copy</span></span><br><span class="line">  <span class="keyword">int</span> val = __cself-&gt;val; <span class="comment">// bound by copy</span></span><br><span class="line"> <span class="built_in">printf</span>(fmt, val); &#125;</span><br></pre></td></tr></table></figure>

<p>执行 <code>Block</code> 时，<code>Block</code> 语法表达式中使用的局部变量被保存到 <code>Block</code> 的结构体实例（ 即<code>Block</code> 自身）中</p>
<h5 id="block"><a href="#block" class="headerlink" title="__block"></a>__block</h5><p><code>__block</code> 说明符类似于 <code>auto</code> <code>static</code> 用于指定将变量值设置到哪个存储域中</p>
<p>例如，<code>auto</code> 表示作为自动变量存储在栈中，<code>static</code> 表示作为静态变量存储在数据区中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __block <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;val = <span class="number">1</span>;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>clang</code> 编译后</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_val_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_val_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __Block_byref_val_0 *val; <span class="comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_val_0 *_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : val(_val-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_val_0 *val = __cself-&gt;val; <span class="comment">// bound by ref</span></span><br><span class="line">(val-&gt;__forwarding-&gt;val) = <span class="number">1</span>;&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;val, (<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_val_0), <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, <span class="number">570425344</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看声明部分 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_val_0), <span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>简化后</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__Block_byref_val_0 val = &#123;<span class="number">0</span>,&amp;val, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_val_0), <span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>局部变量加上 <code>__block</code> 修饰后，变成了结构体实例 <code>__Block_byref_val_0</code> ，保存原始变量的指针和值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_val_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_val_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, <span class="number">570425344</span>));</span><br></pre></td></tr></table></figure>

<p><code>__main_block_impl_0</code> 中，将变量 <code>val</code> 生成的结构体对象的指针地址，传给 <code>Block</code> ，然后 <code>Block</code> 内部就可以对外界的变量进行操作了</p>
<p>查看给 <code>__block</code> 变量赋值部分 <code>^&#123;val = 1;&#125;;</code></p>
<p>转换后的源码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_val_0 *val = __cself-&gt;val; <span class="comment">// bound by ref</span></span><br><span class="line">(val-&gt;__forwarding-&gt;val) = <span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure>

<p><code>__Block_byref_val_0</code> 结构体实例的成员变量 <code>__forwarding</code> 持有指向该实例自身的指针。</p>
<p>通过成员变量 <code>__forwarding</code> 访问成员变量 <code>val</code></p>
<p><img src="/2021/05/19/Block/forwarding.png" alt="forwarding"></p>
<ul>
<li>一般情况下，对被截获的变量进行赋值操作需要添加 <code>__block</code> 修饰符</li>
<li>基本数据类型和对象类型的局部变量进行赋值时需要加 <code>__block</code> 修饰符</li>
<li>静态局部变量、静态全局变量、全局变量，进行赋值时不需要加 <code>__block</code> 修饰符</li>
</ul>
<h5 id="Block类型"><a href="#Block类型" class="headerlink" title="Block类型"></a>Block类型</h5><ul>
<li>_NSConcreteGlobalBlock（NSGlobalBlock）全局 <code>Block</code> ，存储在程序的数据区（.data区）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void(^blk)(void) &#x3D; ^&#123;</span><br><span class="line">    printf(&quot;MCBlock\n&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@&quot;%@&quot;, blk);</span><br></pre></td></tr></table></figure>

<p>此时的 <code>Block</code> 无参也无返回值，属于全局 <code>Block</code> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;__NSGlobalBlock__: 0x100004030&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>_NSConcreteStackBlock（NSStackBlock）栈 <code>Block</code> ，存放在栈上</p>
</li>
<li><p>_NSConcreteMallocBlock（NSMallocBlock）堆 <code>Block </code>，存储在堆上</p>
</li>
</ul>
<p>不使用外部变量的 Block 是全局 Block</p>
<p>使用外部变量并且未进行 copy 操作的 Block 是栈 Block</p>
<p>对栈 Block 进行 copy 操作，就是堆 Block，对全局 Block 进行 copy，仍是全局 Block</p>
<p>对 Block 的 copy 操作</p>
<p><img src="/2021/05/19/Block/copy.png" alt="copy"></p>
<p>对栈上Block进行copy操作，copy结果-&gt;在堆上产生一个Block</p>
<p><img src="/2021/05/19/Block/block2.png" alt="block2"></p>
<p><code>Block</code>  在栈上时 <code>__Block_byref_val_0</code> 结构体内 <code>__forwarding</code> 指针指向结构体自己</p>
<p><code>Block</code> 被复制到堆中时，<code>__Block_byref_val_0</code> 结构体也被复制到堆中一份</p>
<p>栈上 <code>__Block_byref_val_0</code> 结构体中的  <code>__forwarding</code>  指针指向堆中 <code>__Block_byref_val_0</code> 结构体</p>
<p>堆上  <code>__Block_byref_val_0</code> 结构体中的  <code>__forwarding</code>  指针指向结构体自己</p>
<ul>
<li><code>__forwarding</code> 指针存在的意义：</li>
</ul>
<p>不论在任何内存位置，都可以顺利访问同一个 <code>__block</code> 变量</p>
<p>无论 <code>__block</code> 变量配置在栈上还是堆上时，都能正确的访问 <code>__block</code> 变量</p>
]]></content>
  </entry>
  <entry>
    <title>FXForms</title>
    <url>/2021/12/06/FXForms/</url>
    <content><![CDATA[<h4 id="FXForms"><a href="#FXForms" class="headerlink" title="FXForms"></a>FXForms</h4><p>FXForms 框架提供了一个 FXFormViewController 视图控制器类，可以直接写继承于这个类的 ViewController 来便捷创建表单界面</p>
<p>FxForms 是通过节点配置的方式来进行表单创建的，表单中的每一个 Cell 都是一个节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface RootFormViewController : FXFormViewController</span><br><span class="line">@end</span><br><span class="line">@implementation RootFormViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">  	&#x2F;&#x2F;节点信息设置</span><br><span class="line">    self.formController.form &#x3D; [MyForm new];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h5 id="配置节点"><a href="#配置节点" class="headerlink" title="配置节点"></a>配置节点</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface MyForm : NSObject&lt;FXForm&gt;</span><br><span class="line">@property (nonatomic, copy) NSString *email;</span><br><span class="line">@property (nonatomic, copy) NSString *password;</span><br><span class="line">@property (nonatomic, assign) BOOL remember;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>上面的 MyForm 类定义了一些属性，如果不进行节点信息配置，FXForms 会自动根据节点属性来推断节点类型，NSString 类型的属性会被自动推断成带文本框的 Cell，BOOL 类型的属性会被自动推断成带 UISwitch 控件的 Cell</p>
<p><img src="/FXForms/WeChat8a22183ff8df3019ca8b1cca696d5910.png" alt="WeChat8a22183ff8df3019ca8b1cca696d5910"></p>
<h5 id="配置节点属性"><a href="#配置节点属性" class="headerlink" title="配置节点属性"></a>配置节点属性</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation MyForm</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方法名必须是 属性名+Field 返回为NSDictionary字典 字典中为节点的配置信息</span><br><span class="line">- (NSDictionary *)emailField &#123;</span><br><span class="line">    &#x2F;&#x2F;配置节点的类型 点击后 将弹出时间选择控件</span><br><span class="line">    return @&#123;FXFormFieldType: FXFormFieldTypeDate&#125;;</span><br><span class="line">&#125;</span><br><span class="line">- (NSDictionary *)passwordField &#123;</span><br><span class="line">    &#x2F;&#x2F;设置节点名称</span><br><span class="line">    return @&#123;FXFormFieldTitle: @&quot;名称&quot;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">- (NSDictionary *)rememberField &#123;</span><br><span class="line">    &#x2F;&#x2F;设置节点头视图名称</span><br><span class="line">    return @&#123;FXFormFieldHeader: @&quot;配置&quot;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h5 id="返回字典中可以配置的属性"><a href="#返回字典中可以配置的属性" class="headerlink" title="返回字典中可以配置的属性"></a>返回字典中可以配置的属性</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;配置此节点的标识符</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldKey;</span><br><span class="line">&#x2F;&#x2F;配置此节点的类型</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldType; </span><br><span class="line">&#x2F;&#x2F;指定当前节点属性对应的类 (一般不需设置)</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldClass;</span><br><span class="line">&#x2F;&#x2F;设置当前节点对应的cell类</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldCell;</span><br><span class="line">&#x2F;&#x2F;设置当前节点显示的名称(不设置默认为驼峰的属性名 eg:Email)</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldTitle;</span><br><span class="line">&#x2F;&#x2F;设置当前节点的placeHolder</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldPlaceholder;</span><br><span class="line">&#x2F;&#x2F;设置节点上默认显示的文字</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldDefaultValue; </span><br><span class="line">&#x2F;&#x2F;设置选项数组 这个属性的设置 必须配合特定配型的cell使用</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldOptions;</span><br><span class="line">&#x2F;&#x2F;如果某个节点是一个数组 则FXFormFieldTemplate可以用来设置数组中节点的属性</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldTemplate;</span><br><span class="line">&#x2F;&#x2F;进行类型转换</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldValueTransformer;</span><br><span class="line">&#x2F;&#x2F;设置节点的触发方法</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldAction;</span><br><span class="line">&#x2F;&#x2F;连接StoryboardSegue</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldSegue;</span><br><span class="line">&#x2F;&#x2F;设置节点头部内容</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldHeader;</span><br><span class="line">&#x2F;&#x2F;设置节点尾部内容</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldFooter;</span><br><span class="line">&#x2F;&#x2F;设置是否是内嵌节点 对于父节点或者数组类界定 这个如果设置为@YES 则会在当前界面中展示表单 如果设置为@NO，则会在新的视图控制器中展示</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldInline;</span><br><span class="line">&#x2F;&#x2F;对于数组类型的节点，设置是否支持排序 设置为@YES则为支持排序</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldSortable;</span><br><span class="line">&#x2F;&#x2F;设置选中cell后跳转的ViewController</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldViewController;</span><br></pre></td></tr></table></figure>

<h5 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;默认的节点类型</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldTypeDefault;</span><br><span class="line">&#x2F;&#x2F;文本标签节点类型</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldTypeLabel;</span><br><span class="line">&#x2F;&#x2F;输入框节点类型</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldTypeText;</span><br><span class="line">&#x2F;&#x2F;长文本输入节点类型</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldTypeLongText; </span><br><span class="line">&#x2F;&#x2F;URL节点类型</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldTypeURL;</span><br><span class="line">&#x2F;&#x2F;Email节点类型</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldTypeEmail; </span><br><span class="line">&#x2F;&#x2F;号码节点类型</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldTypePhone; </span><br><span class="line">&#x2F;&#x2F;密码框节点类型</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldTypePassword;</span><br><span class="line">&#x2F;&#x2F;数字节点类型</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldTypeNumber;</span><br><span class="line">&#x2F;&#x2F;只允许输入整数的节点类型</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldTypeInteger;</span><br><span class="line">&#x2F;&#x2F;无符号整数节点类型</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldTypeUnsigned; </span><br><span class="line">&#x2F;&#x2F;浮点节点类型</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldTypeFloat;</span><br><span class="line">&#x2F;&#x2F;BOOL节点类型 默认带UISwitch控件</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldTypeBoolean;</span><br><span class="line">&#x2F;&#x2F;选项节点类型 默认带对号符号</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldTypeOption;</span><br><span class="line">&#x2F;&#x2F;日期节点类型</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldTypeDate;</span><br><span class="line">&#x2F;&#x2F;时间节点类型</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldTypeTime;</span><br><span class="line">&#x2F;&#x2F;日期时间节点类型</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldTypeDateTime;</span><br><span class="line">&#x2F;&#x2F;图片节点类型</span><br><span class="line">UIKIT_EXTERN NSString *const FXFormFieldTypeImage;</span><br></pre></td></tr></table></figure>

<h5 id="FXForms中也提供了许多封装好的cell"><a href="#FXForms中也提供了许多封装好的cell" class="headerlink" title="FXForms中也提供了许多封装好的cell"></a>FXForms中也提供了许多封装好的cell</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;默认的cell</span><br><span class="line">@interface FXFormDefaultCell : FXFormBaseCell</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;带文本输入框的cell</span><br><span class="line">@interface FXFormTextFieldCell : FXFormBaseCell</span><br><span class="line">@property (nonatomic, readonly) UITextField *textField;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;带文本输入视图的cell</span><br><span class="line">@interface FXFormTextViewCell : FXFormBaseCell</span><br><span class="line">@property (nonatomic, readonly) UITextView *textView;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;带UISwitch控件的cell</span><br><span class="line">@interface FXFormSwitchCell : FXFormBaseCell</span><br><span class="line">@property (nonatomic, readonly) UISwitch *switchControl;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;带UIStepper控件的cell</span><br><span class="line">@interface FXFormStepperCell : FXFormBaseCell</span><br><span class="line">@property (nonatomic, readonly) UIStepper *stepper;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;带UISlider控件的cell</span><br><span class="line">@interface FXFormSliderCell : FXFormBaseCell</span><br><span class="line">@property (nonatomic, readonly) UISlider *slider;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;带日期选择控件的cell</span><br><span class="line">@interface FXFormDatePickerCell : FXFormBaseCell</span><br><span class="line">@property (nonatomic, readonly) UIDatePicker *datePicker;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;带图片选择控件的cell</span><br><span class="line">@interface FXFormImagePickerCell : FXFormBaseCell</span><br><span class="line">@property (nonatomic, readonly) UIImageView *imagePickerView;</span><br><span class="line">@property (nonatomic, readonly) UIImagePickerController *imagePickerController;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;带自定义PickerView的cell</span><br><span class="line">@interface FXFormOptionPickerCell : FXFormBaseCell</span><br><span class="line">@property (nonatomic, readonly) UIPickerView *pickerView;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;带UISegmentedControl控件的cell</span><br><span class="line">@interface FXFormOptionSegmentsCell : FXFormBaseCell</span><br><span class="line">@property (nonatomic, readonly) UISegmentedControl *segmentedControl;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h5 id="通过协议方式进行节点配置"><a href="#通过协议方式进行节点配置" class="headerlink" title="通过协议方式进行节点配置"></a>通过协议方式进行节点配置</h5><p>也可以不创建属性，使用 FXForms 协议的方法，完成节点的创建和配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation MyForm</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建与配置节点</span><br><span class="line">- (NSArray *)fields</span><br><span class="line">&#123;</span><br><span class="line">    return @[</span><br><span class="line">             &#x2F;&#x2F;这里面配置字典的方法和属性字典的配置方法一一致</span><br><span class="line">             @&#123;FXFormFieldKey: @&quot;email&quot;, FXFormFieldTitle: @&quot;email&quot;&#125;,</span><br><span class="line">             @&#123;FXFormFieldKey: @&quot;phone&quot;, FXFormFieldTitle: @&quot;phone&quot;&#125;,</span><br><span class="line">             @&#123;FXFormFieldKey: @&quot;address&quot;, FXFormFieldTitle: @&quot;address&quot;&#125;,</span><br><span class="line">             @&#123;FXFormFieldKey: @&quot;name&quot;, FXFormFieldTitle: @&quot;name&quot;&#125;</span><br><span class="line">             ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>fields 方法中可以直接进行节点的创建和配置</p>
<p>FXForms 协议中还提供了两个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;这个方法用于配置额外的节点，如果需要某些节点不对应任何属性，可以在这个方法中配置</span><br><span class="line">- (NSArray *)extraFields;</span><br><span class="line">&#x2F;&#x2F;这个方法需要返回一个字符串数组，如果需要某些属性不对应节点，即有属性的存在，但是不生成cell，可以将属性名传入返回</span><br><span class="line">- (NSArray *)excludedFields;</span><br></pre></td></tr></table></figure>

<p>节点还可以进行复合，将一个节点的配置作为属性，设置给另一个节点配置类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;子节点信息配置类</span><br><span class="line">@interface SubForm : NSObject&lt;FXForm&gt;</span><br><span class="line">@property(nonatomic,assign)NSInteger age;</span><br><span class="line">@property(nonatomic,assign)NSDate * date;</span><br><span class="line">@end</span><br><span class="line">@implementation SubForm</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;父节点信息配置类</span><br><span class="line">@interface MyForm : NSObject&lt;FXForm&gt;</span><br><span class="line">@property(nonatomic,strong)NSString * email;</span><br><span class="line">@property(nonatomic,strong)NSString * passwd;</span><br><span class="line">@property(nonatomic,assign)BOOL rememberMe;</span><br><span class="line">&#x2F;&#x2F;其中有属性为子节点</span><br><span class="line">@property(nonatomic,strong)SubForm * subForm;</span><br><span class="line">@end</span><br><span class="line">@implementation MyForm</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h5 id="自定义视图"><a href="#自定义视图" class="headerlink" title="自定义视图"></a>自定义视图</h5><p>创建的视图控制器不是继承于 FXFormViewController，也可以使用 FXForms 来快捷创建表单视图，需要遵守 FXFormControllerDelegate 协议</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface ViewController : UIViewController&lt;FXFormControllerDelegate&gt;</span><br><span class="line">&#x2F;&#x2F;系统的tableView</span><br><span class="line">@property(nonatomic,strong)UITableView * tableView;</span><br><span class="line">&#x2F;&#x2F;FX表单控制器</span><br><span class="line">@property(nonatomic,strong)FXFormController * formController;</span><br><span class="line">@end</span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.tableView &#x3D; [[UITableView alloc]initWithFrame:self.view.frame style:UITableViewStyleGrouped];</span><br><span class="line">    self.formController &#x3D; [[FXFormController alloc] init];</span><br><span class="line">    self.formController.tableView &#x3D; self.tableView;</span><br><span class="line">    self.formController.delegate &#x3D; self;</span><br><span class="line">    self.formController.form &#x3D; [[MyForm alloc] init];</span><br><span class="line">    [self.view addSubview:self.tableView];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h5 id="Cell-属性设置"><a href="#Cell-属性设置" class="headerlink" title="Cell 属性设置"></a>Cell 属性设置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-(NSDictionary *)passwdField&#123;</span><br><span class="line">    return @&#123;@&quot;textLabel.textColor&quot;:[UIColor redColor]&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="ViewController-页面跳转"><a href="#ViewController-页面跳转" class="headerlink" title="ViewController 页面跳转"></a>ViewController 页面跳转</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface RegistrationForm : NSObject &lt;FXForm&gt;</span><br><span class="line">@property (nonatomic, readonly) TermsViewController *termsAndConditions;</span><br><span class="line">@property (nonatomic, readonly) PrivacyPolicyViewController *privacyPolicy;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation RegistrationForm</span><br><span class="line">- (NSArray *)fields</span><br><span class="line">&#123;</span><br><span class="line">    return @[</span><br><span class="line">    	@&#123;FXFormFieldKey: @&quot;termsAndConditions&quot;, FXFormFieldHeader: @&quot;Legal&quot;&#125;,</span><br><span class="line">    	@&quot;privacyPolicy&quot;,</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><img src="/FXForms/WeChat49fb789e1986ffb8541ec06c2e2c0ae4.png" alt="WeChat49fb789e1986ffb8541ec06c2e2c0ae4"></p>
<p>点击跳转到 TermsViewController 控制器</p>
<h5 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation RegistrationForm</span><br><span class="line">- (NSArray *)fields</span><br><span class="line">&#123;</span><br><span class="line">    return @[</span><br><span class="line">    	@&#123;FXFormFieldTitle: @&quot;Submit&quot;, FXFormFieldHeader: @&quot;&quot;, FXFormFieldAction: @&quot;submitRegistrationForm:&quot;&#125;</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface RootFormViewController : FXFormViewController</span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">@implementation RootFormViewController</span><br><span class="line">- (void)submitRegistrationForm:(UITableViewCell&lt;FXFormFieldCell&gt; *)cell</span><br><span class="line">&#123;</span><br><span class="line">  	&#x2F;&#x2F;获取表单数据</span><br><span class="line">  	RegistrationForm *form &#x3D; cell.field.form;</span><br><span class="line">&#125;</span><br><span class="line">@end </span><br><span class="line"></span><br></pre></td></tr></table></figure>











<p><a href="%5Bhttps://github.com/nicklockwood/FXForms%5D(https://www.oschina.net/action/GoToLink?url=https://github.com/nicklockwood/FXForms)">FxForms</a></p>
<p><a href="https://my.oschina.net/u/2340880/blog/705221">iOS中表单视图 FXForms</a></p>
]]></content>
  </entry>
  <entry>
    <title>Flutter.cn</title>
    <url>/2022/02/16/FlutterCn%EF%BC%88%E4%B8%80%EF%BC%89Flutter%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h4 id="横向或纵向布局多个-widgets"><a href="#横向或纵向布局多个-widgets" class="headerlink" title="横向或纵向布局多个 widgets"></a>横向或纵向布局多个 widgets</h4><p>可以指定 Row 或 Column 如何在水平或者垂直方向上对齐其子项</p>
<p>可以指定子 widgets 如何占用 Row 或 Column 的可用空间</p>
<h5 id="对齐widgets"><a href="#对齐widgets" class="headerlink" title="对齐widgets"></a>对齐widgets</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/rendering.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">//设置为true，可以看到可视布局</span></span><br><span class="line">  debugPaintSizeEnabled = <span class="keyword">true</span>;</span><br><span class="line">  runApp(<span class="keyword">const</span> LayoutDemo());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LayoutDemo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> LayoutDemo(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&#x27;Flutter layout demo&#x27;</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">&#x27;Flutter layout demo&#x27;</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Center(</span><br><span class="line">          child: buildRow(),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置主轴对齐方式为spaceEvenly，会将剩余空间在每个图像之间、之前和之后均匀划分</span></span><br><span class="line">  Widget buildRow() =&gt;</span><br><span class="line">      Row(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.spaceEvenly,</span><br><span class="line">        children: [</span><br><span class="line">          Image.asset(<span class="string">&#x27;img/pic1.jpg&#x27;</span>),</span><br><span class="line">          Image.asset(<span class="string">&#x27;img/pic2.jpg&#x27;</span>),</span><br><span class="line">          Image.asset(<span class="string">&#x27;img/pic3.jpg&#x27;</span>),</span><br><span class="line">        ],</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">  Widget buildColumn() =&gt;</span><br><span class="line">      Column(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.spaceEvenly,</span><br><span class="line">        children: [</span><br><span class="line">          Image.asset(<span class="string">&#x27;img/pic1.jpg&#x27;</span>),</span><br><span class="line">          Image.asset(<span class="string">&#x27;img/pic2.jpg&#x27;</span>),</span><br><span class="line">          Image.asset(<span class="string">&#x27;img/pic3.jpg&#x27;</span>),</span><br><span class="line">        ],</span><br><span class="line">      );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="调整widgets大小"><a href="#调整widgets大小" class="headerlink" title="调整widgets大小"></a>调整widgets大小</h5><p>当某个布局太大而超出屏幕时，受影响的边缘会出现黄色和黑色条纹图案</p>
<p>通过使用 Expanded widget 可以调整 widgets 的大小以适合行或列</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Row(</span><br><span class="line">  crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">  children: [</span><br><span class="line">    Expanded(</span><br><span class="line">      child: Image.asset(<span class="string">&#x27;images/pic1.jpg&#x27;</span>),</span><br><span class="line">    ),</span><br><span class="line">    Expanded(</span><br><span class="line">      child: Image.asset(<span class="string">&#x27;images/pic2.jpg&#x27;</span>),</span><br><span class="line">    ),</span><br><span class="line">    Expanded(</span><br><span class="line">      child: Image.asset(<span class="string">&#x27;images/pic3.jpg&#x27;</span>),</span><br><span class="line">    ),</span><br><span class="line">  ],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>想要一个 widget 占用空间是兄弟项的两倍，可以使用 Expanded widget 的 flex 属性</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Row(</span><br><span class="line">  crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">  children: [</span><br><span class="line">    Expanded(</span><br><span class="line">      child: Image.asset(<span class="string">&#x27;images/pic1.jpg&#x27;</span>),</span><br><span class="line">    ),</span><br><span class="line">    Expanded(</span><br><span class="line">      flex: <span class="number">2</span>,</span><br><span class="line">      child: Image.asset(<span class="string">&#x27;images/pic2.jpg&#x27;</span>),</span><br><span class="line">    ),</span><br><span class="line">    Expanded(</span><br><span class="line">      child: Image.asset(<span class="string">&#x27;images/pic3.jpg&#x27;</span>),</span><br><span class="line">    ),</span><br><span class="line">  ],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="/FlutterCn%EF%BC%88%E4%B8%80%EF%BC%89Flutter%E5%B8%83%E5%B1%80/WeChat648aa69a2338cc1da9a5cdded93f8f16.png" alt="WeChat648aa69a2338cc1da9a5cdded93f8f16"></p>
<h5 id="组合widgets"><a href="#组合widgets" class="headerlink" title="组合widgets"></a>组合widgets</h5><p>默认情况下，行或列沿其主轴会占用尽可能多的空间，如果要将子项紧密组合在一起，将 mainAxisSize 设置为 MainAxisSize.min </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Row(</span><br><span class="line">  mainAxisSize: MainAxisSize.min,</span><br><span class="line">  children: [</span><br><span class="line">    Icon(Icons.star, color: Colors.green[<span class="number">500</span>]),</span><br><span class="line">    Icon(Icons.star, color: Colors.green[<span class="number">500</span>]),</span><br><span class="line">    Icon(Icons.star, color: Colors.green[<span class="number">500</span>]),</span><br><span class="line">    <span class="keyword">const</span> Icon(Icons.star, color: Colors.black),</span><br><span class="line">    <span class="keyword">const</span> Icon(Icons.star, color: Colors.black),</span><br><span class="line">  ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="/FlutterCn%EF%BC%88%E4%B8%80%EF%BC%89Flutter%E5%B8%83%E5%B1%80/WeChat9db897d81b3faa8300e97c87f80796cb.png" alt="WeChat9db897d81b3faa8300e97c87f80796cb"></p>
<h5 id="嵌套行和列"><a href="#嵌套行和列" class="headerlink" title="嵌套行和列"></a>嵌套行和列</h5><blockquote>
<p>为了最大限度地减少高度嵌套的布局代码可能导致的视觉错乱，可以在变量和函数中实现UI的各个部分</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stars = Row(</span><br><span class="line">  mainAxisSize: MainAxisSize.min,</span><br><span class="line">  children: [</span><br><span class="line">    Icon(Icons.star, color: Colors.green[<span class="number">500</span>]),</span><br><span class="line">    Icon(Icons.star, color: Colors.green[<span class="number">500</span>]),</span><br><span class="line">    Icon(Icons.star, color: Colors.green[<span class="number">500</span>]),</span><br><span class="line">    <span class="keyword">const</span> Icon(Icons.star, color: Colors.black),</span><br><span class="line">    <span class="keyword">const</span> Icon(Icons.star, color: Colors.black),</span><br><span class="line">  ],</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ratings = Container(</span><br><span class="line">  padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">20</span>),</span><br><span class="line">  child: Row(</span><br><span class="line">    mainAxisAlignment: MainAxisAlignment.spaceEvenly,</span><br><span class="line">    children: [</span><br><span class="line">      stars,</span><br><span class="line">      <span class="keyword">const</span> Text(</span><br><span class="line">        <span class="string">&#x27;170 Reviews&#x27;</span>,</span><br><span class="line">        style: TextStyle(</span><br><span class="line">          color: Colors.black,</span><br><span class="line">          fontWeight: FontWeight.w800,</span><br><span class="line">          fontFamily: <span class="string">&#x27;Roboto&#x27;</span>,</span><br><span class="line">          letterSpacing: <span class="number">0.5</span>,</span><br><span class="line">          fontSize: <span class="number">20</span>,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ],</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="通用布局-widgets"><a href="#通用布局-widgets" class="headerlink" title="通用布局 widgets"></a>通用布局 widgets</h4><p>下面 widget 会分为两类：widgets 库中的标准 widgets 和 Material 库中的 widgets，任何app都可以使用 widget库，但是 Material 库中的组件只能在 Material app 中使用</p>
<h5 id="标准-widgets"><a href="#标准-widgets" class="headerlink" title="标准 widgets"></a>标准 widgets</h5><p>Container：向 widget 增加 padding、margins、borders、background color 或者其他的“装饰”</p>
<p>GridView：将 widget 展示为一个可滚动的网格</p>
<p>ListView：将 widget 展示为一个可滚动的列表</p>
<p>Stack：将 widget 覆盖在另一个的上面</p>
<h5 id="Material-widgets"><a href="#Material-widgets" class="headerlink" title="Material widgets"></a>Material widgets</h5><p>Card：将相关信息整理到一个有圆角和阴影的盒子中</p>
<p>ListTitle：将最多三行的文本、可选的导语以及后面的图标组织在一行中</p>
<h5 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h5><p>许多布局都可以随意的用 Container，它可以将使用了 padding 或者增加了 borders/margins 的 widget 分开。你可以通过将整个布局放到一个 Container 中，并且改变它的背景色或者图片，来改变设备的背景</p>
<p>增加 padding、margins、borders<br>改变背景色或者图片<br>只包含一个子 widget，但是这个子 widget 可以是行、列或者是 widget 树的根 widget</p>
<p><img src="/FlutterCn%EF%BC%88%E4%B8%80%EF%BC%89Flutter%E5%B8%83%E5%B1%80/WeChatdc556c1945581f068555467d6a960f5b.png" alt="WeChatdc556c1945581f068555467d6a960f5b"></p>
<h5 id="GridView"><a href="#GridView" class="headerlink" title="GridView"></a>GridView</h5><p>GridView 将 widget 作为二维列表展示，提供了两个预制的列表，或者可以自定义网格，GridView 检测到内容太长而无法适应渲染盒时，就会自动支持滚动</p>
<p>GridView.count 允许你制定列的数量 GridView.extent 允许你制定单元格最大宽度</p>
<p>demo：gird_and_list、Flutter Gallery 中的  <a href="https://github.com/flutter/flutter/blob/master/dev/integration_tests/flutter_gallery/lib/demo/material/grid_list_demo.dart">grid_list_demo.dart</a></p>
<h4 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h4><p><a href="https://dart.cn/guides">Dart中文文档</a></p>
<p><a href="https://flutter.cn/docs/development/ui/widgets/layout">布局 Layout widgets</a></p>
<p><a href="https://flutter.cn/docs/development/ui/widgets/material">Material组件 Material Components widgets</a></p>
<p><a href="https://flutter.cn/docs/development/ui/advanced/gestures">Flutter中的手势</a></p>
<p><a href="https://flutter.cn/docs/development/tools/devtools/inspector#debugging-layout-issues-visually">使用Flutter inspector工具</a></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter (一) 环境配置</title>
    <url>/2021/10/12/Flutter%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h4 id="安装-Android-Studio"><a href="#安装-Android-Studio" class="headerlink" title="安装 Android Studio"></a>安装 Android Studio</h4><p><a href="%5Bhttps://developer.android.google.cn/studio%5D(https://links.jianshu.com/go?to=https://developer.android.google.cn/studio)">下载地址</a></p>
<p><a href="%5Bhttps://www.cnblogs.com/mengtaoadmin/p/11184052.html%5D(https://links.jianshu.com/go?to=https://www.cnblogs.com/mengtaoadmin/p/11184052.html)">Mac 上安装 Android Studio</a></p>
<h4 id="下载-Flutter-SDK"><a href="#下载-Flutter-SDK" class="headerlink" title="下载 Flutter SDK"></a>下载 Flutter SDK</h4><ul>
<li><p>方式1：<a href="https://flutter.dev/docs/get-started/install/macos">官网下载</a></p>
</li>
<li><p>方式2：</p>
</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">git clone -b beta <span class="symbol">https:</span>/<span class="regexp">/github.com/flutter</span><span class="regexp">/flutter.git</span></span><br></pre></td></tr></table></figure>

<p>放在 opt 目录下 <code>/opt/flutter</code></p>
<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p><code>./zshrc</code> 中配置环境变量，配置完成后执行 <code>source ~/.zshrc</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Flutter 镜像配置</span></span><br><span class="line">export PUB_HOSTED_URL=<span class="symbol">https:</span>/<span class="regexp">/pub.flutter-io.cn</span></span><br><span class="line"><span class="regexp">export FLUTTER_STORAGE_BASE_URL=https:/</span><span class="regexp">/storage.flutter-io.cn</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">#Flutter 配置</span></span><br><span class="line"><span class="regexp">export FLUTTER=/opt</span><span class="regexp">/flutter/bin</span></span><br><span class="line">export PATH=$FLUTTER<span class="symbol">:</span>$PATH</span><br></pre></td></tr></table></figure>

<p>Flutter 有一个 doctor 检测指令，查看配置是否完成</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">flutter doctor</span><br></pre></td></tr></table></figure>

<p>报错</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">[!] Android toolchain - develop <span class="keyword">for</span> Android devices (Android SDK version <span class="number">31.0</span>.<span class="number">0</span>)</span><br><span class="line">    ✗ cmdline-tools component is missing</span><br><span class="line">      Run <span class="string">`path/to/sdkmanager --install &quot;cmdline-tools;latest&quot;`</span></span><br><span class="line">      See <span class="symbol">https:</span>/<span class="regexp">/developer.android.com/studio</span><span class="regexp">/command-line for more details.</span></span><br><span class="line"><span class="regexp">    ✗ Android license status unknown.</span></span><br><span class="line"><span class="regexp">      Run `flutter doctor --android-licenses` to accept the SDK licenses.</span></span><br><span class="line"><span class="regexp">      See https:/</span><span class="regexp">/flutter.dev/docs</span><span class="regexp">/get-started/install</span><span class="regexp">/macos#android-setup for more details.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>解决 cmdline-tools component is missing 问题</li>
</ul>
<p>打开 Android Studio，Preferences-Appearance &amp; Beahvior-System Settings-Android SDK-SDK Tools</p>
<p>勾选 Android SDK Command-line Tools (latest)  OK</p>
<ul>
<li>解决 Android license status unknown 问题</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">flutter doctor --android-licenses</span><br><span class="line"><span class="comment">#然后一直选择y</span></span><br></pre></td></tr></table></figure>

<ul>
<li>安装 Flutter 插件</li>
</ul>
<p>Preferences-Plugins 找到 Flutter 插件安装</p>
<p><a href="https://flutterchina.club/setup-macos/">Flutter中文网搭建Flutter开发环境</a><br><a href="https://www.jianshu.com/p/7662c2b1501f">Flutter专题目录汇总</a><br><a href="https://flutter.dev/docs">Flutter 官方文档: </a><br><a href="https://github.com/flutter/flutter">Flutter github 地址: </a><br><a href="https://flutterchina.club/">Flutter 中文网: </a><br><a href="https://juejin.im/tag/Flutter">Flutter 掘金标签: </a><br><a href="https://zhuanlan.zhihu.com/p/37232700">Flutter 仿写项目</a></p>
<p><a href="https://github.com/alibaba/flutter-go">阿里巴巴 flutter-go</a>：包含 flutter 常用140+组件的demo演示与中文文档<br><a href="https://gitee.com/qingdongmeng/flutter-do">老孟flutter</a><br><a href="https://docs.flutter.dev/development/tools/sdk/releases?tab=macos">Flutter SDK releases</a></p>
<p><a href="https://github.com/flutter/samples">Flutter samples</a></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter（二）Hello Flutter</title>
    <url>/2021/10/12/Flutter%EF%BC%88%E4%BA%8C%EF%BC%89Hello-Flutter/</url>
    <content><![CDATA[<h4 id="创建-Flutter-工程"><a href="#创建-Flutter-工程" class="headerlink" title="创建 Flutter 工程"></a>创建 Flutter 工程</h4><p>Android Studio - New Flutter Project </p>
<p>Project Type：</p>
<ul>
<li><p>Application：创建一个 Flutter 应用工程</p>
</li>
<li><p>Plugin：为了给 Android 和 iOS 提供插件应用（暴露的接口）的时候使用</p>
</li>
<li><p>Package：创建一个 Dart 组件发布到 pub 来提供便捷开发，类似一些第三方库</p>
</li>
<li><p>Module：一般用来做混合开发，嵌入到 Android 和 iOS 工程中</p>
</li>
</ul>
<p>终端命令行方式创建：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">flutter create flutter_demo</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter run</span><br></pre></td></tr></table></figure>



<ul>
<li>添加安卓模拟器</li>
</ul>
<p>AVD Manager 添加模拟器</p>
<p>选择安卓模拟器运行卡在 <code>Running Gradle task &#39;assembleDebug&#39;...</code></p>
<p>原因是 Gradle 的 Maven 仓库在国外</p>
<p>修改项目下的 build .gradle 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">google()</span><br><span class="line">mavenCentral()</span><br></pre></td></tr></table></figure>

<p>修改为阿里云镜像</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">maven &#123; url <span class="string">&#x27;https://maven.aliyun.com/repository/google&#x27;</span> &#125;</span><br><span class="line">maven &#123; url <span class="string">&#x27;https://maven.aliyun.com/repository/jcenter&#x27;</span> &#125;</span><br><span class="line">maven &#123; url <span class="string">&#x27;http://maven.aliyun.com/nexus/content/groups/public&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext.kotlin_version = <span class="string">&#x27;1.3.50&#x27;</span></span><br><span class="line">    repositories &#123;</span><br><span class="line">        /<span class="regexp">/google()</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/mavenCentral()</span></span><br><span class="line"><span class="regexp">	 maven &#123; url &#x27;https:/</span><span class="regexp">/maven.aliyun.com/repository</span><span class="regexp">/google&#x27; &#125;</span></span><br><span class="line"><span class="regexp">	 maven &#123; url &#x27;https:/</span><span class="regexp">/maven.aliyun.com/repository</span><span class="regexp">/jcenter&#x27; &#125;</span></span><br><span class="line"><span class="regexp">	 maven &#123; url &#x27;http:/</span><span class="regexp">/maven.aliyun.com/nexus</span><span class="regexp">/content/groups</span><span class="regexp">/public&#x27; &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    dependencies &#123;</span></span><br><span class="line"><span class="regexp">        classpath &#x27;com.android.tools.build:gradle:4.1.0&#x27;</span></span><br><span class="line"><span class="regexp">        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">allprojects &#123;</span></span><br><span class="line"><span class="regexp">    repositories &#123;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/google()</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/mavenCentral()</span></span><br><span class="line"><span class="regexp">	 maven &#123; url &#x27;https:/</span><span class="regexp">/maven.aliyun.com/repository</span><span class="regexp">/google&#x27; &#125;</span></span><br><span class="line"><span class="regexp">	 maven &#123; url &#x27;https:/</span><span class="regexp">/maven.aliyun.com/repository</span><span class="regexp">/jcenter&#x27; &#125;</span></span><br><span class="line"><span class="regexp">	 maven &#123; url &#x27;http:/</span><span class="regexp">/maven.aliyun.com/nexus</span><span class="regexp">/content/groups</span><span class="regexp">/public&#x27; &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>修改 Flutter 安装目录中的 flutter.gradle 文件</p>
<p><code>/opt/flutter/packages/flutter_tools/gradle/flutter.gradle</code></p>
<h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p><code>Command + o</code> : 全局搜索</p>
<p><code>command + option + l</code> : 格式化代码</p>
<p><code>command + l</code> : 注释代码</p>
<p><code>command + -</code> : 折叠和展开代码</p>
<p><code>command + [</code> : 代码返回</p>
<p><code>command + ]</code> : 代码前进</p>
<p><code>cmd + C / cmd + delete</code> : 删除行</p>
<p><code>ctr + alt + I</code>: 自动缩进对齐</p>
<p><code>opt + sft + up/down</code> : 上下移动代码</p>
<p><code>ctrl + tab</code>: 切换文件</p>
<p><code>shift + command + enter</code> : 行尾自动添加分号，if后面自动加“(){ }”</p>
<p><code>cmd + N</code> : 快速生成getter／setter方法，构造方法，toString()方法等</p>
<p><code>cmd + J</code> : 快速生成模版代码块，如if,while,return</p>
<p><code>opt + cmd + T</code> : Surround with快速调出if,for,try…catch,while等环绕代码</p>
<p><code>opt + ctr + o</code>: 删除未使用的import</p>
<p><code>option + enter</code>: 自动导入用到的包</p>
<p><code>stless</code>: 创建新的 <code>StatelessWidget</code></p>
<p><code>stful</code>: 创建新的 <code>StatefulWidget</code></p>
<h4 id="Flutter-工程"><a href="#Flutter-工程" class="headerlink" title="Flutter 工程"></a>Flutter 工程</h4><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">/<span class="regexp">/导入系统包，作用类似 #import &lt;UIKit/</span>UIKit.h&gt;</span><br><span class="line">import <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(<span class="keyword">new</span> MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&#x27;Welcome to Flutter&#x27;</span>,</span><br><span class="line">      home: <span class="keyword">new</span> Scaffold(</span><br><span class="line">        appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">          title: <span class="keyword">new</span> Text(<span class="string">&#x27;Welcome to Flutter&#x27;</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: <span class="keyword">new</span> Center(</span><br><span class="line">          child: <span class="keyword">new</span> Text(<span class="string">&#x27;Hello World&#x27;</span>),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建一个 Material APP ，Material 是一种标准的移动端和 web 端的视觉设计语言</p>
</li>
<li><p>man 函数使用了 =&gt; 符号，这是 Dart 中单行函数或方法的简写</p>
</li>
<li><p>该程序继承了 StatelessWidget，将会使本身也成为一个 widget</p>
</li>
<li><p>Scaffold 是 Material APP，中提供的一个 widget，它提供了默认的导航栏、标题和包含主屏幕 widget 树的 body 属性</p>
</li>
<li><p>widget 的主要工作是提供一个 build() 方法来描述如果根据其它较低级别的 widget 来显示自己</p>
</li>
</ul>
<h5 id="文本组件-Text-Widget"><a href="#文本组件-Text-Widget" class="headerlink" title="文本组件 Text Widget"></a>文本组件 Text Widget</h5><p>main.dart</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;Model/base_widget.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;Model/hello_flutter_demo.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;Model/listView_demo.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(App());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      debugShowCheckedModeBanner: <span class="keyword">false</span>,<span class="comment">//右上角 debug 角标显示</span></span><br><span class="line">      home: Home(),</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primaryColor: Colors.blue, <span class="comment">//主题颜色</span></span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(<span class="comment">//类似 nav</span></span><br><span class="line">      backgroundColor: Colors.grey[<span class="number">100</span>], <span class="comment">//页面背景颜色</span></span><br><span class="line">      appBar: AppBar(<span class="comment">// 导航栏</span></span><br><span class="line">        title: Text(<span class="string">&quot;Demo&quot;</span>),</span><br><span class="line">        foregroundColor: Colors.black,  <span class="comment">//appBar上标题文字背景</span></span><br><span class="line">        backgroundColor: Colors.yellow, <span class="comment">//AppBar背景</span></span><br><span class="line">      ),</span><br><span class="line">      body: MyWidget(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hello_flutter_demo.dart</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> _textStyle = TextStyle(color: Colors.red, fontSize: <span class="number">40</span>, fontWeight: FontWeight.bold);</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: Text(</span><br><span class="line">          <span class="string">&quot;Hello Flutter&quot;</span>,</span><br><span class="line">          textDirection: TextDirection.ltr,</span><br><span class="line">          style: _textStyle),</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>base_widget.dart</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/cupertino.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/painting.dart&#x27;</span>;</span><br><span class="line"><span class="comment">//文本显示</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextDemo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> TextStyle _textStyle = TextStyle(</span><br><span class="line">    fontSize: <span class="number">16.0</span>,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> _title = <span class="string">&quot;标题&quot;</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> _name  = <span class="string">&quot;名字&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Text(</span><br><span class="line">      <span class="string">&quot;《<span class="subst">$&#123; _title &#125;</span>》-- <span class="subst">$_name</span> 123445&quot;</span>,</span><br><span class="line">      textAlign: TextAlign.center,</span><br><span class="line">      style: _textStyle,</span><br><span class="line">      maxLines: <span class="number">4</span>,</span><br><span class="line">      overflow: TextOverflow.ellipsis,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//富文本显示</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RichTextDemo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> RichText(</span><br><span class="line">      text: TextSpan(</span><br><span class="line">        text: <span class="string">&quot;富文本文字测试&quot;</span>,</span><br><span class="line">        style: TextStyle(fontSize: <span class="number">30</span>, color: Colors.black),</span><br><span class="line">        children: &lt;TextSpan&gt; [</span><br><span class="line">          TextSpan(</span><br><span class="line">            text: <span class="string">&quot;文本1&quot;</span>,</span><br><span class="line">            style: TextStyle(fontSize: <span class="number">10</span>, color: Colors.red),</span><br><span class="line">          ),</span><br><span class="line">          TextSpan(</span><br><span class="line">            text: <span class="string">&quot;文本2&quot;</span>,</span><br><span class="line">            style: TextStyle(fontSize: <span class="number">15</span>, color: Colors.green),</span><br><span class="line">          ),</span><br><span class="line">          TextSpan(</span><br><span class="line">            text: <span class="string">&quot;文本3&quot;</span>,</span><br><span class="line">            style: TextStyle(fontSize: <span class="number">20</span>, color: Colors.blue),</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseWidgetDmoe</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      color: Colors.yellow,</span><br><span class="line">      child: Row(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Container(</span><br><span class="line">            width: <span class="number">100</span>,</span><br><span class="line">            height: <span class="number">100</span>,</span><br><span class="line">            <span class="comment">//padding: EdgeInsets.only(left: 30, right: 30, top: 10, bottom: 10),</span></span><br><span class="line">            padding: EdgeInsets.all(<span class="number">30</span>),</span><br><span class="line">            color: Colors.red,</span><br><span class="line">            child: Icon(</span><br><span class="line">              Icons.add,</span><br><span class="line">              size: <span class="number">45</span>,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/12/Flutter%EF%BC%88%E4%BA%8C%EF%BC%89Hello-Flutter/richText.jpg" alt="richText"></p>
<p>Text 的构造方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Text(<span class="keyword">this</span>.data, &#123;  <span class="comment">//Text显示的内容</span></span><br><span class="line">Key key,</span><br><span class="line"><span class="keyword">this</span>.style, <span class="comment">//Text显示的样式</span></span><br><span class="line"><span class="keyword">this</span>.textAlign,<span class="comment">//文本应该如何水平对齐,TextAlign.start,end 或者center</span></span><br><span class="line"><span class="keyword">this</span>.textDirection, <span class="comment">//文本方向,TextDirection.ltr\TextDirection.rtl</span></span><br><span class="line"><span class="keyword">this</span>.locale,</span><br><span class="line"><span class="keyword">this</span>.softWrap,  <span class="comment">//是否自动换行，若为false，文字将不考虑容器大小，单行显示，超出屏幕部分将默认截断处理</span></span><br><span class="line"><span class="keyword">this</span>.overflow, <span class="comment">//当文字超出屏幕的时候，如何处理,TextOverflow.clip(裁剪)\TextOverflow.fade(渐隐)\TextOverflow.ellipsis(省略号)</span></span><br><span class="line"><span class="keyword">this</span>.textScaleFactor, <span class="comment">//字体显示倍率，上面的例子使用的字体大小是20.0，将字体设置成10.0，然后倍率为2</span></span><br><span class="line"><span class="keyword">this</span>.maxLines, <span class="comment">//最大行数设置</span></span><br><span class="line"><span class="keyword">this</span>.semanticsLabel,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>TextStyle 属性</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TextStyle(&#123;</span><br><span class="line">  <span class="keyword">this</span>.inherit: <span class="keyword">true</span>,  <span class="comment">// 为false的时候不显示</span></span><br><span class="line">  <span class="keyword">this</span>.color,          <span class="comment">// 颜色 </span></span><br><span class="line">  <span class="keyword">this</span>.fontSize,       <span class="comment">// 字号</span></span><br><span class="line">  <span class="keyword">this</span>.fontWeight,     <span class="comment">// 字重，加粗也用这个字段  FontWeight.w700</span></span><br><span class="line">  <span class="keyword">this</span>.fontStyle,      <span class="comment">// FontStyle.normal  FontStyle.italic斜体</span></span><br><span class="line">  <span class="keyword">this</span>.letterSpacing,  <span class="comment">// 字符间距  就是单个字母或者汉字之间的间隔，可以是负数</span></span><br><span class="line">  <span class="keyword">this</span>.wordSpacing,    <span class="comment">// 字间距 句字之间的间距</span></span><br><span class="line">  <span class="keyword">this</span>.textBaseline,   <span class="comment">// 基线，两个值，字面意思是一个用来排字母的，一人用来排表意字的（类似中文）</span></span><br><span class="line">  <span class="keyword">this</span>.height,         <span class="comment">// 当用来Text控件上时，行高（会乘以fontSize,所以不以设置过大）</span></span><br><span class="line">  <span class="keyword">this</span>.decoration,     <span class="comment">// 添加上划线，下划线，删除线 </span></span><br><span class="line">  <span class="keyword">this</span>.decorationColor,<span class="comment">// 划线的颜色</span></span><br><span class="line">  <span class="keyword">this</span>.decorationStyle,<span class="comment">// 这个style可能控制画实线，虚线，两条线，点, 波浪线等</span></span><br><span class="line">  <span class="keyword">this</span>.debugLabel,</span><br><span class="line">  <span class="built_in">String</span> fontFamily,   <span class="comment">// 字体</span></span><br><span class="line">  <span class="built_in">String</span> package,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="列表-ListView"><a href="#列表-ListView" class="headerlink" title="列表 ListView"></a>列表 ListView</h5><p>Car.dart</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Car(&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.name,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.imageUrl,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> imageUrl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模型数组</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">List</span>&lt;Car&gt; datas = [</span><br><span class="line">  Car(</span><br><span class="line">    name: <span class="string">&#x27;保时捷918 Spyder&#x27;</span>,</span><br><span class="line">    imageUrl:</span><br><span class="line">    <span class="string">&#x27;https://upload-images.jianshu.io/upload_images/2990730-7d8be6ebc4c7c95b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#x27;</span>,</span><br><span class="line">  ),</span><br><span class="line">  Car(</span><br><span class="line">    name: <span class="string">&#x27;兰博基尼Aventador&#x27;</span>,</span><br><span class="line">    imageUrl:</span><br><span class="line">    <span class="string">&#x27;https://upload-images.jianshu.io/upload_images/2990730-e3bfd824f30afaac?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#x27;</span>,</span><br><span class="line">  )</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>listView_demo.dart</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;Car.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListViewDemo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Widget _cellForRow(BuildContext contex, <span class="built_in">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      color: Colors.white,</span><br><span class="line">      margin: EdgeInsets.all(<span class="number">10</span>),</span><br><span class="line">      child: Column(</span><br><span class="line">        children: [</span><br><span class="line">          Image.network(</span><br><span class="line">              datas[index].imageUrl</span><br><span class="line">          ),</span><br><span class="line">          SizedBox(</span><br><span class="line">            height: <span class="number">10</span>,</span><br><span class="line">          ),</span><br><span class="line">          Text(</span><br><span class="line">              datas[index].name,</span><br><span class="line">              style: TextStyle(</span><br><span class="line">                fontWeight: FontWeight.w400,</span><br><span class="line">                fontSize: <span class="number">18</span>,</span><br><span class="line">                fontStyle: FontStyle.values[<span class="number">1</span>],</span><br><span class="line">              ),</span><br><span class="line">          ),</span><br><span class="line">          Container(height: <span class="number">20</span>,)</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ListView.builder(</span><br><span class="line">      itemCount: datas.length,</span><br><span class="line">      itemBuilder: _cellForRow,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/10/12/Flutter%EF%BC%88%E4%BA%8C%EF%BC%89Hello-Flutter/listView.jpg" alt="listView"></p>
<h5 id="使用-packages"><a href="#使用-packages" class="headerlink" title="使用 packages"></a>使用 packages</h5><p>pubspec 文件管理 Flutter 应用程序的 assets（资源，如图片、package等）在 pubspec.yaml 中，将 english_word 添加到依赖项列表</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">dependencies:</span></span><br><span class="line">  <span class="symbol">flutter:</span></span><br><span class="line">    <span class="symbol">sdk:</span> flutter</span><br><span class="line"></span><br><span class="line">  <span class="symbol">cupertino_icons:</span> ^<span class="number">0</span>.<span class="number">1.0</span></span><br><span class="line">  <span class="symbol">english_words:</span> ^<span class="number">4.0</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>Android Studio 编辑器视图中查看 pubspec.yaml 时，点击右上角 Pub get，将会将依赖包安装到项目，可以在控制台看到 flutter package get </p>
<p>或者在 Terminal 中输入 flutter package get  安装依赖包</p>
<p>安装成功后在 lib/main.dart 中，引入 english_words</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:english_words/english_words.dart&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h4 id="报错问题"><a href="#报错问题" class="headerlink" title="报错问题"></a>报错问题</h4><h5 id="1-flutter-pub-get-安装包卡住"><a href="#1-flutter-pub-get-安装包卡住" class="headerlink" title="1. flutter pub get 安装包卡住"></a>1. flutter pub get 安装包卡住</h5><p>网上好多说需要配置国内镜像就可以了，在 <code>~/.bash_profile</code> 添加 </p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 官方提供的国内镜像</span></span><br><span class="line">export PUB_HOSTED_URL=<span class="symbol">https:</span>/<span class="regexp">/pub.flutter-io.cn</span></span><br><span class="line"><span class="regexp">export FLUTTER_STORAGE_BASE_URL=https:/</span><span class="regexp">/storage.flutter-io.cn</span></span><br></pre></td></tr></table></figure>

<p><code>source ~/.bash_profile</code></p>
<p>可配置了还是会卡住，直接下载 package 配置本地路径了</p>
<p><code>https://pub.flutter-io.cn</code> 搜索包 <code>english_word</code> 下载最新版本</p>
<p> 放到项目目录 <code>plugin/english_words</code></p>
<p>pubspec.yaml 中配置包路径</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">dependencies:</span></span><br><span class="line">  <span class="symbol">flutter:</span></span><br><span class="line">    <span class="symbol">sdk:</span> flutter</span><br><span class="line"></span><br><span class="line">  <span class="symbol">cupertino_icons:</span> ^<span class="number">0</span>.<span class="number">1.0</span></span><br><span class="line">  <span class="symbol">english_words:</span> </span><br><span class="line">  	<span class="symbol">path:</span>  plugin/english_words/</span><br></pre></td></tr></table></figure>











<p><a href="https://gitee.com/other_other/flutter.git">hello_flutter</a></p>
<p><a href="https://www.jianshu.com/p/41f1d9d6079c">配置Flutter环境ForMac</a></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>KVO KVC</title>
    <url>/2021/07/06/KVO-KVC/</url>
    <content><![CDATA[<h4 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h4><p><code>KVC</code> 键值编码，一种间接访问对象属性的机制，通过字符串访问对象属性</p>
<h5 id="setValue-forKey"><a href="#setValue-forKey" class="headerlink" title="setValue:forKey"></a>setValue:forKey</h5><p>查找对应 key 的 setter 方法，顺序为：<code>set&lt;Key&gt; -&gt; _set&lt;Key&gt; -&gt; setIs&lt;Key&gt;</code></p>
<p>查找到则直接设置属性的 value</p>
<p>如果没有，检查 <code>accessInstanceVariableDirectly</code> 是否允许访问成员变量</p>
<p>如果 YES，则查找实例变量，顺序为：<code>_&lt;Key&gt; -&gt; _is&lt;Key&gt; -&gt; &lt;Key&gt; -&gt; &lt;isKey&gt;</code></p>
<p>找到实例变量则赋值，否则执行 <code>setValueforUndefineKey:</code> 方法，抛出 <code>NSUndefinedKeyException</code></p>
<h5 id="valueforKey"><a href="#valueforKey" class="headerlink" title="valueforKey:"></a>valueforKey:</h5><p>查找对应 key 的 getter 方法，顺序为：<code>get&lt;Key&gt; -&gt; &lt;key&gt; -&gt; is&lt;Key&gt; -&gt; _&lt;Key&gt;</code></p>
<p>查找到直接返回结果</p>
<p>如果没有，检查 <code>accessInstanceVariableDirectly</code> 是否允许访问成员变量</p>
<p>如果 YES，则查找实例变量，顺序为：<code>_&lt;Key&gt; -&gt; _is&lt;Key&gt; -&gt; &lt;Key&gt; -&gt; &lt;isKey&gt;</code></p>
<p>查找到直接返回结果，否则执行 <code>valueForUndefinedKey:</code> 方法，抛出 <code>NSUndefinedKeyException</code></p>
<h4 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h4><p><code>KeyValueObserving</code> 键值观察者，可以监听对象属性的改变</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.person &#x3D; [[LGPerson alloc] init];</span><br><span class="line">self.person.age &#x3D; 1;</span><br><span class="line">NSKeyValueObservingOptions options &#x3D; NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">[self.person addObserver:self forKeyPath:@&quot;age&quot; options:options context:@&quot;1&quot;];</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    self.person.age &#x3D; 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    NSLog(@&quot;%@ %@ %@ %@&quot;, keyPath, object, change, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加观察者后，KVO 会在运行时动态创建一个子类 <code>NSKVONotifing_XXX</code>，将对象的 isa 指向新创建的类</p>
<p>修改对象属性时，会先调用子类 <code>NSKVONotifing_XXX</code> 的 setter 方法</p>
<p>子类 setter 内部会调用：</p>
<ol>
<li><code>willChangeValueForKey:</code></li>
<li>父类原来的 setter</li>
<li><code>didChangeValueForKey:</code></li>
<li>内部会触发监听器的监听方法 <code>(observeValueForKeyPath:ofObject:change:context:)</code></li>
</ol>
<h4 id="Swift-KVO"><a href="#Swift-KVO" class="headerlink" title="Swift KVO"></a>Swift KVO</h4><p>kVO 是一个纯 OC 特性，swift class 需要在声明时加 <code>@objcMembers</code> 关键字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@objcMembers class OCClass: NSObject &#123;</span><br><span class="line">    dynamic var name: String</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察的闭包需要强引用，否则函数离开这个观察闭包后会被回收</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var occlass: OCClass?</span><br><span class="line">var observation: NSKeyValueObservation?</span><br><span class="line">  </span><br><span class="line">occlass &#x3D; OCClass(name: &quot;aa&quot;)</span><br><span class="line">observation &#x3D; occlass!.observe(\.name) &#123; obj, changed in</span><br><span class="line">    let new &#x3D; obj.name</span><br><span class="line">    print(&quot;new:\(new)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123;</span><br><span class="line">    occlass?.name &#x3D; &quot;1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><h5 id="1、直接修改成员变量会触发-KVO-吗"><a href="#1、直接修改成员变量会触发-KVO-吗" class="headerlink" title="1、直接修改成员变量会触发 KVO 吗"></a>1、直接修改成员变量会触发 KVO 吗</h5><p>不会，没有调用重写后的 set 方法</p>
<h5 id="2、手动触发-KVO"><a href="#2、手动触发-KVO" class="headerlink" title="2、手动触发 KVO"></a>2、手动触发 KVO</h5><p>手动调用 <code>willChangeValueForKey:</code> ，<code>didChangeValueForKey:</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[self.person willChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">self.person-&gt;_age &#x3D; 2;</span><br><span class="line">[self.person didChangeValueForKey:@&quot;age&quot;];</span><br></pre></td></tr></table></figure>

<h5 id="3、如何对可变数组进行-KVO"><a href="#3、如何对可变数组进行-KVO" class="headerlink" title="3、如何对可变数组进行 KVO"></a>3、如何对可变数组进行 KVO</h5><p>可变数组添加元素 <code>addObject:</code> 是不会调用 <code>setter</code> 方法的，不会触发 KVO 通知回调</p>
<p>需要使用 <code>mutableArrayValueForKey</code> 获取要操作的可变数组，添加元素</p>
<p>  <code>[[self mutableArrayValueForKey:@“arr”] addObject:item]</code> </p>
]]></content>
  </entry>
  <entry>
    <title>Hexo+GitHub 搭建博客</title>
    <url>/2020/11/17/Hexo-GitHub-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>安装node.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure>
<p>查看版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>
<p>npm是node.js的包管理工具</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p>Hexo是一个快速、简洁高效博客框架</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>安装完成后桌面建一个blog文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;Desktop &amp;&amp; mkdir blog &amp;&amp; cd blog</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>安装依赖包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>新建的框架目录如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|--_config.yml      &#x2F;&#x2F;网站的配置信息</span><br><span class="line">|--package.json     &#x2F;&#x2F;项目包信息</span><br><span class="line">|--scaffolds        &#x2F;&#x2F;模板文件，Hexo根据scaffolds中的模板来新建文件</span><br><span class="line">|--source           &#x2F;&#x2F;存放用户资源的地方</span><br><span class="line">|  |--_drafts       &#x2F;&#x2F;存放草稿</span><br><span class="line">|  |--_posts        &#x2F;&#x2F;存放文章</span><br><span class="line">|--themes           &#x2F;&#x2F;主题文件夹</span><br></pre></td></tr></table></figure>
<h4 id="部署到GitHub-Pages"><a href="#部署到GitHub-Pages" class="headerlink" title="部署到GitHub Pages"></a>部署到GitHub Pages</h4><p>安装 hexo-deployer-git工具</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>修改_config.yml中的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;caodaxun&#x2F;caodaxun.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure>
<p>查看 <code>https://caodaxun.github.io</code> 是否部署成功</p>
<h4 id="安装-NexT-主题"><a href="#安装-NexT-主题" class="headerlink" title="安装 NexT 主题"></a>安装 NexT 主题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>
<p>主题更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm update hexo-theme-next</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd themes&#x2F;next &amp;&amp; git pull</span><br></pre></td></tr></table></figure>

<h4 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h4><h5 id="配置添加文章自动打开编辑器"><a href="#配置添加文章自动打开编辑器" class="headerlink" title="配置添加文章自动打开编辑器"></a>配置添加文章自动打开编辑器</h5><p>blog 目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir scripts &amp;&amp; touch open.js</span><br></pre></td></tr></table></figure>

<p>添加代码保存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var exec &#x3D; require(&#39;child_process&#39;).exec;</span><br><span class="line">hexo.on(&#39;new&#39;, function(data)&#123;</span><br><span class="line">    exec(&#39;open -a &quot;&#x2F;Applications&#x2F;Typora.app&quot; &#39; + data.path);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>新建文章  <code>hexo new &quot;Test&quot;</code>  会自动打开 Typora 编辑器</p>
<p>写完后生成静态网页部署到 <code>github</code> 上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g -d				#直接生成页面发布</span><br></pre></td></tr></table></figure>

<h5 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h5><p>调试的时候可以边修改，边刷新查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean			#清除缓存</span><br><span class="line">hexo g				#生成静态页面</span><br><span class="line">hexo s --debug  #调试模式 http:&#x2F;&#x2F;localhost:4000&#x2F;进行访问</span><br></pre></td></tr></table></figure>

<p>调试模式有时会出现端口占用情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo lsof -i :4000</span><br><span class="line">sudo kill -9 进程PID</span><br></pre></td></tr></table></figure>

<h5 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h5><p>安装插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-marked</span><br></pre></td></tr></table></figure>

<p>修改  <code>config.yml</code>  配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br></pre></td></tr></table></figure>

<p>之后就可以使用 <code>![图片](image.jpg)</code> 访问图片了</p>
<h4 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h4><h5 id="添加菜单"><a href="#添加菜单" class="headerlink" title="添加菜单"></a>添加菜单</h5><p><code>hexo new page</code>添加页面，添加后文件在 <code>source/</code> 目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;categories&quot;</span><br><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">hexo new about &quot;about&quot;</span><br></pre></td></tr></table></figure>

<p>配置标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2020-11-18 12:42:18</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>配置分类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2020-11-18 12:31:50</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>给文章配置分类和标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 测试下</span><br><span class="line">date: 2020-11-17 15:02:26</span><br><span class="line">tags: </span><br><span class="line">    - 标签1</span><br><span class="line">categories: </span><br><span class="line">    - 分类1</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>修改主题配置<code>themes/next/_ocnfig.yml</code>，|| 后面的是图片名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">    home: &#x2F; || fa fa-home</span><br><span class="line">    archives: &#x2F;archives || fa fa-archive</span><br><span class="line">    categories: &#x2F;categories || fa fa-th</span><br><span class="line">    tags: &#x2F;tags || fa fa-tags</span><br><span class="line">    about: &#x2F;about || fa fa-user</span><br></pre></td></tr></table></figure>

<h5 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p><code>config.yml</code> 新增</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<p>修改主题配置文件 <code>themes/next/_config.yml</code> 修改 <code>local_search</code>的 <code>enable</code> 为<code>true</code></p>
<h5 id="添加背景动画"><a href="#添加背景动画" class="headerlink" title="添加背景动画"></a>添加背景动画</h5><p>进入 <code>Hexo</code> ，带 <code>scaffolds  source  themes  _config.yml  package.json</code>目录</p>
<p>新建 <code>footer.swig</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script color&#x3D;&quot;0,0,255&quot; opacity&#x3D;&quot;0.5&quot; zIndex&#x3D;&quot;-1&quot; count&#x3D;&quot;99&quot; src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;canvas-nest.js@1&#x2F;dist&#x2F;canvas-nest.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><code>themes/next/_config.yml</code> 修改 <code>custom_file_path</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer: source&#x2F;_data&#x2F;footer.swig</span><br></pre></td></tr></table></figure>

<p>查看图：</p>
<p><img src="/2020/11/17/Hexo-GitHub-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E8%83%8C%E6%99%AF.png" alt="背景"></p>
<h4 id="文章加密"><a href="#文章加密" class="headerlink" title="文章加密"></a>文章加密</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-blog-encrypt --save</span><br></pre></td></tr></table></figure>

<p>或者直接在 <code>package.json</code> 中直接配置依赖，再 <code>npm install</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;hexo-blog-encrypt&quot;: &quot;3.0.13&quot;,</span><br></pre></td></tr></table></figure>

<p><code>config.yml</code>中添加 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Security</span><br><span class="line">encrypt:</span><br><span class="line">    enable: true</span><br></pre></td></tr></table></figure>

<p>将<code>password</code>添加到文章信息头</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: Hello World</span><br><span class="line">password: xxxxxx</span><br><span class="line">abstract: 输入密码</span><br><span class="line">message: 输入密码</span><br></pre></td></tr></table></figure>

<h4 id="备份博客源文件"><a href="#备份博客源文件" class="headerlink" title="备份博客源文件"></a>备份博客源文件</h4><p>直接放码云了，码云上新建仓库 Hexo</p>
<p>本地新建同名文件 Hexo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd Hexo </span><br><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>本地和远程绑定 &amp;&amp; 拉取远程代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin https:&#x2F;&#x2F;gitee.com&#x2F;xxxx&#x2F;hexo.git</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>

<p>新建或修改 <code>.gitignore</code> 文件，加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*.log</span><br><span class="line">public&#x2F;</span><br><span class="line">.deploy*&#x2F;</span><br></pre></td></tr></table></figure>

<p>把 Blog 里面的代码拖到 Hexo 文件，提交到码云</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;提交备份&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>远程代码有更新时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>

<p>还是直接用 SourceTree 工具吧，Git命令一段时间不用就会忘</p>
<h4 id="报错问题"><a href="#报错问题" class="headerlink" title="报错问题"></a>报错问题</h4><ul>
<li>SSL_ERROR_SYSCALL in connection to github.com:443</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#39;https:&#x2F;&#x2F;github.com&#x2F;caodaxun&#x2F;caodaxun.github.io&#x2F;&#39;: LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (&#x2F;Users&#x2F;xx&#x2F;Desktop&#x2F;Hexo&#x2F;node_modules&#x2F;hexo-deployer-git&#x2F;node_modules&#x2F;hexo-util&#x2F;lib&#x2F;spawn.js:51:21)</span><br><span class="line">      at ChildProcess.emit (events.js:310:20)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:275:12) &#123;</span><br><span class="line">    code: 128</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something&#39;s wrong. Maybe you can find the solution here: %s https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;troubleshooting.html</span><br></pre></td></tr></table></figure>

<p>解决：</p>
<p>把 hexo 项目根目录下的 _config.yml 文件中把仓库地址 https 改为 ssh 地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t ed25519-sk -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>

<p>直接回车，会在 <code>~/.ssh</code> 目录生成 <code>id_ed25519</code> 和 <code>id_ed25519.pub</code> 文件</p>
<p>拷贝文件内容 <code>pbcopy &lt; ~/.ssh/id_ed25519.pub</code> 或直接打开拷贝，到 git 上添加 sshkey</p>
<p><a href="https://hexo.io/zh-cn/docs/">Hexo</a></p>
<p><a href="https://github.com/theme-next/hexo-theme-next">theme-next</a></p>
]]></content>
  </entry>
  <entry>
    <title>OC对象底层原理</title>
    <url>/2020/11/19/OC%E5%AF%B9%E8%B1%A1%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p><code>NSObject</code> 对象的底层就是一个包含了一个指针的结构体，那么它的大小是不是就是8字节（64位下指针类型占8个字节）？</p>
</blockquote>
<h4 id="class-getInstanceSize"><a href="#class-getInstanceSize" class="headerlink" title="class_getInstanceSize"></a>class_getInstanceSize</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;objc&#x2F;runtime.h&gt;</span><br></pre></td></tr></table></figure>

<p><code>class_getInstanceSize ()</code>可以计算一个类的实例对象实际所需要的空间大小，也就是计算类所对应的结构体的大小</p>
<p>系统在为类的结构体分配内存时内存对齐，以一个指针的长度作为对齐系数，64位系统指针长度为8个字节，类所对应的结构体，头部肯定是一个 <code>isa</code> 指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size_t size &#x3D; class_getInstanceSize([NSObject class]);</span><br><span class="line">NSLog(@&quot;NSObject对象大小：%zd&quot;, size); &#x2F;&#x2F;8</span><br></pre></td></tr></table></figure>

<h4 id="malloc-size"><a href="#malloc-size" class="headerlink" title="malloc_size()"></a>malloc_size()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;malloc&#x2F;malloc.h&gt;</span><br></pre></td></tr></table></figure>

<p><code>malloc_size()</code>，函数的参数是一个指针，可以计算指针所指向内存空间的大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSObject *obj &#x3D; [[NSObject alloc] init];</span><br><span class="line">size_t size2 &#x3D; malloc_size((__bridge const void *)(obj));</span><br><span class="line">NSLog(@&quot;对象obj所指向的的内存空间大小：%zd&quot;,size2); &#x2F;&#x2F;16</span><br></pre></td></tr></table></figure>

<p>系统为实例对象分配的内存空间，最小为16个字节</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">instanceSize</span><span class="params">(<span class="keyword">size_t</span> extraBytes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例对象内部成员变量所占空间大小 extraBytes通常为0</span></span><br><span class="line">    <span class="keyword">size_t</span> size = alignedInstanceSize() + extraBytes;</span><br><span class="line">    <span class="comment">// CF requires all objects be at least 16 bytes.</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">16</span>) size = <span class="number">16</span>; <span class="comment">//系统为该实例对象分配的内存空间大小</span></span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p><code>class_getInstanceSize</code> 获取类的实例对象内存大小，本质就是获取实例对象中成员变量的内存大小</p>
<p><code>malloc_size</code> 得到一个指针所指向的内存空间的大小，系统实际分配内存，利用这个可以得到对象所占用的内存大小</p>
<p><code>sizeof()</code> 获取数据类型或变量占用空间大小，这是一个运算符</p>
<p><code>[NSObject alloc]</code> 之后，系统为其分配了16个字节的内存，最终 <code>obj</code> 对象实际使用了其中8个字节内存（也就是其内部的那个 <code>isa</code> 指针所用的8个字节，64位系统下）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface Student : NSObject</span><br><span class="line">&#123;</span><br><span class="line">   @public</span><br><span class="line">    int _age;   &#x2F;&#x2F;4个字节</span><br><span class="line">    int _no;    &#x2F;&#x2F;4个字节</span><br><span class="line">    int _grade; &#x2F;&#x2F;4个字节</span><br><span class="line">&#125; </span><br><span class="line">Student *std &#x3D; [[Student alloc] init];</span><br><span class="line">size_t size &#x3D; class_getInstanceSize([Student class]); &#x2F;&#x2F;24</span><br><span class="line">size_t size &#x3D; malloc_size((__bridge const void *)(std)); &#x2F;&#x2F;32</span><br></pre></td></tr></table></figure>

<p><code>Student</code> 结构体所有成员变量所需要的总空间为20个字节，根据内存对齐的原则，最后结构体所需要的空间应该是8的倍数，也就是24个字节；实际系统分配内存大小是16的倍数32个字节</p>
<h4 id="LLDB查看内存"><a href="#LLDB查看内存" class="headerlink" title="LLDB查看内存"></a>LLDB查看内存</h4><p><img src="/2020/11/19/OC%E5%AF%B9%E8%B1%A1%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/alloc.png" alt="alloc"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x281442fa0-0x281442fa0-0x281442fa0</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(lldb) po p</span><br><span class="line">&lt;LGPerson: <span class="number">0x281442fa0</span>&gt;</span><br><span class="line">(lldb) x p</span><br><span class="line"><span class="number">0x281442fa0</span>: <span class="number">2</span>d <span class="number">17</span> d7 <span class="number">02</span> a1 <span class="number">41</span> <span class="number">00</span> <span class="number">00</span> <span class="number">28</span> c0 d6 <span class="number">02</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  -....A..(.......</span><br><span class="line"><span class="number">0x281442fb0</span>: <span class="number">0</span>a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">64</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  ........d.......</span><br><span class="line">(lldb) po <span class="number">0x0a</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">(lldb) po <span class="number">0x64</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line">(lldb) po <span class="number">0x0102d6c028</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<p>前8位<code>2d 17 d7 02 a1 41 00 00</code> 是<code>isa</code>的内存8个字节</p>
<p><code>0a 00 00 00</code> 是 <code>age</code> 占4个字节</p>
<p><code>64 00 00 00</code> 是 <code>height</code> 占4个字节</p>
<p><code>28 c0 d6 02 01 00 00 00</code> 是 <code>name</code> 占8个字节</p>
<h4 id="alloc-init"><a href="#alloc-init" class="headerlink" title="alloc init"></a>alloc init</h4><img src="allocinit.png" alt="allocinit" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (id)alloc &#123;</span><br><span class="line">    return _objc_rootAlloc(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_objc_rootAlloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return callAlloc(cls, false&#x2F;*checkNil*&#x2F;, true&#x2F;*allocWithZone*&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">callAlloc(Class cls, bool checkNil, bool allocWithZone&#x3D;false)</span><br><span class="line">&#123;</span><br><span class="line">#if __OBJC2__</span><br><span class="line">    if (slowpath(checkNil &amp;&amp; !cls)) return nil;</span><br><span class="line">    if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        return _objc_rootAllocWithZone(cls, nil);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; No shortcuts available.</span><br><span class="line">    if (allocWithZone) &#123;</span><br><span class="line">        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil);</span><br><span class="line">    &#125;</span><br><span class="line">    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id</span><br><span class="line">_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone __unused)&#x2F;&#x2F; alloc 源码 第四步</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; allocWithZone under __OBJC2__ ignores the zone parameter</span><br><span class="line">    &#x2F;&#x2F;zone 参数不再使用 类创建实例内存空间</span><br><span class="line">    return _class_createInstanceFromZone(cls, 0, nil,</span><br><span class="line">                                         OBJECT_CONSTRUCT_CALL_BADALLOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>alloc 的核心操作：</p>
<p><code>cls-&gt;instanceSize</code>：计算需要开辟内存空间大小</p>
<p><code>calloc</code>：申请内存，返回指针地址</p>
<p><code>objc-&gt;initInstanceIsa</code>：将类与 isa 关联</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static ALWAYS_INLINE id</span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,</span><br><span class="line">                              int construct_flags &#x3D; OBJECT_CONSTRUCT_NONE,</span><br><span class="line">                              bool cxxConstruct &#x3D; true,</span><br><span class="line">                              size_t *outAllocatedSize &#x3D; nil)&#x2F;&#x2F; alloc 源码 第五步</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(cls-&gt;isRealized()); &#x2F;&#x2F;检查是否已经实现</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Read class&#39;s info bits all at once for performance</span><br><span class="line">    &#x2F;&#x2F;一次性读取类的位信息以提高性能</span><br><span class="line">    bool hasCxxCtor &#x3D; cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();</span><br><span class="line">    bool hasCxxDtor &#x3D; cls-&gt;hasCxxDtor();</span><br><span class="line">    bool fast &#x3D; cls-&gt;canAllocNonpointer();</span><br><span class="line">    size_t size;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;计算需要开辟的内存大小，传入的extraBytes 为 0</span><br><span class="line">    size &#x3D; cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    if (outAllocatedSize) *outAllocatedSize &#x3D; size;</span><br><span class="line"></span><br><span class="line">    id obj;</span><br><span class="line">    if (zone) &#123;</span><br><span class="line">        obj &#x3D; (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;申请内存</span><br><span class="line">        obj &#x3D; (id)calloc(1, size);</span><br><span class="line">    &#125;</span><br><span class="line">    if (slowpath(!obj)) &#123;</span><br><span class="line">        if (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;</span><br><span class="line">            return _objc_callBadAllocHandler(cls);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!zone &amp;&amp; fast) &#123;</span><br><span class="line">        &#x2F;&#x2F;将 cls类 与 obj指针（即isa） 关联</span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Use raw pointer isa on the assumption that they might be</span><br><span class="line">        &#x2F;&#x2F; doing something weird with the zone or RR.</span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fastpath(!hasCxxCtor)) &#123;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    construct_flags |&#x3D; OBJECT_CONSTRUCT_FREE_ONFAILURE;</span><br><span class="line">    return object_cxxConstructFromClass(obj, cls, construct_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><a href="https://blog.csdn.net/u013480070/article/details/88365141">OC对象的本质（上）：OC对象的底层实现原理</a><br><a href="https://opensource.apple.com/tarballs/objc4/">objc4-781</a><br><a href="https://juejin.im/post/5d9c829df265da5ba46f49c9#heading-8">objc4-756.2源码编译</a><br><a href="https://www.jianshu.com/p/d4f4769eaa1a">macOS 10.15最新objc源码编译调试</a></p>
]]></content>
  </entry>
  <entry>
    <title>Runtime底层原理</title>
    <url>/2020/12/01/Runtime%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h4 id="通过SEL找到IMP"><a href="#通过SEL找到IMP" class="headerlink" title="通过SEL找到IMP"></a>通过SEL找到IMP</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL class_respondsToSelector(Class cls, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    return class_respondsToSelector_inst(cls, sel, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><a href="https://opensource.apple.com/tarballs/objc4/">苹果源码下载地址</a></p>
]]></content>
  </entry>
  <entry>
    <title>RxSwift（一）</title>
    <url>/2021/09/03/RxSwift%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h4 id="1-Observable"><a href="#1-Observable" class="headerlink" title="1 Observable"></a>1 Observable</h4><p><code>Observable&lt;T&gt;</code> 可观察序列 可以异步地产生一系列的Event(事件)</p>
<p>这些Event还可以携带数据</p>
<p>还需要有一个 Observer(订阅者)来订阅它，这样这个订阅者才能接收 <code>Observable&lt;T&gt;</code> 发出的Event</p>
<h5 id="1-1-创建Observable序列"><a href="#1-1-创建Observable序列" class="headerlink" title="1.1 创建Observable序列"></a>1.1 创建Observable序列</h5><ol>
<li>just() 方法</li>
</ol>
<p>传入一个默认值初始化，下面指定了这个Observable所发出的事件携带的数据类型必须是Int类型的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let observable &#x3D; Observable&lt;Int&gt;.just(5)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>of() 方法</li>
</ol>
<p>接收可变数量的参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let observable &#x3D; Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>from() 方法</li>
</ol>
<p>接收数组参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let observable &#x3D; Observable.from([&quot;A&quot;, &quot;B&quot;])</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>empty()方法</li>
</ol>
<p>创建一个空内容的Observable序列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let observable &#x3D; Observable&lt;Int&gt;.empty()</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>never()方法</li>
</ol>
<p>创建永远不会发出Event的Observable</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let observable &#x3D; Observable&lt;Int&gt;.never()</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>error()方法</li>
</ol>
<p>不做任何操作，只发送error的Observable</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum MyError: Error &#123;</span><br><span class="line">   case A</span><br><span class="line">   case B</span><br><span class="line">&#125;</span><br><span class="line">let observable &#x3D; Observable&lt;Int&gt;.error(MyError.A)</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>range()方法</li>
</ol>
<p>指定起始值和结束值，创建范围内所有值作为初始值的 Observable 序列，下面两种方法创建的 Observable 序列都是一样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用range()</span><br><span class="line">let observable &#x3D; Observable.range(start: 1, count: 5)</span><br><span class="line">&#x2F;&#x2F;使用of()</span><br><span class="line">let observable &#x3D; Observable.of(1, 2, 3 ,4 ,5)</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>repeatElement()方法</li>
</ol>
<p>创建可以无限发送给定元素的Event的Observable序列，永不终止</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let observable &#x3D; Observable.repeatElement(1)</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>generate()方法</li>
</ol>
<p>只有当提供的所有判断条件为true的时候才会给出动作的Observable序列，下面两种方法创建的 Observable 序列都是一样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let observable &#x3D; Observable.generate(</span><br><span class="line">    initialState: 0,</span><br><span class="line">    condition: &#123; $0 &lt;&#x3D; 10 &#125;,</span><br><span class="line">    iterate: &#123; $0 + 2&#125;</span><br><span class="line">)</span><br><span class="line">let observable &#x3D; Observable.of(0 , 2 ,4 ,6 ,8 ,10)</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>creat()方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let observable &#x3D; Observable&lt;String&gt;.create &#123; observer in</span><br><span class="line">    observer.onNext(&quot;hangge.com&quot;)</span><br><span class="line">    observer.onCompleted()</span><br><span class="line">    return Disposables.create()</span><br><span class="line">&#125;</span><br><span class="line">observable.subscribe(&#123;</span><br><span class="line">    print($0)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>defferred()方法</li>
</ol>
<p>相当于创建一个Observable工厂，传入一个block来延迟执行Observable序列创建行为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var isOdd &#x3D; true</span><br><span class="line">&#x2F;&#x2F;使用 deferred 方法延迟 Observable 序列的初始化</span><br><span class="line">let factory: Observable&lt;Int&gt; &#x3D; Observable.deferred &#123;</span><br><span class="line">    isOdd &#x3D; !isOdd</span><br><span class="line">    &#x2F;&#x2F;根据isOdd参数，决定创建并返回的是奇数Observable、还是偶数Observable</span><br><span class="line">    if isOdd &#123;</span><br><span class="line">        return Observable.of(1, 3, 5, 7)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return Observable.of(2, 4, 6, 8)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;第1次订阅测试</span><br><span class="line">factory.subscribe(&#123; event in</span><br><span class="line">    print(&quot;\(isOdd)&quot;, event)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;第2次订阅测试</span><br><span class="line">factory.subscribe(&#123; event in</span><br><span class="line">    print(&quot;\(isOdd)&quot;, event)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>interval()方法</li>
</ol>
<p>每隔一段特定时间，发出索引数的元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let observable &#x3D; Observable&lt;Int&gt;.interval(RxTimeInterval.seconds(1), scheduler: MainScheduler.instance)</span><br><span class="line">  </span><br><span class="line">observable.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="13">
<li>timer()</li>
</ol>
<p>两种用法，一种是创建的 Observable 序列经过设定时间后，产生唯一元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let observable &#x3D; Observable&lt;Int&gt;.timer(RxTimeInterval.seconds(5), scheduler: MainScheduler.instance)</span><br><span class="line">observable.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">next(0)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure>

<p>另一种是创建的 Observable 序列在经过设定时间后，每隔一段时间产生一个元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;5秒后，每隔1秒发出一个元素</span><br><span class="line">let observable &#x3D; Observable&lt;Int&gt;.timer(RxTimeInterval.seconds(5), period: RxTimeInterval.seconds(1), scheduler: MainScheduler.instance)</span><br><span class="line">observable.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-订阅-Observable"><a href="#1-2-订阅-Observable" class="headerlink" title="1.2 订阅 Observable"></a>1.2 订阅 Observable</h5><p>有了Observable，还要使用subscribe()来订阅它，接收它发出的Event</p>
<ul>
<li>第一种</li>
</ul>
<p>使用 subscribe() 订阅 Observable 对象，数据发送完毕后自动发一个 .completed 时间出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let observable &#x3D; Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">observable.subscribe &#123; event in</span><br><span class="line">  	&#x2F;&#x2F;想要获取event数据，可以通过event.element</span><br><span class="line">  	print(event)</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">next(A)</span><br><span class="line">next(B)</span><br><span class="line">next(C)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure>

<ul>
<li>第二种</li>
</ul>
<p>对event进行分类，通过不同block处理不同event，会把event的数据直接解包出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let observable &#x3D; Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">observable.subscribe &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#125; onError: &#123; error in</span><br><span class="line">    print(error)</span><br><span class="line">&#125; onCompleted: &#123;</span><br><span class="line">    print(&quot;completed&quot;)</span><br><span class="line">&#125; onDisposed: &#123;</span><br><span class="line">    print(&quot;disposed&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-监听事件生命周期"><a href="#1-3-监听事件生命周期" class="headerlink" title="1.3 监听事件生命周期"></a>1.3 监听事件生命周期</h5><p>doOn方法监听事件生命周期，会在事件发送前被调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">observable.do(onNext: &#123; (element) in</span><br><span class="line">    print(element)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="1-4-Observable-销毁"><a href="#1-4-Observable-销毁" class="headerlink" title="1.4 Observable 销毁"></a>1.4 Observable 销毁</h5><ol>
<li>通过dispose()取消订阅</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let subscription &#x3D; observable.subscribe &#123; (event) in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;</span><br><span class="line">subscription.dispose()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>DisposeBag</li>
</ol>
<p>DisposeBag会在自己快要dealloc的时候，对里面所有订阅行为都调用dispose()方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let observable &#x3D; Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">let disposeBag &#x3D; DisposeBag()</span><br><span class="line">observable.subscribe &#123; (event) in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h4 id="2-观察者"><a href="#2-观察者" class="headerlink" title="2 观察者"></a>2 观察者</h4><p>观察者（Observer）作用就是监听事件，对事件作出响应，或者说任何响应事件的行为都是观察者</p>
<h5 id="2-1-subscribe、bind方法中创建观察者"><a href="#2-1-subscribe、bind方法中创建观察者" class="headerlink" title="2.1 subscribe、bind方法中创建观察者"></a>2.1 subscribe、bind方法中创建观察者</h5><p>最直接的方法就是在subscribe方法后描述事件发生时，需要如何作出响应</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">observable.subscribe(onNext: &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#125;, onError: &#123; error in</span><br><span class="line">    print(error)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    print(&quot;completed&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>bind</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let observable &#x3D; Observable&lt;Int&gt;.interval(RxTimeInterval.seconds(1),</span><br><span class="line">                                          scheduler: MainScheduler.instance)</span><br><span class="line">observable</span><br><span class="line">    .map &#123; &quot;当前索引数:\($0)&quot; &#125;</span><br><span class="line">    .bind &#123; [weak self] (text) in</span><br><span class="line">        self?.label.text &#x3D; text</span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="2-2-使用-AnyObserver-创建观察者"><a href="#2-2-使用-AnyObserver-创建观察者" class="headerlink" title="2.2 使用 AnyObserver 创建观察者"></a>2.2 使用 AnyObserver 创建观察者</h5><p>配合 subscribe 使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let observer: AnyObserver&lt;String&gt; &#x3D; AnyObserver &#123; event in</span><br><span class="line">    switch event &#123;</span><br><span class="line">    case .next(let data):</span><br><span class="line">        print(data)</span><br><span class="line">    case .error(let error):</span><br><span class="line">        print(error)</span><br><span class="line">    case .completed:</span><br><span class="line">        print(&quot;complete&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let observable &#x3D; Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">observable.subscribe(observer)</span><br></pre></td></tr></table></figure>

<p>配合 bindTo 使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let observer: AnyObserver&lt;String&gt; &#x3D; AnyObserver &#123;[weak self] event in</span><br><span class="line">    switch event &#123;</span><br><span class="line">    case .next(let text):</span><br><span class="line">        self?.label.text &#x3D; text</span><br><span class="line">    default:</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let observable &#x3D; Observable&lt;Int&gt;.interval(RxTimeInterval.seconds(1),</span><br><span class="line">                                          scheduler: MainScheduler.instance)</span><br><span class="line">observable</span><br><span class="line">    .map &#123; &quot;当前索引数:\($0)&quot; &#125;</span><br><span class="line">    .bind(to: observer)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="2-3-使用-Binder-创建观察者"><a href="#2-3-使用-Binder-创建观察者" class="headerlink" title="2.3 使用 Binder 创建观察者"></a>2.3 使用 Binder 创建观察者</h5><p>Binder不会处理错误事件<br>确保绑定都是在给定的Schedule上执行，默认MainSchedule</p>
<p>上面示例中，label 文字显示就是一个典型的观察者，它在响应事件时，只会处理 next 事件，且更新 UI 的操作需要在主线程上执行，更好的方案是使用 Binder</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let observer: Binder&lt;String&gt; &#x3D; Binder(label) &#123; view, text in</span><br><span class="line">	  view.text &#x3D; text</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">observable</span><br><span class="line">    .map &#123; &quot;当前索引数：\($0 )&quot;&#125;</span><br><span class="line">    .bind(to: observer)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<ul>
<li>Binder 在 RxCocoa 中的应用</li>
</ul>
<p>RxCocoa 对许多 UI 控件进行扩展，利用 Binder 将控件属性变成观察者</p>
<h5 id="2-4-自定义可绑定属性"><a href="#2-4-自定义可绑定属性" class="headerlink" title="2.4 自定义可绑定属性"></a>2.4 自定义可绑定属性</h5><p>方法一： 通过对 UI 类进行扩展</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension UILabel &#123;</span><br><span class="line">    public var fontSize: Binder&lt;CGFloat&gt; &#123;</span><br><span class="line">        return Binder(self) &#123; label, fontSize in</span><br><span class="line">            label.font &#x3D; UIFont.systemFont(ofSize: fontSize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：通过对 Reactive 类进行扩展</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension Reactive where Base: UILabel &#123;</span><br><span class="line">    public var fontSize: Binder&lt;CGFloat&gt; &#123;</span><br><span class="line">        return Binder(self.base) &#123; label, fontSize in</span><br><span class="line">            label.font &#x3D; UIFont.systemFont(ofSize: fontSize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Subject"><a href="#3-Subject" class="headerlink" title="3 Subject"></a>3 Subject</h4><p>创建Observable的时候要预先把将要发出的数据都准备好，等到有人订阅时再将数据通过Event发送出去<br>但有时希望Observable动态的获得或者产生新数据，再通过Event发送出去-这些使用Subject来实现</p>
<p>Subject既是订阅者，也是Observable<br>订阅者：因为它能动态接收新值<br>又是一个Observable：因为当Subjects有了新值后，就会通过Event将新值发送给所有订阅者</p>
<h5 id="3-1-PublishSubject"><a href="#3-1-PublishSubject" class="headerlink" title="3.1 PublishSubject"></a>3.1 PublishSubject</h5><p>不需要初始值就能创建<br>PublishSubject的订阅者，可以收到订阅后Subject发出的新的Event，不会收到订阅前发出的Event</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let subject &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;没有任何订阅者 这条不会输出</span><br><span class="line">subject.onNext(&quot;11&quot;)</span><br><span class="line"></span><br><span class="line">subject.subscribe(onNext: &#123; string in</span><br><span class="line">    print(&quot;第一次订阅：&quot;, string)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    print(&quot;第一次订阅：completed&quot;)</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;有订阅会输出</span><br><span class="line">subject.onNext(&quot;22&quot;)</span><br><span class="line"></span><br><span class="line">subject.subscribe(onNext: &#123; string in</span><br><span class="line">    print(&quot;第二次订阅：&quot;, string)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    print(&quot;第二次订阅：completed&quot;)</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;有订阅会输出</span><br><span class="line">subject.onNext(&quot;33&quot;)</span><br><span class="line">subject.onCompleted()</span><br><span class="line">subject.onNext(&quot;44&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;完成后所有订阅(包括结束后订阅) 都能收到 complete 事件</span><br><span class="line">subject.subscribe(onNext: &#123; string in</span><br><span class="line">    print(&quot;第三次订阅：&quot;, string)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    print(&quot;第三次订阅：completed&quot;)</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br><span class="line">  </span><br><span class="line">结果</span><br><span class="line">第一次订阅： 22</span><br><span class="line">第一次订阅： 33</span><br><span class="line">第二次订阅： 33</span><br><span class="line">第一次订阅：completed</span><br><span class="line">第二次订阅：completed</span><br><span class="line">第三次订阅：completed</span><br></pre></td></tr></table></figure>

<h5 id="3-2-BehaviorSubject"><a href="#3-2-BehaviorSubject" class="headerlink" title="3.2 BehaviorSubject"></a>3.2 BehaviorSubject</h5><p>BehaviorSubject需要通过初始值创建<br>订阅者订阅它的时候，立即收到BehaviorSubject发出的Event，之后正常一样收到之后发出的新的Event</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let subject &#x3D; BehaviorSubject(value: &quot;111&quot;)</span><br><span class="line"></span><br><span class="line">subject.subscribe(onNext: &#123; string in</span><br><span class="line">    print(&quot;第1次订阅：&quot;, string)</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(&quot;222&quot;)</span><br><span class="line">&#x2F;&#x2F;发送error</span><br><span class="line">subject.onError(NSError(domain: &quot;local&quot;, code: 0, userInfo: nil))</span><br><span class="line"></span><br><span class="line">subject.subscribe(onNext: &#123; string in</span><br><span class="line">    print(&quot;第2次订阅：&quot;, string)</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br><span class="line">  </span><br><span class="line">输出</span><br><span class="line">第1次订阅： 111</span><br><span class="line">第1次订阅： 222</span><br><span class="line">Unhandled error happened: Error Domain&#x3D;local Code&#x3D;0 &quot;(null)&quot;</span><br><span class="line">Unhandled error happened: Error Domain&#x3D;local Code&#x3D;0 &quot;(null)&quot;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-ReplaySubject"><a href="#3-3-ReplaySubject" class="headerlink" title="3.3 ReplaySubject"></a>3.3 ReplaySubject</h5><p>创建时需要设置一个bufferSize，表示对发送过的Event的缓存个数</p>
<p>如bufferSize设置为2，发出3个.next的Event，那么后面两个会缓存起来，如果一个Subject订阅了这个 ReplaySubject，那立即会收到缓存的两个.next的Event</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let subject &#x3D; ReplaySubject&lt;String&gt;.create(bufferSize: 2)</span><br><span class="line">        </span><br><span class="line">subject.onNext(&quot;111&quot;)</span><br><span class="line">subject.onNext(&quot;222&quot;)</span><br><span class="line">subject.onNext(&quot;333&quot;)</span><br><span class="line"></span><br><span class="line">subject.subscribe &#123; event in</span><br><span class="line">    print(&quot;第1次订阅：&quot;, event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(&quot;444&quot;)</span><br><span class="line"></span><br><span class="line">subject.subscribe &#123; event in</span><br><span class="line">    print(&quot;第2次订阅：&quot;, event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onCompleted()</span><br><span class="line"></span><br><span class="line">subject.subscribe &#123; event in</span><br><span class="line">    print(&quot;第3次订阅：&quot;, event)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">  </span><br><span class="line">结果：</span><br><span class="line">第1次订阅： next(222)</span><br><span class="line">第1次订阅： next(333)</span><br><span class="line">第1次订阅： next(444)</span><br><span class="line">第2次订阅： next(333)</span><br><span class="line">第2次订阅： next(444)</span><br><span class="line">第1次订阅： completed</span><br><span class="line">第2次订阅： completed</span><br><span class="line">第3次订阅： next(333)</span><br><span class="line">第3次订阅： next(444)</span><br><span class="line">第3次订阅： completed</span><br></pre></td></tr></table></figure>

<h5 id="3-4-BehaviorRelay"><a href="#3-4-BehaviorRelay" class="headerlink" title="3.4 BehaviorRelay"></a>3.4 BehaviorRelay</h5><p>BehaviorRelay 有一个 value 属性，我们通过这个属性可以获取最新值。而通过它的 accept() 方法可以对值进行修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let subject &#x3D; BehaviorRelay&lt;String&gt;(value: &quot;111&quot;)</span><br><span class="line">&#x2F;&#x2F;修改value值</span><br><span class="line">subject.accept(&quot;222&quot;)</span><br><span class="line">subject.subscribe &#123;</span><br><span class="line">    print(&quot;第1次订阅：&quot;, $0)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">subject.accept(&quot;333&quot;)</span><br><span class="line">subject.subscribe &#123;</span><br><span class="line">    print(&quot;第2次订阅：&quot;, $0)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br><span class="line">subject.accept(&quot;444&quot;)</span><br><span class="line">  </span><br><span class="line">结果：</span><br><span class="line">第1次订阅： next(222)</span><br><span class="line">第1次订阅： next(333)</span><br><span class="line">第2次订阅： next(333)</span><br><span class="line">第1次订阅： next(444)</span><br><span class="line">第2次订阅： next(444)</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
  </entry>
  <entry>
    <title>RxSwift（四）</title>
    <url>/2021/09/09/RxSwift%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h4 id="1-URLSession"><a href="#1-URLSession" class="headerlink" title="1 URLSession"></a>1 URLSession</h4><h5 id="1-1-rx-response-请求数据"><a href="#1-1-rx-response-请求数据" class="headerlink" title="1.1 rx.response 请求数据"></a>1.1 rx.response 请求数据</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let urlString &#x3D; &quot;https:&#x2F;&#x2F;www.douban.com&#x2F;j&#x2F;app&#x2F;radio&#x2F;channels&quot;</span><br><span class="line">let url &#x3D; URL(string: urlString)!</span><br><span class="line">let request &#x3D; URLRequest(url: url)</span><br><span class="line">URLSession.shared.rx.response(request: request)</span><br><span class="line">    .subscribe(onNext: &#123; (response, data) in</span><br><span class="line">        if 200 ..&lt; 300 ~&#x3D; response.statusCode &#123;</span><br><span class="line">            let str &#x3D; String(data: data, encoding: String.Encoding.utf8)</span><br><span class="line">            print(&quot;返回数据：\(str ?? &quot;&quot;)&quot;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            print(&quot;请求失败&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="1-2-rx-data"><a href="#1-2-rx-data" class="headerlink" title="1.2 rx.data"></a>1.2 rx.data</h5><p>如果不需要获取底层 response，只需知道是否请求成功，以及返回结果，建议使用 rx.data</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URLSession.shared.rx.data(request: request)</span><br><span class="line">    .subscribe(onNext: &#123; data in</span><br><span class="line">        print(&quot;请求成功&quot;)</span><br><span class="line">    &#125;, onError: &#123; error in</span><br><span class="line">        print(&quot;请求失败：&quot;, error)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p>将结果转换为JSON</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URLSession.shared.rx.data(request: request)</span><br><span class="line">    .map &#123;</span><br><span class="line">        try JSONSerialization.jsonObject(with: $0, options: .allowFragments) as! [String: Any]</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe(onNext: &#123; data in</span><br><span class="line">        print(&quot;请求成功&quot;)</span><br><span class="line">    &#125;, onError: &#123; error in</span><br><span class="line">        print(&quot;请求失败：&quot;, error)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="1-3-手动发起-取消请求"><a href="#1-3-手动发起-取消请求" class="headerlink" title="1.3 手动发起/取消请求"></a>1.3 手动发起/取消请求</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">startButton.rx.tap</span><br><span class="line">    .flatMap &#123;</span><br><span class="line">        URLSession.shared.rx.data(request: request)</span><br><span class="line">            .takeUntil(self.cancelButton.rx.tap)</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe(onNext: &#123; data in</span><br><span class="line">    &#125;, onError: &#123;error in</span><br><span class="line">        print(&quot;请求失败：&quot;, error)</span><br><span class="line">    &#125;).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="1-4-转JSON"><a href="#1-4-转JSON" class="headerlink" title="1.4 转JSON"></a>1.4 转JSON</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URLSession.shared.rx.data(request: request)</span><br><span class="line">    .map &#123;</span><br><span class="line">        try JSONSerialization.jsonObject(with: $0, options: .allowFragments) as! [String: Any]</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe(onNext: &#123; data in</span><br><span class="line">        print(&quot;请求成功&quot;)</span><br><span class="line">    &#125;, onError: &#123; error in</span><br><span class="line">        print(&quot;请求失败：&quot;, error)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p>直接使用 rx.json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URLSession.shared.rx.json(request: request)</span><br><span class="line">    .subscribe(onNext: &#123; data in</span><br><span class="line">        let json &#x3D; data as! [String: Any]</span><br><span class="line">        print(&quot;请求成功&quot;)</span><br><span class="line">    &#125;, onError: &#123; error in</span><br><span class="line">        print(&quot;请求失败：&quot;, error)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

































<p><a href="https://www.hangge.com/blog/cache/detail_2010.html">URLSession使用</a></p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/11/14/hello-world/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="48e31149c438b31829246723271e19d6d0977e5f2df026e3e65f815a03a2237e">ccbf2489ed1a233f216cac1e5dda3d49363c641c556918697fb036546f666b01c7abc45d1943ee9d3408364bd5f46f8570100184557ff9fee405fe56e18b4fd58e086651cbf73064170efc9aedd861898b24a00cfcc3fee3b474b0b571c30f593250c8f7c8c24e627500f5e8c161baa4c36a516fbada282e10e2387441140a89de99961057f1486af8d17c1f891e290c2c1c5834a44d398955fca41b52fb113d52fce8c82f3f05d861bc4bac05e6bedc4f572f4aef60c81250f6758ca5c6611de62bf8a78acd96a3d3f49673040ff9a410ba932192472a21992fc57c329690bc2c930b6950232c8079bcc8ddac7252699cfb36533216ae373b44d02cb7dbb4a1bbdf2a5e938afd1e3e78bf0916f51f3b449809c5267d2fe5850bd5d31e97afbf96342e61c7f87ee5a43ab33c86fe76453bc1072ce91df88fe7bca55722dc893aaf79418c66ff77d76ac7d6699810b133b7758a0be14aef449fd343ef1376fec2a73cd20c02d407df46c6ab7fd86511af99f4916779688c557125b40cbc82d9a249aa9b9e285ae0fb9e258cabb6cce3597958eeb95ab18ec0b3c07943c054b7b28bc0f4f77ba12cb76eee3df04b6b4ff322bd34c093a1c4ab7d9db74fc47592f389f280fefcce7fd4e0fce2945368e91bbeb02eb882822c402116acb46283ed0d86be720cb21722ff1f1cb64b8756d3214951ec4c7e97d97d203d97dbef79d7fda19260dd8e107b7339d846d15442a16ed2459d3ee85104594bf30ef9aec082bc407db0dabf770cb13f65cbdba76e70922c7bef6362c59fc80949ce7d9362744c5ef31b35189aef8be5acdca2c5630d0b36c5804884fc0f5827390f969081366873895550e5ef0e82b9eb65951d778000a330e3194c8f9f8760736124680b64ae82376e8245dc6a52c348f70707047ec801acee613dc826321cf7be399c6c2efe2f3fd80523450630915846b4b1f409c6629c786e98d35f0fc7e1a816a62ee722c313c88d72c14770f86767afd07db1628b298924f7d1e6fb6a03372460f87fce293ab1b6e0c50abce375e6d257dc17edc2a955339e6d4fda9309e309b1f2b9e9d35744b8003e3945d5d1467a4b6bf791e7218e4bba0ce339c6ebfc4016ae63e6674c7be5dc978290a08f4f716affb3615ca0e7120135937acc9a0b5e398ce3bbf3db2b275da049032ea9e66e3b782e646fdbdb15914c5832bd0a25a6d0158a32e028fc89aa33fb2fc29d6f8cfb3a98eff80dbcdac046c93720fe854e9273d01aa0c4ae930aa312a87b272dc0351862bdbfc193657968cea438ace70d5ebb7ab440132f23c9807c6578b6139577b6089bf5b4a7c8cdc25fdbee69dfa8ecaeae3a7a28773f198292b0ea59234da65d8a450898ca3d913d2963c1cf324a597995654a144129bb631716b4b6d5b6d8af08ccf3ee99a36d6a0d00d2dfe87511b5e02ba24d990270cf8819a771ed282e1e762932d29fed355bb5900992107c58998647ce327deca6f8edc198581d008eef7bcc94e4422e5162140b60d115ce3c7ee1da3a8a2769d893f4f863c11bbb4c569591d9f1e86ac8ca7fba4a32182c227ad1f6861891b0d89fa4fb3630e25b844fe195228b85308437f5837a88715f2cb9061d4b8000559c6cd3e78f26b8a165765edc61e9eced4d00290061df3e6cdf03e381feafa39a22b783b5f1a5014eed3d2eb4f70fc18be3336ee03f928d26ea73ad8db238230805141c010104611b1bd269170cae8b6d493bbb2288ca13eeabd3100001e5d6e58c66704754be022a30f20ad2a09153260f2508c8f045e52b3a8520d86cf8d0eaf119c65c86c19e05117bd7c8c2b01a8fe78afb98efb0fd2f5ac5f0eeff18deb100a7645ab8f847d1d96de3bcea8223f0d3881da12b14ea767d6b15ad3d1f33eb8bf7c3dffb0f430b05470c25ea80b0933240dfe7bbfbd3767ceacec4430b8b51d7fe5c5afb271f4dd9c68c35dab8d49b6961c6255924f086a97d759c62a41111625b6c2ae4331fea540e7c5c95ba470756f6989f333a022cdcd55dbd1f05fc27cff68bc5aed07e3a2f37fd360a452ddf3555b1d2c86a8f8c6d06ed0c880b442a8aade2daf8b853f1a7447abfad5194047ac1436768deaf8b5f1265cf0bf5827fe5fdc314b6768bfcc490c7847a1de34fd40603b110af9c537d5de2d9bdfd12ed8f874e96a3d23749f72a795ffcfdcb3bf0469b756e4a1f3743014ccff1530ea0e7904e54ac5774b30fdaa4d582307ab5db6baf258a4ef88d5cf8e294a1e261967f3a27604463e1f3612a35ebd64104d0fa22f156db0b1995d7333fe3190f9c0ffb110aabec61f094c42124de30bfa166d8be884a7171ec575847b6666abe260e2bab7686ac226fc4ac854d179ddf1f48170785db3ef2fa21a17e8a9db4eaa21888fac829f404a16b097bd856e6bf1873bd7c73b75dfc413449f4c0f5639eaa8fe917ab368adf6c856f915c73065650719b2ec5fb9554b37b99057f6a9526f2b59978c1b56d3973053c71d19305c6ca2d8d730502ffc827d96b0f1c223816bdbb0018a2f4f9e5dba04a37f46f19f8a5dec321967b545d7399d0b6918c7d0fa1bf31b0e39b99c32e5533bd1e2499dae2ae1b2d959c3938fdcc3e39b4546fcc002366877219e177edfd62f7e36e35294885c03bf00b1cb0747c738c590a06c722854d814ab789a4a43662901dac610b95d092f2ce434158fb263384edbf59a3e9d2cec30ee92ab9492bab918b91af9f17ca807f71d4c5be3bcf364108e4d627cfa7ebc57651920ecc15922ef17ac102540b079fe215fd5163653f5b7b6ea6ed73f60bf967106bbc92b3c45e62e5ad90ede233f1f7587e39f508b7fb753c2f4bf27848107f2d0ca317e340e0f6c607fb8dbb9ce76aa8a4238fed6070fe07fc019d3eaa2c467e5d9c283e4ab975bf55cc61447621e30fa9b1476c028e5e68c25abdeadd97e791862cb281862cdd08488563233f8d9f0cbb47288714475f334669a8f84793164754abb59541e7d3b2595354c9f7283c4e56169190a61faeb83f93c149e8c83fd3c58cbfdaab6e304139ff97c5604fa4d714abf41c48d02b4600a4975bd758f60d689f319fdb9b5bb067800250c9b0185cc260993e3e711981</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Encrypt</category>
      </categories>
      <tags>
        <tag>Encrypt</tag>
      </tags>
  </entry>
  <entry>
    <title>objc-781编译</title>
    <url>/2020/12/04/objc-781%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">macOS 10.15.7</span><br><span class="line"></span><br><span class="line">Xcode 11.3.1</span><br><span class="line"></span><br><span class="line">objc4-781</span><br></pre></td></tr></table></figure>



<h4 id="Runtime源码下载"><a href="#Runtime源码下载" class="headerlink" title="Runtime源码下载"></a>Runtime源码下载</h4><p><a href="https://opensource.apple.com/">Apple Open Source</a> 选择最新 <code>macOS</code> 系统 <code>10.15.6</code> ，搜索 <code>objc</code> 看到最新 <code>objc4</code>文件为 <code>objc4-787.1</code>，右边可以直接下载压缩包</p>
<p><img src="/2020/12/04/objc-781%E7%BC%96%E8%AF%91/AppleOpenSource.jpg" alt="AppleOpenSource"></p>
<p>可以下载历史版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;opensource.apple.com&#x2F;tarballs&#x2F;objc4&#x2F;</span><br></pre></td></tr></table></figure>



<h4 id="下载依赖文件"><a href="#下载依赖文件" class="headerlink" title="下载依赖文件"></a>下载依赖文件</h4><p><img src="/2020/12/04/objc-781%E7%BC%96%E8%AF%91/%E4%BE%9D%E8%B5%96%E6%96%87%E4%BB%B6.png" alt="依赖文件"></p>
<h4 id="Runtime源码编译"><a href="#Runtime源码编译" class="headerlink" title="Runtime源码编译"></a>Runtime源码编译</h4><p>【1】<code>unable to find sdk macosx.internal</code></p>
<p><img src="/2020/12/04/objc-781%E7%BC%96%E8%AF%91/macosx.jpg" alt="macosx"></p>
<p>修改 <code>Base SDK</code> 选择 <code>macOS</code></p>
<p><img src="/2020/12/04/objc-781%E7%BC%96%E8%AF%91/baseSDK.png" alt="baseSDK"></p>
<p>【2】<code>file not foud</code></p>
<p>【2.1】<code>sys/reason.h file not found objc-os.h</code></p>
<p>根目录创建 <code>Common</code> 文件夹，创建 <code>sys</code> 文件 ，加入文件 <code>xnu-6153141.1/bsd/sys/reason.h</code></p>
<p>设置文件检索路径，<code>Header Search Path</code> 添加 <code>$(SRCROOT)/Common</code></p>
<p><img src="/2020/12/04/objc-781%E7%BC%96%E8%AF%91/searchPath.png" alt="searchPath"></p>
<p>【2.2】其它 <code>file not found</code></p>
<ul>
<li>mach-o/dyld_priv.h file not found`</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dyld-750.6&#x2F;include&#x2F;mach-o&#x2F;dyld_priv.h</span><br></pre></td></tr></table></figure>

<ul>
<li><code>os/lock_private.h file not found</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">libplatform-220.100.1&#x2F;private&#x2F;os&#x2F;lock_private.h</span><br></pre></td></tr></table></figure>

<ul>
<li><code>os/base_private.h file not found</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">libplatform-220.100.1&#x2F;private&#x2F;os&#x2F;base_private.h</span><br></pre></td></tr></table></figure>

<ul>
<li><code>pthread/tsd_private.h file not found</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">libpthread-416.100.3&#x2F;private&#x2F;tsd_private.h</span><br></pre></td></tr></table></figure>

<ul>
<li><code>System/machine/cpu_capabilities.h file not found</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xnu-6153.141.1&#x2F;osfmk&#x2F;machine&#x2F;cpu_capabilities.h</span><br></pre></td></tr></table></figure>

<ul>
<li><code>os/tsd.h file not found</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xnu-6153.141.1&#x2F;libsyscall&#x2F;os&#x2F;tsd.h</span><br></pre></td></tr></table></figure>

<ul>
<li><code>pthread/spinlock_private.h file not found</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">libpthread-416.100.3&#x2F;private&#x2F;spinlock_private.h</span><br></pre></td></tr></table></figure>

<ul>
<li><code>System/pthread_machdep.h file not found</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Libc-583&#x2F;pthreads&#x2F;pthread_machdep.h</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CrashReporterClient.h file not found</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Libc-997.90.3&#x2F;include&#x2F;CrashReporterClient.h</span><br></pre></td></tr></table></figure>

<ul>
<li><code>objc-shared-cache.h file not found</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dyld-750.6&#x2F;include&#x2F;objc-shared-cache.h</span><br></pre></td></tr></table></figure>

<ul>
<li><code>_simple.h file not found</code> </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">libplatform-220.100.1&#x2F;private&#x2F;_simple.h</span><br></pre></td></tr></table></figure>

<ul>
<li><code>kern/restartable.h file not found</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xnu-6153.141.1&#x2F;osfmk&#x2F;kern&#x2F;restartable.h</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Block_private.h file not found</code> </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">libclosure-74&#x2F;Block_private.h</span><br></pre></td></tr></table></figure>



<p>【3】<code>pthread_machdep.h</code> 3处报错</p>
<p>将 193 行</p>
<p> <code>typedef int pthread_lock_t;</code></p>
<p>到 244 行</p>
<p><code>#define _pthread_setspecific_direct(key, val) pthread_setspecific(key, val)</code> 注释</p>
<p>替换为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if TARGET_IPHONE_SIMULATOR || defined(__ppc__) || defined(__ppc64__) || \</span><br><span class="line">    (defined(__arm__) &amp;&amp; !defined(_ARM_ARCH_7) &amp;&amp; defined(_ARM_ARCH_6) &amp;&amp; defined(__thumb__))</span><br><span class="line">#define _pthread_getspecific_direct(key) pthread_getspecific((key))</span><br><span class="line">#define _pthread_setspecific_direct(key, val) pthread_setspecific((key), (val))</span><br><span class="line">#else</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>





<p>【4】<code>dyld_priv.h</code> 报错 <code>Expected&#39;,&#39;</code></p>
<p> 删掉 <code>, bridgeos(3.0)</code></p>
<p>【5】<code>lock_private.h</code> 报错 <code>Expected&#39;,&#39;</code></p>
<p>删掉 <code>, bridgeos(4.0)</code></p>
<p>【6】<code>Use of undeclared identifier &#39;DYLD_MACOSX_VERSION_10_11&#39;</code></p>
<p><code>dyld_priv.h</code> 顶部加入宏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define DYLD_MACOSX_VERSION_10_11 0x000A0B00</span><br><span class="line">#define DYLD_MACOSX_VERSION_10_12 0x000A0C00</span><br><span class="line">#define DYLD_MACOSX_VERSION_10_13 0x000A0D00</span><br><span class="line">#define DYLD_MACOSX_VERSION_10_14 0x000A0E00</span><br></pre></td></tr></table></figure>



<p>【7】<code>Use of undeclared identifier &#39;CRGetCrashLogMessage&#39;</code></p>
<p><code>target -&gt; Build Setting -&gt; Preprocessor Macros</code></p>
<p> 添加 <code>LIBC_NO_LIBCRASHREPORTERCLIENT</code></p>
<p><img src="/2020/12/04/objc-781%E7%BC%96%E8%AF%91/macros.png" alt="macros"></p>
<p>【8】<code>Mismatch in debug-ness macros</code></p>
<p>注释 <code>#error mismatch in debug-ness macros</code></p>
<p>【9】</p>
<p><code>can&#39;t open order file: /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.0.sdk/AppleInternal/OrderFiles/libobjc.order</code></p>
<p><code>target -&gt; Build Settings</code> 搜索 <code>Order File</code> 添加 <code>$(SRCROOT)/libobjc.order</code></p>
<p>【10】<code>library not found for -lCrashReporterClient</code></p>
<p><code>target -&gt; Build Settings -&gt; Other Linker Flags</code> 删掉  <code>CrashReporterClient</code></p>
<p>【11】<code>SDK &quot;macosx.internal&quot; cannot be located</code></p>
<p><code>target -&gt; objc -&gt; Build Phase -&gt; Run Script(markgc)</code> 将脚本的 <code>macosx.internal</code> 修改为 <code>macosx</code></p>
<p>Build Success</p>
<h4 id="编译调试"><a href="#编译调试" class="headerlink" title="编译调试"></a>编译调试</h4><p>新建 <code>Target</code> 来进行调试</p>
<ul>
<li><code>File -&gt; New -&gt; Target</code> <code>Test</code></li>
</ul>
<p><img src="/2020/12/04/objc-781%E7%BC%96%E8%AF%91/target.png" alt="target"></p>
<ul>
<li>绑定二进制依赖关系</li>
</ul>
<p><code>TARGETS -&gt; Test -&gt; Build Phases</code></p>
<p> <img src="/2020/12/04/objc-781%E7%BC%96%E8%AF%91/depend.png" alt="target"></p>
<p>还需要设置 <code>target -&gt; objc -&gt; Build Settings -&gt; Enable Hardened Runtime -&gt; NO</code></p>
<p>注意 <code>Compile Sources</code> 中 <code>main.m</code> 位置在前面</p>
<p><img src="/2020/12/04/objc-781%E7%BC%96%E8%AF%91/compile.png" alt="compile"></p>
<p><a href="https://opensource.apple.com/release/mac-os-x-1062.html">Libc-583</a></p>
<p><a href="https://opensource.apple.com/release/os-x-1095.html"> Libc-997.90.3</a></p>
<p><a href="https://opensource.apple.com/release/macos-10156.html">dyld-750.6</a></p>
<p><a href="https://opensource.apple.com/release/macos-10156.html">libauto-187</a></p>
<p><a href="https://opensource.apple.com/release/macos-10156.html">libclosure-74</a></p>
<p><a href="https://opensource.apple.com/release/macos-10156.html">libdispatch-1173.100.2</a></p>
<p><a href="https://opensource.apple.com/release/macos-10156.html">xnu-6153.141.1</a></p>
<p><a href="https://opensource.apple.com/release/macos-10156.html">libpthread-416.100.3</a></p>
<p><a href="https://opensource.apple.com/release/macos-10156.html">libplatform-220.100.1</a></p>
<p><a href="https://opensource.apple.com/release/os-x-1095.html">launchd-842.92.1</a></p>
<p><a href="https://www.jianshu.com/p/28150fa0c085">objc4-750编译</a></p>
<p><a href="https://gitee.com/other_other/objc-781.git">objc4-781可编译代码</a></p>
<p><a href="https://github.com/chenjialin1016/objc4-debugTest">xcode12 objc4-781可编译代码</a></p>
]]></content>
  </entry>
  <entry>
    <title>_objc_init</title>
    <url>/2020/12/25/objc-init/</url>
    <content><![CDATA[<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>什么时候调用 <code>load</code></p>
<p>子类和父类及分类 <code>load</code> 方法调用顺序</p>
<p>子类和父类及分类 <code>initialize</code> 方法调用顺序</p>
<p><code>load</code> 方法调用是在应用程序 <code>main</code> 函数之前，应用启动时 <code>dyld</code> 处理完 <code>image</code> 镜像文件，通过回调传给 <code>runtime</code> ，交由 <code>runtime</code> 在 <code>load_images</code> 方法中调用</p>
<p>从系统库 <code>libSystem</code> 的 <code>runtime</code> 的入口函数 <code>_objc_init</code> 开始</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    <span class="comment">//读取影响运行时的环境变量</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    <span class="comment">//运行C C++静态构造函数</span></span><br><span class="line">    static_init();</span><br><span class="line">    runtime_init();</span><br><span class="line">    <span class="comment">//初始化libobjc的异常处理系统</span></span><br><span class="line">    exception_init();</span><br><span class="line">    cache_init();</span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line">		<span class="comment">//注册回调函数</span></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    didCallDyldNotifyRegister = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="map-images"><a href="#map-images" class="headerlink" title="map_images"></a>map_images</h4><p>主要将 Mach-O 中的类信息加载到内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">map_images(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> paths[],</span><br><span class="line">           <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> map_images_nolock(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>map_images_nolock</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">map_images_nolock(<span class="keyword">unsigned</span> mhCount, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> mhPaths[],</span><br><span class="line">                  <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">		... <span class="comment">//省略代码</span></span><br><span class="line">		<span class="keyword">if</span> (hCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      	<span class="comment">//读取镜像文件</span></span><br><span class="line">        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="read-images"><a href="#read-images" class="headerlink" title="_read_images"></a>_read_images</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _read_images(header_info **hList, <span class="keyword">uint32_t</span> hCount, <span class="keyword">int</span> totalClasses, <span class="keyword">int</span> unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>_read_images</code> 内部做了几件事情</p>
<p>【1】重新初始化 <code>TaggedPointer</code> 环境，创建 <code>gdb_objc_realized_classes</code> 表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!doneOnce) &#123;</span><br><span class="line">    doneOnce = YES;</span><br><span class="line">    launchTime = YES;</span><br><span class="line">    <span class="keyword">if</span> (DisableTaggedPointers) &#123;</span><br><span class="line">        disableTaggedPointers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initializeTaggedPointerObfuscator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;CLASS: found %d classes during launch&quot;</span>, totalClasses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// namedClasses</span></span><br><span class="line">    <span class="comment">// Preoptimized classes don&#x27;t go in this table.</span></span><br><span class="line">    <span class="comment">// 4/3 is NXMapTable&#x27;s load factor</span></span><br><span class="line">    <span class="keyword">int</span> namedClassesSize = </span><br><span class="line">        (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * <span class="number">4</span> / <span class="number">3</span>;</span><br><span class="line">    gdb_objc_realized_classes =</span><br><span class="line">        NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);</span><br><span class="line"></span><br><span class="line">    ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: first time tasks&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>。。。</p>
<h4 id="loadImages"><a href="#loadImages" class="headerlink" title="loadImages"></a>loadImages</h4><p>【1】进入 <code>load_images</code> 方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">load_images(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!didInitialAttachCategories &amp;&amp; didCallDyldNotifyRegister) &#123;</span><br><span class="line">        didInitialAttachCategories = <span class="literal">true</span>;</span><br><span class="line">        loadAllCategories();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></span><br><span class="line">    <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">recursive_mutex_locker_t</span> <span class="title">lock</span><span class="params">(loadMethodLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock2</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">        prepare_load_methods((<span class="keyword">const</span> headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>prepare</code> 加载完所有 <code>load</code>   -&gt;  <code>call_load_methods()</code> 调用 <code>load</code> 方法</p>
<h5 id="prepare-load-methods"><a href="#prepare-load-methods" class="headerlink" title="prepare_load_methods"></a><code>prepare_load_methods</code></h5><p>【2】<code>prepare_load_methods</code> 实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">		<span class="comment">//拿到当前类的列表</span></span><br><span class="line">    <span class="keyword">classref_t</span> <span class="keyword">const</span> *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//拿到分类列表</span></span><br><span class="line">    <span class="keyword">category_t</span> * <span class="keyword">const</span> *categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Swift class extensions and categories on Swift &quot;</span></span><br><span class="line">                        <span class="string">&quot;classes are not allowed to have +load methods&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        realizeClassWithoutSwift(cls, nil);</span><br><span class="line">        ASSERT(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【2.1】进入 <code>schedule_class_load</code> 方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_class_load</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    ASSERT(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering 递归加载 类 父类</span></span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归加载类、父类，加载完毕后添加到 <code>loadable_list</code> 表，</p>
<p>继续查看 <code>add_class_to_loadable_list</code> 方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_class_to_loadable_list</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    method = cls-&gt;getLoadMethod();</span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don&#x27;t bother if cls has no +load method</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;LOAD: class &#x27;%s&#x27; scheduled for +load&quot;</span>, </span><br><span class="line">                     cls-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_classes = (struct loadable_class *)</span><br><span class="line">            <span class="built_in">realloc</span>(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              <span class="keyword">sizeof</span>(struct loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">loadable_class</span> &#123;</span></span><br><span class="line">    Class cls;  <span class="comment">// may be nil</span></span><br><span class="line">    IMP method;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>loadable_list</code> 表中存储的结构体 <code>loadable_class</code> ，包含当前类 <code>cls</code> ，和该类的 <code>load</code> 方法 <code>IMP</code></p>
<p><code>method = cls-&gt;getLoadMethod();</code> 就是获取到该类的 <code>load</code> 方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IMP </span><br><span class="line">objc_class::getLoadMethod()</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">method_list_t</span> *mlist;</span><br><span class="line"></span><br><span class="line">    ASSERT(isRealized());</span><br><span class="line">    ASSERT(ISA()-&gt;isRealized());</span><br><span class="line">    ASSERT(!isMetaClass());</span><br><span class="line">    ASSERT(ISA()-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    mlist = ISA()-&gt;data()-&gt;ro()-&gt;baseMethods();</span><br><span class="line">    <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; meth : *mlist) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *name = sel_cname(meth.name);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(name, <span class="string">&quot;load&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> meth.imp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以 <code>schedule_class_load</code> 就是先获取父类，再递归调用 <code>schedule_class_load</code> 方法，把父类的父类 -&gt; 父类 -&gt; 子类，这些类和的 <code>load</code> 方法加入到 <code>loadable_classes</code> 表中</p>
<p>所以类的 <code>+(load)</code> 方法执行顺序：是从父类到子类</p>
<p>回到【2】在执行 <code>schedule_class_load</code> 添加完类后，继续处理分类，分类调用 <code>_category_getLoadMethod</code> 方法获取到分类中重写的 <code>load</code> 方法，调用 <code>add_category_to_loadable_list</code> 方法，把分类和分类的 <code>load</code> 方法添加到 <code>loadable_categories</code> 表中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">loadable_category</span> &#123;</span></span><br><span class="line">    Category cat;  <span class="comment">// may be nil</span></span><br><span class="line">    IMP method;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>总结 <code>prepare_load_methods</code>：</p>
<p>1、处理类：递归先父类再子类，获取类和类的<code>load</code> 方法，合成结构体 <code>loadable_class</code> ，添加到 <code>loadable_classes</code> 表中</p>
<p>2、处理分类：获取分类<code>load</code> 方法，合成结构体 <code>loadable_category</code> ，添加到 <code>loadable_categories</code> 表中</p>
<h5 id="call-load-methods"><a href="#call-load-methods" class="headerlink" title="call_load_methods"></a>call_load_methods</h5><p>【3】进入 <code>call_load_methods</code> 方法，<code>load</code> 方法的调用部分</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = NO;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren&#x27;t any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到有个 <code>do-while</code> 循环，<code>do-while</code> 循环里面会产生很多临时变量和函数，放到自动释放池里面，节省内存</p>
<p><code>do-while</code> 循环体部分可以看到 <code>load</code> 方法的调用是先调用主类，再调用分类的；下面<code>call_class_loads</code> 方法内</p>
<p>部从 <code>loadable_classes</code> 获取到类调用 <code>load</code> 方法也是先父类再子类</p>
<p>【3.1】查看 <code>call_class_loads</code> 方法实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call_class_loads</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">loadable_class</span> *<span class="title">classes</span> =</span> loadable_classes;</span><br><span class="line">    <span class="keyword">int</span> used = loadable_classes_used;</span><br><span class="line">    loadable_classes = nil;</span><br><span class="line">    loadable_classes_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_classes_used = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        <span class="keyword">load_method_t</span> load_method = (<span class="keyword">load_method_t</span>)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;LOAD: +[%s load]\n&quot;</span>, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        (*load_method)(cls, @selector(load));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Destroy the detached list.</span></span><br><span class="line">    <span class="keyword">if</span> (classes) <span class="built_in">free</span>(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从之前存储好的标 <code>loadable_classes</code> 中取出 <code>Class</code> 和 对应的 <code>load</code> 方法，直接调用</p>
<p>【3.2】<code>call_category_loads</code></p>
<p>从 <code>loadable_categories</code> 表中取出<code>loadable_category</code> ，通过 <code>_category_getClass</code> 获取分类对应的类，直接调用 <code>load</code> 方法</p>
<p><a href="https://www.jianshu.com/p/ea680941e084">深入APP启动之dyld、map_images、load_images</a></p>
]]></content>
  </entry>
  <entry>
    <title>《Flutter实战第二版》九：动画</title>
    <url>/2022/01/18/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E4%B9%9D%EF%BC%9A%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>《Flutter实战第二版》八：事件处理与通知</title>
    <url>/2022/01/18/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E5%85%AB%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E4%B8%8E%E9%80%9A%E7%9F%A5/</url>
    <content><![CDATA[<h3 id="8-事件处理与通知"><a href="#8-事件处理与通知" class="headerlink" title="8 事件处理与通知"></a>8 事件处理与通知</h3><h4 id="8-1-原始指针事件处理"><a href="#8-1-原始指针事件处理" class="headerlink" title="8.1 原始指针事件处理"></a>8.1 原始指针事件处理</h4><p>Flutter 中可以使用 Listener 来监听原始触摸事件</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Listener(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="keyword">this</span>.onPointerDown, <span class="comment">//手指按下回调</span></span><br><span class="line">  <span class="keyword">this</span>.onPointerMove, <span class="comment">//手指移动回调</span></span><br><span class="line">  <span class="keyword">this</span>.onPointerUp,<span class="comment">//手指抬起回调</span></span><br><span class="line">  <span class="keyword">this</span>.onPointerCancel,<span class="comment">//触摸事件取消回调</span></span><br><span class="line">  <span class="keyword">this</span>.behavior = HitTestBehavior.deferToChild, <span class="comment">//先忽略此参数，后面小节会专门介绍</span></span><br><span class="line">  Widget child</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>示例</li>
</ul>
<p>手指在容器上移动时查看手指相对于容器的位置</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_DemoState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">Demo</span>&gt; </span>&#123;</span><br><span class="line">  PointerEvent? _event;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">&#x27;标题&#x27;</span>)),</span><br><span class="line">      body: Listener(</span><br><span class="line">        child: Container(</span><br><span class="line">          alignment: Alignment.center,</span><br><span class="line">          color: Colors.blue,</span><br><span class="line">          width: <span class="number">300.0</span>,</span><br><span class="line">          height: <span class="number">150.0</span>,</span><br><span class="line">          child: Text(<span class="string">&#x27;<span class="subst">$&#123;_event?.localPosition ?? <span class="string">&#x27;&#x27;</span>&#125;</span>&#x27;</span>,style: TextStyle(color: Colors.white)),</span><br><span class="line">        ),</span><br><span class="line">        onPointerDown: (PointerDownEvent event) =&gt; setState(() =&gt; _event = event),</span><br><span class="line">        onPointerMove: (PointerMoveEvent event) =&gt; setState(() =&gt; _event = event),</span><br><span class="line">        onPointerUp: (PointerUpEvent event) =&gt; setState(() =&gt; _event = event),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》八：事件处理与通知/WeChat2b7b8f8ebecd7a3a530fce169a8d1389.png" alt="WeChat2b7b8f8ebecd7a3a530fce169a8d1389" style="zoom:80%;" />

<p>PointerEvent 类中包括当前指针的一些信息<br>position：指针相对于全局坐标的偏移<br>delta：两次指针移动事件（PointerMoveEvent）的距离<br>pressure：按压力度，如果手机不支持压力传感器，则始终为1<br>orientation：指针移动方向，是一个角度值</p>
<ul>
<li>忽略指针事件</li>
</ul>
<p>如果不想让某个子树响应 PointerEvent 的话，可以使用 IgnorePointer 和 AbsorbPointer，两个组件都能阻止子树接收指针事件；不同在于 AbsorbPointer 会参与命中测试（Hit Test）IgnorePointer 不会，意味着 AbsorbPointer 本身是可以接收指针事件的（但其子树不行）</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Listener(</span><br><span class="line">  child: AbsorbPointer(</span><br><span class="line">    child: Listener(</span><br><span class="line">      child: Container(</span><br><span class="line">        color: Colors.red,</span><br><span class="line">        width: <span class="number">200.0</span>,</span><br><span class="line">        height: <span class="number">100.0</span>,</span><br><span class="line">      ),</span><br><span class="line">      onPointerDown: (event)=&gt;<span class="built_in">print</span>(<span class="string">&quot;in&quot;</span>),</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">  onPointerDown: (event)=&gt;<span class="built_in">print</span>(<span class="string">&quot;up&quot;</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>点击 Container 会输出 up，换成 IgnorePointer 两个都不会输出</p>
<h4 id="8-2-手势识别"><a href="#8-2-手势识别" class="headerlink" title="8.2 手势识别"></a>8.2 手势识别</h4><h5 id="8-2-1-GestureDetector"><a href="#8-2-1-GestureDetector" class="headerlink" title="8.2.1 GestureDetector"></a>8.2.1 GestureDetector</h5><p>手势识别的功能性组件，内部封装了 Listener</p>
<ul>
<li>点击、双击、长按</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_DemoState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">Demo</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> _operation = <span class="string">&quot;No Gesture detected!&quot;</span>; <span class="comment">//保存事件名</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">&#x27;标题&#x27;</span>)),</span><br><span class="line">      body: GestureDetector(</span><br><span class="line">        child: Container(</span><br><span class="line">          alignment: Alignment.center,</span><br><span class="line">          color: Colors.blue,</span><br><span class="line">          width: <span class="number">200.0</span>,</span><br><span class="line">          height: <span class="number">100.0</span>,</span><br><span class="line">          child: Text( _operation, style: TextStyle(color: Colors.white)),</span><br><span class="line">        ),</span><br><span class="line">        onTap: () =&gt; updateText(<span class="string">&quot;Tap&quot;</span>), <span class="comment">//点击</span></span><br><span class="line">        onDoubleTap: () =&gt; updateText(<span class="string">&quot;DoubleTap&quot;</span>), <span class="comment">//双击</span></span><br><span class="line">        onLongPress: () =&gt; updateText(<span class="string">&quot;LongPress&quot;</span>), <span class="comment">//长按</span></span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> updateText(<span class="built_in">String</span> text) &#123;</span><br><span class="line">    <span class="comment">//更新显示的事件名</span></span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _operation = text;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>拖动、滑动</li>
</ul>
<p>GestureDetector 会将要监听的组件的原点（左上角）作为本次手势的原点</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_DemoState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">Demo</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> _top = <span class="number">0.0</span>; <span class="comment">//距顶部的偏移</span></span><br><span class="line">  <span class="built_in">double</span> _left = <span class="number">0.0</span>;<span class="comment">//距左边的偏移</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">&#x27;标题&#x27;</span>)),</span><br><span class="line">      body: Stack(</span><br><span class="line">        children: [</span><br><span class="line">          Positioned(</span><br><span class="line">            top: _top,</span><br><span class="line">            left: _left,</span><br><span class="line">            child: GestureDetector(</span><br><span class="line">              child: CircleAvatar(child: Text(<span class="string">&#x27;A&#x27;</span>)),</span><br><span class="line">              <span class="comment">//手指按下时会触发此回调</span></span><br><span class="line">              onPanDown: (DragDownDetails e) &#123;</span><br><span class="line">                <span class="comment">//打印手指按下的位置(相对于屏幕)</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;用户手指按下：<span class="subst">$&#123;e.globalPosition&#125;</span>&quot;</span>);</span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="comment">//手指滑动时会触发此回调</span></span><br><span class="line">              onPanUpdate: (DragUpdateDetails e) &#123;</span><br><span class="line">                <span class="comment">//用户手指滑动时，更新偏移，重新构建</span></span><br><span class="line">                setState(() &#123;</span><br><span class="line">                  _left += e.delta.dx;</span><br><span class="line">                  _top += e.delta.dy;</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;,</span><br><span class="line">              onPanEnd: (DragEndDetails e)&#123;</span><br><span class="line">                <span class="comment">//打印滑动结束时在x、y轴上的速度</span></span><br><span class="line">                <span class="built_in">print</span>(e.velocity);</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》八：事件处理与通知/WeChat086c3a31a2342c497e33c9b744b41fc2.png" alt="WeChat086c3a31a2342c497e33c9b744b41fc2" style="zoom:80%;" />

<p>DragDownDetails.globalPosition：用户按下时，按下位置相对于屏幕（非父组件）原点（左上角）的偏移</p>
<p>DragUpdateDetails.delta：屏幕上滑动时，会对次触发 Update 事件，delta 指一次 Update 事件的滑动的偏移量</p>
<p>DragEndDetails.velocity：用户抬起手指时的滑动速度</p>
<ul>
<li>单一方向拖动</li>
</ul>
<p>GestureDetector 可以只识别特定方向的手势事件</p>
<p>改成只能沿垂直方向拖动</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">child: GestureDetector(</span><br><span class="line">    child: CircleAvatar(child: Text(<span class="string">&quot;A&quot;</span>)),</span><br><span class="line">    <span class="comment">//垂直方向拖动事件</span></span><br><span class="line">    onVerticalDragUpdate: (DragUpdateDetails details) &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        _top += details.delta.dy;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>缩放</li>
</ul>
<p>GestureDetector 可以监听缩放事件</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Scale</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _Scale(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ScaleState createState() =&gt; _ScaleState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ScaleState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">_Scale</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">double</span> _width = <span class="number">200.0</span>; <span class="comment">//通过修改图片宽度来达到缩放效果</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: GestureDetector(</span><br><span class="line">        <span class="comment">//指定宽度，高度自适应</span></span><br><span class="line">        child: Image.asset(<span class="string">&quot;./images/sea.png&quot;</span>, width: _width),</span><br><span class="line">        onScaleUpdate: (ScaleUpdateDetails details) &#123;</span><br><span class="line">          setState(() &#123;</span><br><span class="line">            <span class="comment">//缩放倍数在0.8到10倍之间</span></span><br><span class="line">            _width=<span class="number">200</span>*details.scale.clamp(<span class="number">.8</span>, <span class="number">10.0</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-2-2-GestureRecognizer"><a href="#8-2-2-GestureRecognizer" class="headerlink" title="8.2.2 GestureRecognizer"></a>8.2.2 GestureRecognizer</h5><h4 id="8-3-Flutter-事件机制"><a href="#8-3-Flutter-事件机制" class="headerlink" title="8.3 Flutter 事件机制"></a>8.3 Flutter 事件机制</h4><h4 id="8-4-手势原理与手势冲突"><a href="#8-4-手势原理与手势冲突" class="headerlink" title="8.4 手势原理与手势冲突"></a>8.4 手势原理与手势冲突</h4><h4 id="8-5-事件总线"><a href="#8-5-事件总线" class="headerlink" title="8.5 事件总线"></a>8.5 事件总线</h4><h4 id="8-6-通知-Notification"><a href="#8-6-通知-Notification" class="headerlink" title="8.6 通知 Notification"></a>8.6 通知 Notification</h4>]]></content>
  </entry>
  <entry>
    <title>《Flutter实战第二版》十三：国际化</title>
    <url>/2022/03/02/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E5%8D%81%E4%B8%89%EF%BC%9A%E5%9B%BD%E9%99%85%E5%8C%96/</url>
    <content><![CDATA[<h5 id="13-1-2-支持国际化"><a href="#13-1-2-支持国际化" class="headerlink" title="13.1.2 支持国际化"></a>13.1.2 支持国际化</h5><p>pubspec.yaml 添加 flutter_localizations 的依赖包</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  flutter:</span><br><span class="line">    sdk: flutter</span><br><span class="line">  flutter_localizations:</span><br><span class="line">    sdk: flutter</span><br></pre></td></tr></table></figure>

<p>指定 MaterialApp 的 localizationsDelegates 和 supportedLocales</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter_localizations/flutter_localizations.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MyApp(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      localizationsDelegates: [</span><br><span class="line">        GlobalMaterialLocalizations.delegate,</span><br><span class="line">        GlobalWidgetsLocalizations.delegate,</span><br><span class="line">      ],</span><br><span class="line">      supportedLocales: [</span><br><span class="line">        Locale(<span class="string">&#x27;en&#x27;</span>, <span class="string">&#x27;US&#x27;</span>),<span class="comment">// 美国英语 Locale 包括语言和国家两个标志</span></span><br><span class="line">        Locale(<span class="string">&#x27;zh&#x27;</span>, <span class="string">&#x27;CN&#x27;</span>),<span class="comment">// 中文简体</span></span><br><span class="line">        <span class="comment">//其它Locales</span></span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 MaterialApp 类为入口的应用不同，对基于 WidgetsApp 类为入口的应用进行国际化时不需要 GlobalMaterialLocalizations.delegate</p>
<p>GlobalMaterialLocalizations.delegate 为 Material 组件库提供的本地化的字符串和其它值，可以使 Material 组件支持多语言<br>GlobalWidgetsLocalizations.delegate 定义组件默认的文本方向，从左到右或从右到左<br>supportedLocales 应用支持的语言列表</p>
<h5 id="13-1-3-获取当前区域-Locale"><a href="#13-1-3-获取当前区域-Locale" class="headerlink" title="13.1.3 获取当前区域 Locale"></a>13.1.3 获取当前区域 Locale</h5><p>Locale 类是用来标识用户的语言环境的，包括语言和国家两个标志</p>
<p>获取当前区域 Locale</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Locale myLocale = Localizations.localeOf(context);</span><br></pre></td></tr></table></figure>

<h5 id="13-1-4-监听系统语言切换"><a href="#13-1-4-监听系统语言切换" class="headerlink" title="13.1.4 监听系统语言切换"></a>13.1.4 监听系统语言切换</h5><p>当更改系统语言设置时，APP 中的 Localizations 组件会重新构建，Localizations.localeOf(context) 获取的 Locale 就会更新，最终界面会重新 build</p>
<p>可以通过 localeResolutionCallback 或 localeListResolutionCallback 回调来监听 Locale 改变事件</p>
<h4 id="13-3-使用-Intl-包"><a href="#13-3-使用-Intl-包" class="headerlink" title="13.3 使用 Intl 包"></a>13.3 使用 Intl 包</h4><h5 id="13-3-1-添加依赖"><a href="#13-3-1-添加依赖" class="headerlink" title="13.3.1 添加依赖"></a>13.3.1 添加依赖</h5><p>使用 Intl 包可以非常轻松的实现国际化</p>
<p>添加两个依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  intl: ^0.17.0 </span><br><span class="line">dev_dependencies:</span><br><span class="line">  intl_generator:  0.2.1 </span><br></pre></td></tr></table></figure>

<p>intl_generator 组要包含了一些工具，开发阶段主要作用是从代码中提取要国际化的字符串到单独的 arb 文件，和根据 arb 文件生成对应语言的 dart 代码。而 intl 包主要是引用和加载 intl——generator 生成后的 dart 代码</p>
<h5 id="13-3-2-创建必要目录"><a href="#13-3-2-创建必要目录" class="headerlink" title="13.3.2 创建必要目录"></a>13.3.2 创建必要目录</h5><p>根目录创建 l10n-arb 目录，保存接下来通过 intl_generator 命令生成的 arb 文件</p>
<p>lib 目录下创建 l10n 目录，保存从 arb 文件生成的 dart 代码文件</p>
<h5 id="13-3-3-实现-Localizations-和-Delegate-类"><a href="#13-3-3-实现-Localizations-和-Delegate-类" class="headerlink" title="13.3.3 实现 Localizations 和 Delegate 类"></a>13.3.3 实现 Localizations 和 Delegate 类</h5>]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>《Flutter实战第二版》十五：一个完整的Flutter应用</title>
    <url>/2022/01/28/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E5%8D%81%E4%BA%94%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84Flutter%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h3 id="15-一个完整的-Flutter-应用"><a href="#15-一个完整的-Flutter-应用" class="headerlink" title="15 一个完整的 Flutter 应用"></a>15 一个完整的 Flutter 应用</h3><h4 id="15-1-Github-客户端示例"><a href="#15-1-Github-客户端示例" class="headerlink" title="15.1 Github 客户端示例"></a>15.1 Github 客户端示例</h4><p>需要实现功能：</p>
<p>Github 账号登录、退出登录<br>登录后查看自己项目主页<br>支持换肤<br>支持多语言<br>登录状态持久化</p>
<h4 id="15-2-APP-代码结构"><a href="#15-2-APP-代码结构" class="headerlink" title="15.2 APP 代码结构"></a>15.2 APP 代码结构</h4><img src="《Flutter实战第二版》十五：一个完整的Flutter应用/WeChat3794f9d995c042b43f483a645aedb4d0.png" alt="WeChat3794f9d995c042b43f483a645aedb4d0" style="zoom:76%;" />

<p>l10n-arg 文件夹用于保存各国语言对应的 arb 文件</p>
<img src="《Flutter实战第二版》十五：一个完整的Flutter应用/WeChat34b91b756765ef038ab6c2be2dba0c3a.png" alt="WeChat34b91b756765ef038ab6c2be2dba0c3a"  />

<table>
<thead>
<tr>
<th>文件夹</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>common</td>
<td>一些工具类，如通用方法类、网络接口类、保存全局变量的静态类等</td>
</tr>
<tr>
<td>l10n</td>
<td>国际化相关的类都在此目录下</td>
</tr>
<tr>
<td>models</td>
<td>Json文件对应的Dart Model类会在此目录下</td>
</tr>
<tr>
<td>states</td>
<td>保存APP中需要跨组件共享的状态类</td>
</tr>
<tr>
<td>routes</td>
<td>存放所有路由页面类</td>
</tr>
<tr>
<td>widgets</td>
<td>APP内封装的一些Widget组件都在该目录下</td>
</tr>
</tbody></table>
<h4 id="15-3-Model-类定义"><a href="#15-3-Model-类定义" class="headerlink" title="15.3 Model 类定义"></a>15.3 Model 类定义</h4><ul>
<li>Github 账号信息</li>
</ul>
<p>Github API 接口返回 json 结构如下</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;login&quot;</span>: <span class="string">&quot;octocat&quot;</span>, <span class="comment">//用户登录名</span></span><br><span class="line">  <span class="string">&quot;avatar_url&quot;</span>: <span class="string">&quot;https://github.com/images/error/octocat_happy.gif&quot;</span>, <span class="comment">//用户头像地址</span></span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;User&quot;</span>, <span class="comment">//用户类型，可能是组织</span></span><br><span class="line">  <span class="string">&quot;name?&quot;</span>: <span class="string">&quot;monalisa octocat&quot;</span>, <span class="comment">//用户名字</span></span><br><span class="line">  <span class="string">&quot;company?&quot;</span>: <span class="string">&quot;GitHub&quot;</span>, <span class="comment">//公司</span></span><br><span class="line">  <span class="string">&quot;blog?&quot;</span>: <span class="string">&quot;https://github.com/blog&quot;</span>, <span class="comment">//博客地址</span></span><br><span class="line">  <span class="string">&quot;location?&quot;</span>: <span class="string">&quot;San Francisco&quot;</span>, <span class="comment">// 用户所处地理位置</span></span><br><span class="line">  <span class="string">&quot;email?&quot;</span>: <span class="string">&quot;octocat@github.com&quot;</span>, <span class="comment">// 邮箱</span></span><br><span class="line">  <span class="string">&quot;hireable?&quot;</span>: <span class="keyword">false</span>,</span><br><span class="line">  <span class="string">&quot;bio?&quot;</span>: <span class="string">&quot;There once was...&quot;</span>, <span class="comment">// 用户简介</span></span><br><span class="line">  <span class="string">&quot;public_repos&quot;</span>: <span class="number">2</span>, <span class="comment">// 公开项目数</span></span><br><span class="line">  <span class="string">&quot;followers&quot;</span>: <span class="number">20</span>, <span class="comment">//关注该用户的人数</span></span><br><span class="line">  <span class="string">&quot;following&quot;</span>: <span class="number">0</span>, <span class="comment">// 该用户关注的人数</span></span><br><span class="line">  <span class="string">&quot;created_at&quot;</span>: <span class="string">&quot;2008-01-14T04:33:35Z&quot;</span>, <span class="comment">// 账号创建时间</span></span><br><span class="line">  <span class="string">&quot;updated_at&quot;</span>: <span class="string">&quot;2008-01-14T04:33:35Z&quot;</span>, <span class="comment">// 账号信息更新时间</span></span><br><span class="line">  <span class="string">&quot;total_private_repos&quot;</span>: <span class="number">100</span>, <span class="comment">//该用户总的私有项目数(包括参与的其它组织的私有项目)</span></span><br><span class="line">  <span class="string">&quot;owned_private_repos&quot;</span>: <span class="number">100</span> <span class="comment">//该用户自己的私有项目数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jsons 目录下创建一个 user.json 文件保存</p>
<ul>
<li>API 缓存策略信息</li>
</ul>
<p>创建 cacheConfig.json 文件缓存策略</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;enable&quot;</span>:<span class="keyword">true</span>, <span class="comment">// 是否启用缓存</span></span><br><span class="line">  <span class="string">&quot;maxAge&quot;</span>:<span class="number">1000</span>, <span class="comment">// 缓存的最长时间，单位（秒）</span></span><br><span class="line">  <span class="string">&quot;maxCount&quot;</span>:<span class="number">100</span> <span class="comment">// 最大缓存数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>用户信息</li>
</ul>
<p>profile.json </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;user?&quot;</span>:<span class="string">&quot;<span class="subst">$user</span>&quot;</span>, <span class="comment">//Github账号信息，结构见&quot;user.json&quot;</span></span><br><span class="line">  <span class="string">&quot;token?&quot;</span>:<span class="string">&quot;&quot;</span>, <span class="comment">// 登录用户的token(oauth)或密码</span></span><br><span class="line">  <span class="string">&quot;theme&quot;</span>:<span class="number">0</span>, <span class="comment">//主题索引</span></span><br><span class="line">  <span class="string">&quot;cache?&quot;</span>:<span class="string">&quot;<span class="subst">$cacheConfig</span>&quot;</span>, <span class="comment">// 缓存策略信息，结构见&quot;cacheConfig.json&quot;</span></span><br><span class="line">  <span class="string">&quot;lastLogin?&quot;</span>:<span class="string">&quot;&quot;</span>, <span class="comment">//最近一次的注销登录的用户名</span></span><br><span class="line">  <span class="string">&quot;locale?&quot;</span>:<span class="string">&quot;&quot;</span> <span class="comment">// APP语言信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>项目信息</li>
</ul>
<p>repo.json 文件保存项目信息</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;id&quot;</span>: <span class="number">1296269</span>,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Hello-World&quot;</span>, <span class="comment">//项目名称</span></span><br><span class="line">  <span class="string">&quot;full_name&quot;</span>: <span class="string">&quot;octocat/Hello-World&quot;</span>, <span class="comment">//项目完整名称</span></span><br><span class="line">  <span class="string">&quot;owner&quot;</span>: <span class="string">&quot;<span class="subst">$user</span>&quot;</span>, <span class="comment">// 项目拥有者，结构见&quot;user.json&quot;</span></span><br><span class="line">  <span class="string">&quot;parent?&quot;</span>:<span class="string">&quot;<span class="subst">$repo</span>&quot;</span>, <span class="comment">// 如果是fork的项目，则此字段表示fork的父项目信息</span></span><br><span class="line">  <span class="string">&quot;private&quot;</span>: <span class="keyword">false</span>, <span class="comment">// 是否私有项目</span></span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;This your first repo!&quot;</span>, <span class="comment">//项目描述</span></span><br><span class="line">  <span class="string">&quot;fork&quot;</span>: <span class="keyword">false</span>, <span class="comment">// 该项目是否为fork的项目</span></span><br><span class="line">  <span class="string">&quot;language?&quot;</span>: <span class="string">&quot;JavaScript&quot;</span>,<span class="comment">//该项目的主要编程语言</span></span><br><span class="line">  <span class="string">&quot;forks_count&quot;</span>: <span class="number">9</span>, <span class="comment">// fork了该项目的数量</span></span><br><span class="line">  <span class="string">&quot;stargazers_count&quot;</span>: <span class="number">80</span>, <span class="comment">//该项目的star数量</span></span><br><span class="line">  <span class="string">&quot;size&quot;</span>: <span class="number">108</span>, <span class="comment">// 项目占用的存储大小</span></span><br><span class="line">  <span class="string">&quot;default_branch&quot;</span>: <span class="string">&quot;master&quot;</span>, <span class="comment">//项目的默认分支</span></span><br><span class="line">  <span class="string">&quot;open_issues_count&quot;</span>: <span class="number">2</span>, <span class="comment">//该项目当前打开的issue数量</span></span><br><span class="line">  <span class="string">&quot;pushed_at&quot;</span>: <span class="string">&quot;2011-01-26T19:06:43Z&quot;</span>,</span><br><span class="line">  <span class="string">&quot;created_at&quot;</span>: <span class="string">&quot;2011-01-26T19:01:12Z&quot;</span>,</span><br><span class="line">  <span class="string">&quot;updated_at&quot;</span>: <span class="string">&quot;2011-01-26T19:14:43Z&quot;</span>,</span><br><span class="line">  <span class="string">&quot;subscribers_count?&quot;</span>: <span class="number">42</span>, <span class="comment">//订阅（关注）该项目的人数</span></span><br><span class="line">  <span class="string">&quot;license?&quot;</span>: &#123; <span class="comment">// 该项目的开源许可证</span></span><br><span class="line">    <span class="string">&quot;key&quot;</span>: <span class="string">&quot;mit&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;MIT License&quot;</span>,</span><br><span class="line">    <span class="string">&quot;spdx_id&quot;</span>: <span class="string">&quot;MIT&quot;</span>,</span><br><span class="line">    <span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://api.github.com/licenses/mit&quot;</span>,</span><br><span class="line">    <span class="string">&quot;node_id&quot;</span>: <span class="string">&quot;MDc6TGljZW5zZW1pdA==&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>生成 Dart Model 类</li>
</ul>
<p>添加包 </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">json_model: ^<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">json_serializable: ^<span class="number">6.1</span><span class="number">.4</span></span><br></pre></td></tr></table></figure>

<p>根目录运行 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter packages pub run json_model</span><br></pre></td></tr></table></figure>

<p>执行后在 lib/models 文件夹下会生成相应的 Dart Model 类</p>
<img src="《Flutter实战第二版》十五：一个完整的Flutter应用/WeChatd1808cadb57d89cee1dc0a463410b7be.png" alt="WeChatd1808cadb57d89cee1dc0a463410b7be" style="zoom:80%;" />

<ul>
<li>数据持久化</li>
</ul>
<p>使用 shared_preferences 包来对登录用户的 profile 信息进行持久化，shared_preferences 是一个 Flutter 插件，通过 Android 和 iOS 平台提供的机制来实现数据持久化</p>
<h4 id="15-4-全局变量及共享状态"><a href="#15-4-全局变量及共享状态" class="headerlink" title="15.4 全局变量及共享状态"></a>15.4 全局变量及共享状态</h4><p>全局变量：单纯指会贯穿整个APP生命周期的变量，单纯保存一些信息或者封装一些全局工具和方法的对象</p>
<p>共享状态：指那些需要跨组件或跨路由共享的信息</p>
<p>区别在于共享状态发生改变时需要通知所有使用该状态的组件，全局变量不需要</p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>事件传递和响应</title>
    <url>/2021/07/20/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%92%8C%E5%93%8D%E5%BA%94/</url>
    <content><![CDATA[<h4 id="1、事件的传递"><a href="#1、事件的传递" class="headerlink" title="1、事件的传递"></a>1、事件的传递</h4><h5 id="1-1-事件传递流程"><a href="#1-1-事件传递流程" class="headerlink" title="1.1 事件传递流程"></a>1.1 事件传递流程</h5><p>事件发生后，系统会将事件加入到一个由 UIApplication 管理的事件队列中<br>UIApplication 会从事件队列中取出最前面的事件，分发下去，首先传给 UIWindow<br>UIWindow 会在视图层次结构中找到一个最合适的视图来处理事件</p>
<p>触摸事件的传递是从父控件传递到子控件<br>UIApplication -&gt; Window -&gt; 寻找最合适的视图来处理事件</p>
<h5 id="1-2-寻找最合适的视图"><a href="#1-2-寻找最合适的视图" class="headerlink" title="1.2 寻找最合适的视图"></a>1.2 寻找最合适的视图</h5><p>内部通过调用 <code>hitTest:withEvent</code> 方法找最终响应视图</p>
<p><code>hitTest:withEvent</code> 底层实现：</p>
<ol>
<li>判断当前控件能不能接收事件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(self.userInteractionEnabled &#x3D;&#x3D; NO || self.hidden &#x3D;&#x3D; YES || self.alpha &lt;&#x3D; 0.01)</span><br><span class="line">return  nil;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>判断触摸点在不在当前的控件上</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(![self pointInside:point withEvent:event]) return nil;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>从后往前遍历自己的子控件（最后添加的子视图先遍历）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int count &#x3D; (int)self.subviews.count;</span><br><span class="line">for (int i &#x3D; count - 1; i &gt;&#x3D; 0;i-- ) &#123;</span><br><span class="line">	UIView *childV &#x3D; self.subviews[i];</span><br><span class="line">	&#x2F;&#x2F;把当前坐标系上的点转换成子控件坐标系上的点.</span><br><span class="line">	CGPoint childP &#x3D; [self convertPoint:point toView:childV];</span><br><span class="line">	&#x2F;&#x2F;判断自己的子控件是不是最适合的View 对子view进行 hitTest</span><br><span class="line">	UIView *fitView &#x3D; [childV hitTest:childP withEvent:event];</span><br><span class="line">	&#x2F;&#x2F;如果子控件是最适合的View,直接返回</span><br><span class="line">  if (fitView) &#123;</span><br><span class="line">    return fitView;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>如果没有找到最合适的view，自己就是最合适的view</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return self</span><br></pre></td></tr></table></figure>

<h5 id="1-3-应用"><a href="#1-3-应用" class="headerlink" title="1.3 应用"></a>1.3 应用</h5><ol>
<li>扩大button的响应区域</li>
<li>子view超出了父view的bounds响应事件</li>
<li>使部分区域失去响应</li>
<li>让非scrollView区域响应scrollView拖拽事件</li>
</ol>
<p>button被view遮住了，要让button接收事件</p>
<p><img src="/2021/07/20/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%92%8C%E5%93%8D%E5%BA%94/button.png" alt="button"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123;</span><br><span class="line">    &#x2F;&#x2F;return [super hitTest:point withEvent:event];</span><br><span class="line">    &#x2F;&#x2F;拿到后面的按钮</span><br><span class="line">    &#x2F;&#x2F;当点在按钮上的时候,才返回按钮,如果不在按钮上.保持系统默认做法</span><br><span class="line">    &#x2F;&#x2F;判断点在不在按钮身上</span><br><span class="line">    &#x2F;&#x2F;把当前的点转换到按钮身上的坐标系的点</span><br><span class="line">    CGPoint btnP &#x3D; [self convertPoint:point toView:self.btn];</span><br><span class="line">    if ([self.btn pointInside:btnP withEvent:event]) &#123;</span><br><span class="line">        return self.btn;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return [super hitTest:point withEvent:event];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、事件响应"><a href="#2、事件响应" class="headerlink" title="2、事件响应"></a>2、事件响应</h4><p>传递链是用来获取第一响应者，接下来开始响应事件</p>
<p>响应链条：firstView -&gt; super view -&gt; … -&gt; viewcontroller -&gt;window -&gt; application -&gt; appdelegate</p>
<p>找到最合适的视图后，事件会从视图开始，沿着响应链 nextResponder 传递，直到找到处理事件的视图，没有处理的事件会被丢弃</p>
<p>如果有父视图，则 nextResponder指向父视图</p>
<p>响应链传递</p>
<p><img src="/2021/07/20/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%92%8C%E5%93%8D%E5%BA%94/%E5%93%8D%E5%BA%94%E9%93%BE%E4%BC%A0%E9%80%92.png" alt="响应链传递"></p>
<h5 id="2-1-系统响应"><a href="#2-1-系统响应" class="headerlink" title="2.1 系统响应"></a>2.1 系统响应</h5><p>屏幕点击后，将事件交由 IOKit 处理</p>
<p>IOKit 将事件封装成一个 IOHIDEvent 对象，通过 mach port 传递给 SpringBoard 进程</p>
<p>SpringBoard 接收到触摸事件，触发主线程 RunLoop 的 source1回调</p>
<p>如果此时在桌面，则交给桌面系统消耗该事件</p>
<p>如果此时在 APP，通过 IPC（进程通信）传给 APP 进程</p>
<h5 id="2-2-APP响应"><a href="#2-2-APP响应" class="headerlink" title="2.2 APP响应"></a>2.2 APP响应</h5><p>APP 进程的 mach port 接收到 SpringBoard 触摸事件，主线程 RunLoop 被唤醒，触发 source1 回调</p>
<p>source1 内部触发了 source0 回调，将接收的 IOHIDEvent 对象封装成 UIEvent 对象</p>
<p>source0 将事件添加到 UIApplication 对象的事件队列中，开始寻找最佳响应者</p>
<h5 id="2-3-应用"><a href="#2-3-应用" class="headerlink" title="2.3 应用"></a>2.3 应用</h5><ul>
<li>利用响应链获取 view 的控制器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension UIView &#123;</span><br><span class="line">    var viewController: UIViewController? &#123;</span><br><span class="line">        var next &#x3D; next</span><br><span class="line">        var current: UIViewController?</span><br><span class="line">        while next !&#x3D; nil &#123;</span><br><span class="line">            if next is UIViewController &#123;</span><br><span class="line">                return next as? UIViewController</span><br><span class="line">            &#125;</span><br><span class="line">            next &#x3D; next?.next</span><br><span class="line">        &#125;</span><br><span class="line">        return current</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3、面试题"><a href="#3、面试题" class="headerlink" title="3、面试题"></a>3、面试题</h4><ul>
<li>APP 中间有个 button，在你手触摸屏幕点击后，到这个 button 收到点击事件，中间发生了什么？</li>
</ul>
<ol>
<li>设备将 touch 到的 UITouch 和 UIEvent 对象打包，放到当前活动的 Application 的事件队列中</li>
<li>UIApplication 会从事件队列中取出触摸事件并传递给 UIWindow</li>
<li>UIWindow 使用 hitTest:withEvent 方法查找操作所在视图</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>二进制重排</title>
    <url>/2021/07/30/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%87%8D%E6%8E%92/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s/Drmmx5JtjG3UtTFksL6Q8Q">抖音二进制重排</a></p>
]]></content>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/2021/07/23/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h4 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h4><p>iOS 中的内存区域从低地址到高地址：.text 段（代码区）、.data 段（已初始化全局变量、静态变量）、.bss 段（未初始化全局变量、静态变量）、堆区、栈区</p>
<img src="内存分布.png" alt="内存分布" style="zoom:40%;" />

<p>堆区：</p>
<p>低地址向高地址拓展数据结构，不连续的内存区域，先进先出，由程序员动态分配和释放，通过 alloc 分配的对象</p>
<p>缺点：手动管理，速度慢，容易产生内存碎片</p>
<p>栈区：</p>
<p>高地址向低地址拓展的数据结构，连续内存区域，后进先出，一般运行时分配，编译器自动分配并释放</p>
<p>由编译器自动分配并释放，不会产生内存碎片，速度快，缺点：内存大小限制不灵活</p>
<h4 id="TaggedPointer"><a href="#TaggedPointer" class="headerlink" title="TaggedPointer"></a>TaggedPointer</h4><p>普通对象的查找过程：从栈中找到指针，然后去堆中寻找指针对应的内存空间，进而读取值</p>
<p>64 bit 开始，引入了 TaggedPointer 技术，用于优化 NSNumber、NSDate、NSString 等小对象存储</p>
<p>TaggedPointer 通过在其最后一个 bit 位设置一个特殊标记，用于将数据直接保存到指针本身</p>
<p>TaggedPointer 指针的值不再是堆区地址，而是真正的值。所以实际上它不再是一个对象了，内存并不存储在堆中</p>
<p>将对象的指针拆分成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特殊指针，不指向任何一个地址</p>
<ul>
<li>引入 TaggedPointer 对象之后，64 位 CPU 下 NSNumber 的内存变成这样</li>
</ul>
<img src="nsnumber.png" alt="nsnumber" style="zoom:60%;" />



<ul>
<li>执行以下代码，有什么区别</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">for (int i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        self.name &#x3D; [NSString stringWithFormat:@&quot;abcdefghij&quot;];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_global_queue(0, 0);</span><br><span class="line">for (int i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        self.name &#x3D; [NSString stringWithFormat:@&quot;abc&quot;];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个会 Crash，第二个正常运行</p>
<p>第一个多线程同时访问 name 的 setter 方法，有可能多条线程同时执行 [_name release]，连续 release 两次造成对象的过度释放，导致 Crash</p>
<p>第二个 name 指针为 TaggedPointer 类型，不存在 release 操作</p>
<p>两个 name 的底层类型不一致，第一个 name 类型是 NSCFString 类型，存储在堆上，第二个 name 类型是NSTaggedPointerString 存储在常量区</p>
<p>NSString 对于那些所需内存小于 60 位的字符串，它可以创建一个 TaggedPointer，其余则被放置在真正的 NSString 对象里，这使得常用短字符串的性能得到提升</p>
<h4 id="NONPOINTER-ISA"><a href="#NONPOINTER-ISA" class="headerlink" title="NONPOINTER_ISA"></a>NONPOINTER_ISA</h4><p>和 TaggedPointer 设计思想类似，ISA 其实并不单单是一个指针，其中一些位仍旧编码指向对象的类，一部分额外空间存储其它内容</p>
<p>ISA 指针第 1 位表示使用优化的 ISA 指针</p>
<p>64 位架构下，ISA 指针本身占 64 位，64 位存储一个内存地址显然浪费，为了提高内存利用率，剩余比特位中存储了内存管理相关的内容</p>
<ul>
<li>nonpointer：表示是否对isa开启指针优化 。0代表是纯isa指针，1代表除了地址外，还包含了类的一些信息、对象的引用计数等</li>
<li>has_assoc：关联对象标志位</li>
<li>该对象是否有C++或Objc的析构器，如果有析构函数，则需要做一些析构的逻辑处理，如果没有，则可以更快的释放对象</li>
<li>shiftcls：存在类指针的值，开启指针优化的情况下，arm64位中有33位来存储类的指针</li>
<li>magic：判断当前对象是真的对象还是一段没有初始化的空间</li>
<li>weakly_referenced：是否被指向或者曾经指向一个ARC的弱变量，没有弱引用的对象释放的更快</li>
<li>deallocating：是否正在释放</li>
<li>has_sidetable_rc：当对象引用计数大于10时，则需要进位</li>
<li>extra_rc：表示该对象的引用计数值，实际上是引用计数减一。例如：如果引用计数为10，那么extra_rc为9。如果引用计数大于10，则需要使用has_sidetable_rc</li>
</ul>
<h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><p>当引用计数存储到一定值，并不会存储到 Nonpointer_isa 位域的 extra_rc 中，而是会存储到 SideTable 散列表中</p>
<p>在 runtime 内存空间中，SideTable 是一个 hash 数组，里面存储了 SideTable</p>
<p>SideTable 的 hash 键就是一个对象 obj 的 address，因此可以说，一个 obj，对应了一个 SideTable，但一个 SideTable 会对应多个 obj，因为SideTable 的数量有限，所有会有很多 obj 公用一个 SideTable</p>
<p>SideTable结构中包含了自旋锁、引用计数表、弱引用表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct SideTable &#123;</span><br><span class="line">    spinlock_t slock;       &#x2F;&#x2F; 自旋锁</span><br><span class="line">    RefcountMap refcnts;    &#x2F;&#x2F;引用计数的Map表 key-value</span><br><span class="line">    weak_table_t weak_table;&#x2F;&#x2F;弱引用表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么不直接用一张SideTable，而是用SideTables去管理多个 SideTable</li>
</ul>
<p>SideTable 里有一个自旋锁，如果把所有的类都放在同一个 SideTable，有任何一个类有改动都会对整个 table 做操作，并且在操作一个类的同时，操作别的类会被锁住等待，这样会导致操作效率和查询效率都很低。而有多个SideTable 的话，操作的都是单个 Table，并不会影响其他的 table，这就是分离锁</p>
<h5 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h5><p>retain 底层先判断是否是 Nonpointer_isa，如果不是，则直接操作散列表进行 +1 操作<br>如果是 Nonpointer_isa，extra_rc 引用计数+1，extra_rc只有8位，如果出现上溢出，需要借助散列表存储，一半存储在散列表中，另一半还是存储在 extra_rc 中</p>
<h5 id="release"><a href="#release" class="headerlink" title="release"></a>release</h5><p>release 底层先判断是否是 Nonpointer_isa，如果不是，则直接操作散列表进行 -1 操作<br>如果是 Nonpointer_isa，extra_rc 引用计数-1，如果引用计数出现下溢出，看散列表中是否存储引用计数，从散列表中取一半进行 -1 操作，然后存储到 extra_rc 中，如果还是下溢出，就调用 dealloc</p>
<p><a href="https://www.infoq.cn/article/deep-understanding-of-tagged-pointer/">深入理解 TaggedPointer</a></p>
]]></content>
  </entry>
  <entry>
    <title>对象和方法底层原理</title>
    <url>/2020/12/01/%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%96%B9%E6%B3%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h4 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a>isa指针</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LGPerson *p  &#x3D; [LGPerson alloc];</span><br><span class="line">p.name &#x3D; @&quot;aa&quot;;</span><br><span class="line"></span><br><span class="line">Class cls1 &#x3D; [LGPerson class];</span><br><span class="line">Class cls2 &#x3D; p.class;</span><br><span class="line">Class cls3 &#x3D; object_getClass(p);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%p %p %p&quot;, cls1, cls2, cls3); &#x2F;&#x2F;打印结果相同 只有一个类对象</span><br><span class="line"></span><br><span class="line">Class cls4 &#x3D; objcet_getClass(cls3);</span><br></pre></td></tr></table></figure>

<p>实例对象   – <code>p</code><br>类对象       – <code>cls1</code><br>元类对象   – <code>cls4</code></p>
<p>实例对象所属的类  -&gt; 类对象（<code>class</code>）<br>类对象所属的类      -&gt; 元类    （<code>meta-class</code>）<br>元类所属                  -&gt; 根元类（基类的<code>meta-class</code>）<br>根元类所属              -&gt; 自己</p>
<ul>
<li><p>根元类的父类是<code>NSObject</code> ，<code>NSObject</code> 的父类是 <code>nil</code></p>
</li>
<li><p><code>Class</code> 的 <code>superclass</code> 指向父类的 <code>class</code>，如果没有父类，<code>superclasss</code> 指针为 <code>nil</code></p>
</li>
<li><p><code>meta-class</code> 的 <code>superclass</code> 指向父类的 <code>meta-class</code>，基类的 <code>meta-class</code> 的 <code>superclass</code> 指向基类的 <code>class</code></p>
</li>
</ul>
<h4 id="实例对象调用对象方法"><a href="#实例对象调用对象方法" class="headerlink" title="实例对象调用对象方法"></a>实例对象调用对象方法</h4><p><img src="/2020/12/01/%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%96%B9%E6%B3%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95.png" alt="实例对象调用对象方法"></p>
<p>对于 <code>student</code> 来说，并不知道 <code>abc</code> 方法在哪里，唯一知道的就是可以去它的 <code>class对象</code> 里找</p>
<p>先通过 <code>isa</code> 指针进入 <code>Student</code> 类的 <code>class对象</code>，如果在其中找到了 <code>abc</code> 就直接进行调动，调用过程结束</p>
<p>没有找到的话，就通过<code> class对象</code>的 <code>superclass</code> 指针进入 <code>Student</code> 类的父类，也就是 <code>Person</code>类的 <code>class对象</code>，重复上一步的查找逻辑</p>
<p>一层层往上找，最终到基类，也就是 <code>NSObject</code> 类的 <code>class对象</code>，还没找到的话，由于它的 <code>superclass</code> 为 nil，最终就会报错 <code>[ERROR: unrecognized selector sent to instance]</code>，调用结束</p>
<h4 id="类对象调用类方法"><a href="#类对象调用类方法" class="headerlink" title="类对象调用类方法"></a>类对象调用类方法</h4><p><img src="/2020/12/01/%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%96%B9%E6%B3%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/%E7%B1%BB%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8%E7%B1%BB%E6%96%B9%E6%B3%95.png" alt="类对象调用类方法"></p>
<p>对于<code> Student</code>类来说，并不知道 <code>abc</code> 方法在哪里，我们知道类方法放在 <code>meta-class</code>对象里面</p>
<p>首先通过 <code>Student</code> 的 <code>class对象</code> 的 <code>isa</code> 指针找到其 <code>meta-class</code>对象，然后在方法列表里找是否有<code>abc</code>，如果有的话就调用，调用结束</p>
<p>如果没有的话，就通过 <code>meta-class</code> 对象的 <code>superclass</code> 指针找到 <code>Student</code> 的父类 <code>Person</code> 的<code>meta-class</code>对象，然后查找<code>abc</code>方法，如果有的话就调用，调用结束</p>
<p>没有的话，通过<code>meta-class</code>对象的<code>superclass</code>指针一层层往上查找</p>
<p>如果到了基类<code>（NSObject）</code>的<code>meta-class</code>还没找到<code>abc</code>，接下来 <code>superclass</code> 指针会找到 <code>NSObject</code> 的<code>class对象</code>，此时会继续在 <code>NSObject</code> 的 <code>class对象</code> 里面，寻找 <code>abc</code>，如果找到就会调用</p>
<p>如果没有找到，由于此时 <code>superclass</code> 是 <code>nil</code> ，最终系统会报错</p>
<h4 id="验证isa指针指向"><a href="#验证isa指针指向" class="headerlink" title="验证isa指针指向"></a>验证isa指针指向</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LGPerson *person &#x3D; [[LGPerson alloc] init];</span><br><span class="line">Class personClass &#x3D; [LGPerson class];</span><br><span class="line">Class personMetaClass &#x3D; object_getClass(personClass);</span><br><span class="line">NSLog(@&quot;%p %p %p&quot;, person, personClass, personMetaClass);</span><br></pre></td></tr></table></figure>

<p>打断点，LLDB调试打印 <code>person</code> 对象的 <code>isa</code> 指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) p&#x2F;x person-&gt;isa</span><br><span class="line">(Class) $1 &#x3D; 0x000001a1044bd715 LGPerson</span><br><span class="line">(lldb) p&#x2F;x personClass</span><br><span class="line">(Class) $2 &#x3D; 0x00000001044bd710 LGPerson</span><br></pre></td></tr></table></figure>

<p>通过 <code>p/x</code> 命令打印指针，<code>/</code>后面是打印参数，<code>x</code> 表示用 16 进制输出</p>
<p>可以看到输出结果并不相等</p>
<p>实例对象 <code>person 的 isa = 0x000001a1044bd715</code></p>
<p>类对象 <code>personClass = 0x00000001044bd710</code></p>
<p>从 64bit 开始，<code>isa</code> 需要进行一次位运算，才能计算出 <code>class对象</code> 的地址，系统提供了 <code>ISA_MASK</code>，在 <a href="https://opensource.apple.com/tarballs/objc4/">objc4</a> 的源码中可以找到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">objc_object::ISA() </span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer()); </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line">    <span class="keyword">if</span> (isa.nonpointer) &#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> slot = isa.indexcls;</span><br><span class="line">        <span class="keyword">return</span> classForIndex((<span class="keyword">unsigned</span>)slot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Class)isa.bits;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> (Class)(isa.bits &amp; ISA_MASK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">elif</span> __x86_64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></span><br></pre></td></tr></table></figure>

<p>验证结果，通过和 <code>ISA_MASK</code>进行一次 <code>&amp;</code> 运算，得到了类对象 <code>personClass</code> 的地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) p&#x2F;x 0x000001a1044bd715 &amp; 0x0000000ffffffff8ULL</span><br><span class="line">(unsigned long long) $4 &#x3D; 0x00000001044bd710</span><br></pre></td></tr></table></figure>

<h4 id="objc-class"><a href="#objc-class" class="headerlink" title="objc_class"></a>objc_class</h4><p>查看源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;			//isa占8字节</span></span><br><span class="line">    Class superclass; <span class="comment">//8字节</span></span><br><span class="line">    <span class="keyword">cache_t</span> cache;    <span class="comment">//16字节         // formerly cache pointer and vtable</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到 <code>class_rw_t</code> 看字面意思是可读可写的表，进入查看</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_array_t</span> methods;				<span class="comment">//方法列表</span></span><br><span class="line">    <span class="keyword">property_array_t</span> properties;  <span class="comment">//属性列表</span></span><br><span class="line">    <span class="keyword">protocol_array_t</span> protocols;   <span class="comment">//协议列表</span></span><br></pre></td></tr></table></figure>

<p>方法、属性、协议信息都放在这里，还有一个 <code>class_ro_t</code> 只读表，进入查看哪些是只读的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;	<span class="comment">//实例对象size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;			<span class="comment">//类名</span></span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList;</span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols; <span class="comment">//成员变量描述信息，如名称，类型等</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;</span><br></pre></td></tr></table></figure>

<h4 id="通过MachO文件查找类和方法列表"><a href="#通过MachO文件查找类和方法列表" class="headerlink" title="通过MachO文件查找类和方法列表"></a>通过MachO文件查找类和方法列表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   Person *p &#x3D; [[Person alloc] init];</span><br><span class="line">   p.name &#x3D; @&quot;pname&quot;;</span><br><span class="line">   p.age  &#x3D; 20;</span><br><span class="line">   NSLog(@&quot;%p&quot;, [p class]); &#x2F;&#x2F;0x100cc9718</span><br><span class="line">-&gt; NSLog(@&quot;end&quot;);</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p><code>image list</code> 查看偏移量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) image list</span><br><span class="line">[  0] E4FC76C2-878C-31CA-AB74-26EF8D1204D5 0x0000000100cc0000 &#x2F;</span><br><span class="line">xxx&#x2F;Build&#x2F;Products&#x2F;Debug-iphoneos&#x2F;Test.app&#x2F;Test </span><br></pre></td></tr></table></figure>

<p>计算内存地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) p&#x2F;x 0x100cc9718-0x0000000100cc0000</span><br><span class="line">(long) $0 &#x3D; 0x0000000000009718</span><br></pre></td></tr></table></figure>

<p>将<code>Products/Debug-iphoneos/Test.app/Test</code> 目录下的可执行文件拖入到 <code>MachOView</code></p>
<p><img src="/2020/12/01/%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%96%B9%E6%B3%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/MachOView.jpg" alt="MachOView"></p>
<h4 id="isKindOfClass-isMemberOfClass"><a href="#isKindOfClass-isMemberOfClass" class="headerlink" title="isKindOfClass isMemberOfClass"></a>isKindOfClass isMemberOfClass</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL re1 &#x3D; [(id)[NSObject class] isKindOfClass:[NSObject class]];</span><br><span class="line">BOOL re2 &#x3D; [(id)[LGPerson class] isKindOfClass:[LGPerson class]];</span><br><span class="line">BOOL re3 &#x3D; [(id)[NSObject class] isMemberOfClass:[NSObject class]];</span><br><span class="line">BOOL re4 &#x3D; [(id)[LGPerson class] isMemberOfClass:[LGPerson class]];</span><br><span class="line">NSLog(@&quot; re1 :%hhd\n re2 :%hhd\n re3 :%hhd\n re4 :%hhd\n&quot;,re1,re2,re3,re4);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ret3 传入类NSObject self指向NSObject self-&gt;ISA()指向根元类 根元类和NSObject不相等</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;iskindOfClass &amp; isMemberOfClass 实例方法调用</span><br><span class="line">BOOL re5 &#x3D; [(id)[NSObject alloc] isKindOfClass:[NSObject class]];</span><br><span class="line">BOOL re6 &#x3D; [(id)[LGPerson alloc] isKindOfClass:[LGPerson class]];</span><br><span class="line">BOOL re7 &#x3D; [(id)[NSObject alloc] isMemberOfClass:[NSObject class]];</span><br><span class="line">BOOL re8 &#x3D; [(id)[LGPerson alloc] isMemberOfClass:[LGPerson class]];</span><br><span class="line">NSLog(@&quot; re5 :%hhd\n re6 :%hhd\n re7 :%hhd\n re8 :%hhd\n&quot;,re5,re6,re7,re8);</span><br><span class="line"></span><br><span class="line">ret1: 1</span><br><span class="line">ret2: 0</span><br><span class="line">ret3: 0</span><br><span class="line">ret4: 0</span><br><span class="line"></span><br><span class="line">ret5: 1</span><br><span class="line">ret6: 1</span><br><span class="line">ret7: 1</span><br><span class="line">ret8: 1</span><br></pre></td></tr></table></figure>

<ul>
<li>isKindOfClass</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;类方法 </span><br><span class="line">&#x2F;&#x2F;第一次比较，获取类的元类与传入类比较，之后获取上次结果的父类与传入类比较</span><br><span class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">     &#x2F;&#x2F;类的元类 vs 传入类</span><br><span class="line">     &#x2F;&#x2F;根元类 vs 传入类</span><br><span class="line">     &#x2F;&#x2F;根类 vs 传入类</span><br><span class="line">     &#x2F;&#x2F;nil vs 传入类</span><br><span class="line">     for (Class tcls &#x3D; self-&gt;ISA(); tcls; tcls &#x3D; tcls-&gt;getSuperclass()) &#123;</span><br><span class="line">         if (tcls &#x3D;&#x3D; cls) return YES;</span><br><span class="line">     &#125;</span><br><span class="line">     return NO;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实例方法 </span><br><span class="line">&#x2F;&#x2F;第一次比较，获取对象的类与传入类比较，之后获取上次结果的父类与传入类比较</span><br><span class="line"> - (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">     &#x2F;&#x2F;对象的类 vs 传入类</span><br><span class="line">     &#x2F;&#x2F;父类 vs 传入类</span><br><span class="line">     &#x2F;&#x2F;根类 vs 传入类</span><br><span class="line">     &#x2F;&#x2F;nil vs 传入类</span><br><span class="line">     for (Class tcls &#x3D; [self class]; tcls; tcls &#x3D; tcls-&gt;getSuperclass()) &#123;</span><br><span class="line">         if (tcls &#x3D;&#x3D; cls) return YES;</span><br><span class="line">     &#125;</span><br><span class="line">     return NO;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>类方法：元类 -&gt; 根元类 -&gt; 根类 -&gt; nil 与 传入类比较<br>对象方法：对象的类 -&gt; 父类 -&gt; 根类 -&gt; nil 与 传入类比较</p>
<ul>
<li>isMemberOfClass</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;类方法 </span><br><span class="line">&#x2F;&#x2F;获取类的元类 与传入类比较</span><br><span class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">     return self-&gt;ISA() &#x3D;&#x3D; cls;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实例方法 </span><br><span class="line">&#x2F;&#x2F;获取对象的类 与传入类比较</span><br><span class="line"> - (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">     return [self class] &#x3D;&#x3D; cls;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>类方法：    类的元类 与 传入类 比较<br>对象方法：对象的父类 与 传入类 比较</p>
<p><a href="https://blog.csdn.net/u013480070/article/details/100154183">对象的本质（下）详解isa&amp;superclass指针</a></p>
]]></content>
  </entry>
  <entry>
    <title>测试下</title>
    <url>/2020/11/17/%E6%B5%8B%E8%AF%95%E4%B8%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>分类1</category>
      </categories>
      <tags>
        <tag>标签1</tag>
      </tags>
  </entry>
  <entry>
    <title>消息流程</title>
    <url>/2021/07/29/%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="方法的本质"><a href="#方法的本质" class="headerlink" title="方法的本质"></a>方法的本质</h4><p>使用 clang 编译 main.m 文件 <code>clang -rewrite-objc main.m</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LGPerson *person &#x3D; [LGPerson alloc];</span><br><span class="line">[person sayHello];</span><br></pre></td></tr></table></figure>

<p>编译后的底层实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LGPerson *person = ((LGPerson *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">&quot;LGPerson&quot;</span>), sel_registerName(<span class="string">&quot;alloc&quot;</span>));</span><br><span class="line">((<span class="keyword">void</span> (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)person, sel_registerName(<span class="string">&quot;say&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>可以看出，方法的调用本质就是 objc_msgSend消息发送</p>
<h4 id="objc-msgSend-快速查找"><a href="#objc-msgSend-快速查找" class="headerlink" title="objc_msgSend 快速查找"></a>objc_msgSend 快速查找</h4><h4 id="objc-msgSend-慢速查找"><a href="#objc-msgSend-慢速查找" class="headerlink" title="objc_msgSend 慢速查找"></a>objc_msgSend 慢速查找</h4><h4 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h4><p>如果 LGPerson 类中没有实现 sayHello 方法，runtime 就会调用</p>
<p> <code>resolveInstanceMethod:(实例方法)</code> 或者  <code>resolveClassMethod:(类方法)</code> </p>
<p>我们可以在方法中新增已实现的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)sayAddHello &#123;</span><br><span class="line">    NSLog(@&quot;say add hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    if (sel &#x3D;&#x3D; @selector(sayHello)) &#123;</span><br><span class="line">        IMP addImp &#x3D; class_getMethodImplementation(self, @selector(sayAddHello));</span><br><span class="line">        Method addMethod &#x3D; class_getInstanceMethod(self, @selector(sayAddHello));</span><br><span class="line">        const char *type &#x3D; method_getTypeEncoding(addMethod);</span><br><span class="line">        return class_addMethod(self, sel, addImp, type);</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void runAddMethod(id self, SEL _cmd)&#123;</span><br><span class="line">    NSLog(@&quot;add C IMP&quot;);</span><br><span class="line">&#125;</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    if ([NSStringFromSelector(sel) isEqualToString:@&quot;sayHello&quot;]) &#123;</span><br><span class="line">        class_addMethod(self, sel, (IMP)runAddMethod, &quot;v@:*&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h4><p>如果动态方法解析没有处理，进入消息转发流程</p>
<ol>
<li>进入快速转发</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface LGTeacher : NSObject</span><br><span class="line">- (void)sayHello;</span><br><span class="line">@end</span><br><span class="line">@implementation LGTeacher</span><br><span class="line">- (void)sayHello &#123;</span><br><span class="line">    NSLog(@&quot;Teacher sayhello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>LGTeacher 中实现了 sayHello 方法，将消息转发给 LGTeacher 处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector &#x3D;&#x3D; @selector(sayHello)) &#123;</span><br><span class="line">        return [LGTeacher alloc];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>快速转发没有处理，则进入慢速转发</li>
</ol>
<p><code>methodSignatureForSelector</code> 方法返回方法的签名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector &#x3D;&#x3D; @selector(sayHello)) &#123;</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>forwardInvocation</code> 真正执行由 methodSignatureForSelector 返回的 NSMethodSignature</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    SEL aSelector &#x3D; [anInvocation selector];</span><br><span class="line">    LGTeacher *teacher &#x3D; [LGTeacher alloc];</span><br><span class="line">    if ([teacher respondsToSelector:aSelector]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:teacher];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [super forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>OC 消息机制可以分为三个阶段：</p>
<p>消息发送阶段：从类和父类的方法缓存列表、方法列表中查找方法</p>
<p>动态解析阶段：如果消息发送阶段没找到方法，进入动态方法解析，动态添加方法实现</p>
<p>消息转发阶段：如果也没有实现动态解析方法，进入消息转发阶段，将消息转发给可以处理消息的接受者</p>
<img src="消息处理.png" alt="消息处理" style="zoom:67%;" />

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void runAddMethod(id self, SEL _cmd)&#123;</span><br><span class="line">    NSLog(@&quot;add C IMP&quot;);</span><br><span class="line">&#125;</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    if ([NSStringFromSelector(sel) isEqualToString:@&quot;sayHello&quot;]) &#123;</span><br><span class="line">    		class_addMethod(self, sel, (IMP)runAddMethod, &quot;v@:*&quot;);</span><br><span class="line">   		  return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>objc_msgSend 发送消息流程：</p>
<p>消息发送者先进行 <code>快速查找流程</code> ，在类的缓存cache中查找方法</p>
<p>快速查找流程没找到，走慢速查找流程，实例方法在当前类及类的继承链的方法列表中查找，类方法在元类及元类继承链的方法列表中查找</p>
<p>慢速查找没找到会进行动态方法解析</p>
<p>动态方法解析没有找到会进入消息转发，快速消息转发和慢速消息转发</p>
<p>没有找到最终报异常：unrecognized selector send to instance</p>
]]></content>
  </entry>
  <entry>
    <title>逆</title>
    <url>/2021/03/31/%E9%80%86/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="72532eea066a4da146eb47dadaf84eae9b7a8370881c3e752edf5432c1f21e4f">6a0984f7a8e89a416916236f779221ce3fd2c4dcefac971b9ac8b0dfe88c8e46334c272f445ecc37ad2ff29ebc86c61b795b2bdd3ba96e9dc0312d782588f3cb55a66a01be0215453842d96a281db9303caec9bb73de782bc345e2ee9c2109549031e91b8f54c589e56cd95adc18592a272832103cd750c72d5021192aadfa386c3b355150f4376389da11d8e6d3b79ced6064535d03fcf12e8ad72c4f67d5196a2943dcd69dc9298ed2857ce03fc372809a9251c876b0605369c29361d02c80082e6af9060a3ffd5060671e8c286a72e29105bbd27fa3f7b643f885e6358b85ff761f1ad49fab37b1ac11b5c2879ec671eb393c01cc40b340f9b79fc36fbde6a6410ef6c65aa67281b7d616fc5b3f61a46de02ff4c1593f6a6e0fdd335e1fbecc015c033058d04b0f3796d88a5b639a8e502e8e36230ca5c175c600a08c9c0d2544b0a55b0dea027beb482f30bdb73be6d93f6f5941cf27106f9fc6b9ab45ae4bfab5cc357a1e09dd39af815aab12482e54376b299f8314af335ee9b4d19eec71138ac45872addfb03fde20d695503a1e6d89628fe5556b283bab9d641155c408aa20e621089921bc38a2226e5441d38eb1919e96ea5ccc7aa3ad50072925f12f1dc0c96f62927c180c49ff6629d59450382c0f7d5e51d84b376c68d7dc5d04323da77a82ba1c2f7d50e0b7f152589b9c4c83252fa4c75ef735d4070c51ba0e54ef82fe489ad56b19dc589056ad5348a4a3ac10df2c1fc258ec69bcc7540833af19ebeb43910353062e1a7f9afc05f682f6ee81dc998ed50bb091b3601db2e03db2d9afae8dc1e81592accf3ec79df755ed9261abcc7219cef7d94201dc8ca57f64781627c4b2eae6c57a4597ff77a3c7ef700615a774a5f42db7e39d39007c53c58b66d76619b0b979ddf6504860c6947e50f63be2a4c9f03efb22ff02259d9a7b664d33bf3aada6808a148bda07bc170ca2ca19bc069b49691ebb20db4f23cd61022657739942380ccf836e709424cc037cb464fab6ee3bdd4a5c325ed262ba1f61c704768fe90ef06daa72e4dd6dd00826a76be1a1c902cbbdb1fde547ac2df339616028bd8f213baa018b39f618cdec6274f0f0a72ab9e48a28c86496c60a522b6430e78f6837d54ab3b6abf57e6f825a2d2e96376e63f056881fee71a01cb345dcf559d6db14adc6da9d27b8f300972ea9333f7a33acd9f709b5229defb2fa2143718fa1119777a150ff8e18bbfdec179d55d7cca38daeb9bf7aefff3f1e5da36cd74725b78e80d16de9bfaf93d8a1f12dd51a7ae6b78ba34697edfb0d917beccfccb00f2d34d9df69c080b4e1</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>逆</category>
      </categories>
      <tags>
        <tag>逆</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向-安全保护</title>
    <url>/2021/11/12/%E9%80%86%E5%90%91-%E5%AE%89%E5%85%A8%E4%BF%9D%E6%8A%A4/</url>
    <content><![CDATA[<p>加固方案：</p>
<p>数据加密：静态字符串、本地存储及网络传输的加密</p>
<p>静态混淆：类名、方法名、属性的混淆</p>
<p>动态保护：反调试、注入检测、hook检测、越狱检测、签名检测等</p>
<p>代码混淆：将代码分块、扁平化、增加干扰代码，提高分析难度</p>
<h4 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h4><p>加密算法：</p>
<ul>
<li>BASE64：一种基于64个可打印字符表示二进制数据的方法，主要为了将二进制数据变成可见字符以便传输，可以解密</li>
<li>MD5：将数据运算变成另一个固定长度值，用于数据校验，不可逆</li>
<li>DES：一种对称加密算法，用于对二进制数据进行加密，明文、密文和秘钥的分组长度都是64</li>
<li>AES：密码学中的高级加密标准，本质上是一种对称分组密码体制，用来代替DES</li>
<li>RSA：一种非对称加密算法，存在一个公钥和一个私钥，分别用于加密和解密，速度比对称加密慢很多</li>
</ul>
<p>对称加密：加密解密使用同一秘钥</p>
<p>非对称加密：存在一个公钥和一个私钥</p>
<h5 id="本地存储加密"><a href="#本地存储加密" class="headerlink" title="本地存储加密"></a>本地存储加密</h5><p>本地存储方式：NSUserDefaults、文件、数据库</p>
<p>存储数据时，可以使用哈希算法、对称加密算法（DES/AES）进行加密存储，或者系统 keychain 进行存储，实现加密算法时也不能将 key 以明文形式写在代码中</p>
<h5 id="网络传输加密"><a href="#网络传输加密" class="headerlink" title="网络传输加密"></a>网络传输加密</h5><p>HTTPS + 本地证书校验方式</p>
<p>传输过程中可以使用 RSA+AES 进行加密传输</p>
<ol>
<li>客户端随机生成 AES 的key</li>
<li>使用 RSA 公钥加密算法加密随机的 key</li>
<li>使用随机的 key 对数据进行 AES 加密</li>
<li>将 RSA 加密后的 key 和 AES 加密后的数据发送给服务器</li>
<li>给发送的数据加上时间戳，以防止重放攻击</li>
</ol>
<img src="逆向-安全保护/WeChatd746b59be5c7fc2ddd3741f286c2db2f.png" alt="WeChatd746b59be5c7fc2ddd3741f286c2db2f"/>



<p>AFNetworking 证书校验</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *certFilePath &#x3D; [[NSBundle mainBundle] pathForResource:@&quot;server&quot; ofType:@&quot;der&quot;];</span><br><span class="line">NSData *certData &#x3D; [NSData dataWithContentsOfFile:certFilePath];</span><br><span class="line">NSSet *certSet &#x3D; [NSSet setWithObject:certData];</span><br><span class="line">AFSecurityPolicy *policy &#x3D; [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate withPinnedCertificates:certSet];</span><br></pre></td></tr></table></figure>

<h5 id="字符串加密"><a href="#字符串加密" class="headerlink" title="字符串加密"></a>字符串加密</h5>]]></content>
  </entry>
  <entry>
    <title>逆向工具-Cycript</title>
    <url>/2021/10/11/%E9%80%86%E5%90%91%E5%B7%A5%E5%85%B7-Cycript/</url>
    <content><![CDATA[<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p><a href="http://www.cycript.org/">Cycript官网</a> 下载 SDK 解压进入 cycript_0.9.594 文件夹，执行 ./cycript</p>
<p>会报下面错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dyld[1291]: Library not loaded: &#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;Ruby.framework&#x2F;Versions&#x2F;2.0&#x2F;usr&#x2F;lib&#x2F;libruby.2.0.0.dylib</span><br><span class="line">  Referenced from: &#x2F;Users&#x2F;midland_whk&#x2F;Downloads&#x2F;cycript_0.9.594&#x2F;Cycript.lib&#x2F;cycript-apl</span><br><span class="line">  Reason: tried: &#39;&#x2F;Users&#x2F;midland_whk&#x2F;Downloads&#x2F;cycript_0.9.594&#x2F;.&#x2F;Cycript.lib&#x2F;libruby.2.0.0.dylib&#39; (no such file), &#39;&#x2F;System&#x2F;Library&#x2F;Frameworks&#x2F;Ruby.framework&#x2F;Versions&#x2F;2.0&#x2F;usr&#x2F;lib&#x2F;libruby.2.0.0.dylib&#39; (no such file), &#39;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;libruby.2.0.0.dylib&#39; (no such file), &#39;&#x2F;usr&#x2F;lib&#x2F;libruby.2.0.0.dylib&#39; (no such file)</span><br><span class="line">[1]    1291 abort      .&#x2F;cycript</span><br></pre></td></tr></table></figure>

<p>这是因为 ruby 版本太高，需要进入 <code>/usr/local/Cellar/ruby@2.5/2.5.8/lib</code> ，将 <code>libruby.2.5.8.dylib</code> 重命名 <code>libruby.2.0.0</code> 并拷贝到 <code>Cycript.lib</code> 目录下</p>
<h4 id="Cycript-分析应用"><a href="#Cycript-分析应用" class="headerlink" title="Cycript 分析应用"></a>Cycript 分析应用</h4><p>Cydia 中 搜索 Cycript 安装</p>
<p>通过 SSH 登录手机，输入 cycript 命令，就进入交互界面，control + D 或者 <code>?exit</code>  退出命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ssh root@<span class="number">172.16</span><span class="number">.1</span><span class="number">.96</span> //ssh -P <span class="number">2222</span> root@localhost</span><br><span class="line">cycript</span><br><span class="line"></span><br><span class="line">cy<span class="comment"># var a = 3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">cy<span class="comment"># var b = 4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">cy<span class="comment"># a + b</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>注入 SpringBoard 弹出提示窗口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root# cycript -p SpringBoard</span><br><span class="line">cy# var alert &#x3D; [[UIAlertView alloc] initWithTitle:@&quot;hi&quot; message: @&quot;hello,world&quot;  delegate:nil cancelButtonTitle:@&quot;cancel&quot; otherButtonTitles: nil]</span><br><span class="line">#&quot;&lt;UIAlertView: 0x118c27680; frame &#x3D; (0 0; 0 0); layer &#x3D; &lt;CALayer: 0x280a06b00&gt;&gt;&quot;</span><br><span class="line">cy# [alert show]</span><br></pre></td></tr></table></figure>

<h5 id="分析应用"><a href="#分析应用" class="headerlink" title="分析应用"></a>分析应用</h5><p><code>ps -e</code>  或者 <code>ps -A</code>   <code>ps -e | grep DemoApp</code> 找到进程号 9790</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9790 ??  0:00.80 &#x2F;var&#x2F;containers&#x2F;Bundle&#x2F;Application&#x2F;4F526F02-0133-4149-9E3F-A492B2DC7D7F&#x2F;DemoApp.app&#x2F;DemoApp</span><br></pre></td></tr></table></figure>

<p>cycript -p 进程名字</p>
<p><code>cycript -p 9790</code> 或者  <code>cycript -p DemoApp</code> 启动 cycript</p>
<ul>
<li>获取沙盒目录 NSHomeDirectory()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cy# NSHomeDirectory()</span><br><span class="line">@&quot;&#x2F;var&#x2F;mobile&#x2F;Containers&#x2F;Data&#x2F;Application&#x2F;629E01BE-3EC6-461C-A479-83EEEAB0A22D&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取 Bundle ID</li>
</ul>
<p>[[NSBundle mainBundle] bundleIdentifier]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cy# [[NSBundle mainBundle] bundleIdentifier]</span><br><span class="line">@&quot;com.DemoApp&quot;</span><br></pre></td></tr></table></figure>

<p>可以直接在脚本中调用 OC 函数来获取和修改应用一些信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cy# UIApp</span><br><span class="line">#&quot;&lt;UIApplication: 0x109e01050&gt;&quot;</span><br><span class="line">cy# UIApp.delegate</span><br><span class="line">#&quot;&lt;AppDelegate: 0x281d3d700&gt;&quot;</span><br><span class="line">cy# UIApp.keyWindow</span><br><span class="line">#&quot;&lt;UIWindow: 0x109e14650; frame &#x3D; (0 0; 375 667); gestureRecognizers &#x3D; &lt;NSArray: 0x281324510&gt;; layer &#x3D; &lt;UIWindowLayer: 0x281d2aa60&gt;&gt;&quot;</span><br><span class="line">cy# UIApp.keyWindow.rootViewController</span><br><span class="line">#&quot;&lt;ViewController: 0x109d16900&gt;&quot;</span><br><span class="line">cy# #0x109d16900.view</span><br><span class="line">#&quot;&lt;UIView: 0x109e15b40; frame &#x3D; (0 0; 375 667); autoresize &#x3D; W+H; layer &#x3D; &lt;CALayer: 0x281d2ae80&gt;&gt;&quot;</span><br><span class="line">cy# #0x109d16900.view.backgroundColor &#x3D; [UIColor yellowColor]</span><br><span class="line">#&quot;UIExtendedSRGBColorSpace 1 1 0 1&quot;</span><br><span class="line">cy# var newVC &#x3D; new Instance(0x109d16900)</span><br><span class="line">#&quot;&lt;ViewController: 0x109d16900&gt;&quot;</span><br><span class="line">cy# var newVC &#x3D; #0x109d16900</span><br><span class="line">#&quot;&lt;ViewController: 0x109d16900&gt;&quot;</span><br><span class="line">cy# newVC</span><br><span class="line">#&quot;&lt;ViewController: 0x109d16900&gt;&quot;</span><br><span class="line">cy# #0x109d16900</span><br><span class="line">#&quot;&lt;ViewController: 0x109d16900&gt;&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>打印界面结构 UIApp.keyWindow.recursiveDescription().toString()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cy# UIApp.keyWindow.recursiveDescription().toString()</span><br><span class="line">&#96;&lt;UIWindow: 0x109e14650; frame &#x3D; (0 0; 375 667); gestureRecognizers &#x3D; &lt;NSArray: 0x281324510&gt;; layer &#x3D; &lt;UIWindowLayer: 0x281d2aa60&gt;&gt;</span><br><span class="line">   | &lt;UIView: 0x109e15b40; frame &#x3D; (0 0; 375 667); autoresize &#x3D; W+H; layer &#x3D; &lt;CALayer: 0x281d2ae80&gt;&gt;</span><br><span class="line">   |    | &lt;UIButton: 0x109d1a100; frame &#x3D; (20 100; 100 50); opaque &#x3D; NO; layer &#x3D; &lt;CALayer: 0x281d262c0&gt;&gt;</span><br><span class="line">   |    |    | &lt;UIButtonLabel: 0x109d19690; frame &#x3D; (10 14.5; 80.5 21.5); text &#x3D; &#39;DemoApp&#39;; opaque &#x3D; NO; userInteractionEnabled &#x3D; NO; layer &#x3D; &lt;_UILabelLayer: 0x283e31400&gt;&gt;&#96;</span><br></pre></td></tr></table></figure>

<p>[[[UIWindow keyWindow] rootViewController] _printHierarchy].toString()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cy# [[[UIWindow keyWindow] rootViewController] _printHierarchy].toString()</span><br><span class="line">&quot;&lt;ViewController 0x101211e50&gt;, state: appeared, view: &lt;UIView 0x109e15b40&gt;&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>choose() 方法</li>
</ul>
<p>choose(UITableView) 在内存中直接找出这个类的对象地址，打印所有 UITableView 实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cy# choose(UIViewController)</span><br><span class="line">[#&quot;&lt;ViewController: 0x101211e50&gt;&quot;]</span><br></pre></td></tr></table></figure>

<ul>
<li>找UIButton 所属 Controller</li>
</ul>
<p>UIButton 地址 0x100b15960</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cy# [#0x100b15960 nextResponder]</span><br><span class="line">#&quot;&lt;UIView: 0x100b15380; frame &#x3D; (0 0; 375 667); autoresize &#x3D; W+H; layer &#x3D; &lt;CALayer: 0x282e3a4a0&gt;&gt;&quot;</span><br><span class="line">cy# [#0x100b15380 nextResponder]</span><br><span class="line">#&quot;&lt;ViewController: 0x101211e50&gt;&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>找出 Action 响应方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cy# [#0x100b15960 allTargets]</span><br><span class="line">[NSSet setWithArray:@[#&quot;&lt;ViewController: 0x101211e50&gt;&quot;]]]</span><br><span class="line">cy# [#0x100b15960 actionsForTarget:#0x101211e50]</span><br><span class="line">cy# [#0x100b15960 actionsForTarget:#0x101211e50 forControlEvent: UIControlEventTouchUpInside]</span><br><span class="line">@[&quot;demoAction:&quot;]</span><br></pre></td></tr></table></figure>

<h5 id="加载脚本"><a href="#加载脚本" class="headerlink" title="加载脚本"></a>加载脚本</h5><p>新建 utils.cy</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function(utils) &#123;</span><br><span class="line">	APPID &#x3D; [NSBundle mainBundle].bundleIdentifier,</span><br><span class="line">	APPPATH &#x3D; [NSBundle mainBundle].bundlePath,</span><br><span class="line"></span><br><span class="line">	HKRootvc &#x3D; function()&#123;</span><br><span class="line">	 	return UIApp.keyWindow.rootViewController;</span><br><span class="line">	 &#125;;</span><br><span class="line">	 </span><br><span class="line">	 HKKeyWindow &#x3D; function()&#123;</span><br><span class="line">	 	return UIApp.keyWindow;</span><br><span class="line">	 &#125;;</span><br><span class="line"></span><br><span class="line">	 HKGetCurrentVCFromRootVc &#x3D; function(rootVC)&#123;</span><br><span class="line">	 var currentVC;</span><br><span class="line">	 if([rootVC presentedViewController])&#123;</span><br><span class="line">	 rootVC &#x3D; [rootVC presentedViewController];</span><br><span class="line">	 &#125;</span><br><span class="line">	 </span><br><span class="line">	 if([rootVC isKindOfClass:[UITabBarController class]])&#123;</span><br><span class="line">		 	currentVC &#x3D; HKGetCurrentVCFromRootVc(rootVC.selectedViewController);</span><br><span class="line">		 &#125;else if([rootVC isKindOfClass:[UINavigationController class]])&#123;</span><br><span class="line">		 	currentVC &#x3D; HKGetCurrentVCFromRootVc(rootVC.visibleViewController);</span><br><span class="line">		 &#125;else&#123;</span><br><span class="line">		 currentVC &#x3D; rootVC;</span><br><span class="line">	 &#125;</span><br><span class="line">	 </span><br><span class="line">	 	return currentVC;</span><br><span class="line">	 &#125;;</span><br><span class="line">	 </span><br><span class="line">	 </span><br><span class="line">	 HKCurrentVC &#x3D; function()&#123;</span><br><span class="line">	 	return HKGetCurrentVCFromRootVc(HKRootvc());</span><br><span class="line">	 &#125;;</span><br><span class="line"></span><br><span class="line">	 pviews &#x3D; function() &#123;</span><br><span class="line">		return UIApp.keyWindow.recursiveDescription().toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pvc &#x3D; function() &#123;</span><br><span class="line">		return [[[UlWindow keyWindow] rootViewController] _printHierarchy].toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;)(exports);</span><br></pre></td></tr></table></figure>

<p>设备上 <code>/usr/lib/cycript0.9/com/</code> 新建文件夹 monkey</p>
<p>将 utils.cy 拷贝到文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp utils.cy root@172.16.1.96:&#x2F;usr&#x2F;lib&#x2F;cycript0.9&#x2F;com&#x2F;monkey</span><br></pre></td></tr></table></figure>

<p>如果需要使用该文件，在 cycript 中需要导入，就可以使用了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@import com.monkey.utils;</span><br><span class="line">pviews()</span><br></pre></td></tr></table></figure>

<h5 id="MonkeyApp-cycript"><a href="#MonkeyApp-cycript" class="headerlink" title="MonkeyApp cycript"></a>MonkeyApp cycript</h5><p>MonkeyApp 运行后控制台会提示 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Download cycript(https:&#x2F;&#x2F;cydia.saurik.com&#x2F;api&#x2F;latest&#x2F;3) then run: .&#x2F;cycript -r 172.16.1.60:6666</span><br><span class="line">2021-10-11 15:15:55.342839+0800 TargetApp[5795:1158273] [Cycript] Finish download all script!</span><br></pre></td></tr></table></figure>

<p>终端输入 <code>./cycript -r 172.16.1.60:6666</code> 就可以进入 cycript 交互界面</p>
<p>MonkeyDev 作者加载了自己写的网络脚本，源码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function(utils) &#123;</span><br><span class="line"></span><br><span class="line">    utils.constants &#x3D; &#123;</span><br><span class="line">        APPID:  	 NSBundle.mainBundle.bundleIdentifier,</span><br><span class="line">        APPPATH:     NSBundle.mainBundle.bundlePath,</span><br><span class="line">        APPHOME:	 NSHomeDirectory(),</span><br><span class="line">        APPDOC:      NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0],</span><br><span class="line">        APPLIBRARY:  NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES)[0],</span><br><span class="line">        APPCACHE:    NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0]</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    utils.pviews &#x3D; function()&#123;</span><br><span class="line">        return UIApp.keyWindow.recursiveDescription().toString();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    utils.pvcs &#x3D; function()&#123;</span><br><span class="line">        return UIWindow.keyWindow().rootViewController._printHierarchy().toString();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    utils.rp &#x3D; function(target)&#123;</span><br><span class="line">        var result &#x3D; &quot;&quot; + target.toString();</span><br><span class="line">        while(target.nextResponder)&#123;</span><br><span class="line">            result +&#x3D; &quot;\n&quot; + target.nextResponder.toString();</span><br><span class="line">            target &#x3D; target.nextResponder;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    utils.pactions &#x3D; function(target)&#123;</span><br><span class="line">		var result &#x3D; &#39;&#39;;</span><br><span class="line">		var objs &#x3D; target.allTargets.allObjects();</span><br><span class="line">		for(var i &#x3D; 0; i &lt; objs.length; i++)&#123;</span><br><span class="line">			var actions &#x3D; [target actionsForTarget:objs[i] forControlEvent:0];</span><br><span class="line">			result +&#x3D; objs[i] + &quot; &quot; + [actions componentsJoinedByString:@&quot;,&quot;];</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    for(var k in utils.constants) &#123;</span><br><span class="line">        Cycript.all[k] &#x3D; utils.constants[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(var k in utils) &#123;</span><br><span class="line">        if(utils.hasOwnProperty(k)) &#123;</span><br><span class="line">            var f &#x3D; utils[k];</span><br><span class="line">            if(typeof f &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">                Cycript.all[k] &#x3D; f;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(exports);</span><br></pre></td></tr></table></figure>

<p>使用的时候需要先导入 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@import md</span><br></pre></td></tr></table></figure>





















]]></content>
      <tags>
        <tag>逆向工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Autotouch</title>
    <url>/2021/09/29/Autotouch/</url>
    <content><![CDATA[<blockquote>
<p>Autotouch 版本：7.0.33 破解版</p>
<p>软件源：多米诺骨牌源 <a href="https://apt.wxhbts.com/">https://apt.wxhbts.com</a></p>
</blockquote>
<h4 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h4><h5 id="模块与包"><a href="#模块与包" class="headerlink" title="模块与包"></a>模块与包</h5><p>Lua 的模块是由变量、函数等已知元素组成的 table，创建一个模块就是创建一个 table，把需要导出的常量、函数放入其中，最后返回 table</p>
<p>创建自定义模块 module.lua</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 文件名为 module.lua</span></span><br><span class="line"><span class="comment">-- 定义一个 module 的模块</span></span><br><span class="line"><span class="built_in">module</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义一个常量</span></span><br><span class="line"><span class="built_in">module</span>.constant = <span class="string">&quot;这是一个常量&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.func1</span><span class="params">()</span></span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;这是公有函数&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func2</span><span class="params">()</span></span> </span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;这是私有函数&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.func3</span><span class="params">()</span></span></span><br><span class="line">	func2()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">module</span></span><br></pre></td></tr></table></figure>

<p>使用模块</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 加载模块 或者 require &quot;module&quot;</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;module&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">module</span>.constant)</span><br><span class="line"><span class="built_in">module</span>.func1()</span><br><span class="line"><span class="built_in">module</span>.func3()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 给模块定义一个别名</span></span><br><span class="line"><span class="keyword">local</span> m = <span class="built_in">require</span>(<span class="string">&quot;module&quot;</span>)</span><br><span class="line">m.func3()</span><br></pre></td></tr></table></figure>





<h4 id="Extension-Functions"><a href="#Extension-Functions" class="headerlink" title="Extension Functions"></a>Extension Functions</h4><h5 id="touchDown-id-x-y"><a href="#touchDown-id-x-y" class="headerlink" title="touchDown(id, x, y)"></a>touchDown(id, x, y)</h5><blockquote>
<p>Press the coordinate (x,y) on the screen.</p>
</blockquote>
<p>id:    Finger ID</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Press by one finger at coordinate (100,200).</span></span><br><span class="line">touchDown(<span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">-- Press by three fingers at three locations on the screen.</span></span><br><span class="line">touchDown(<span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">touchDown(<span class="number">1</span>, <span class="number">200</span>, <span class="number">300</span>);</span><br><span class="line">touchDown(<span class="number">2</span>, <span class="number">300</span>, <span class="number">400</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Implement a tap function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tap</span><span class="params">(x, y)</span></span></span><br><span class="line">    touchDown(<span class="number">0</span>, x, y);</span><br><span class="line">    usleep(<span class="number">16000</span>);</span><br><span class="line">    touchUp(<span class="number">0</span>, x, y);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Tap at (100, 200)</span></span><br><span class="line">tap(<span class="number">100</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure>

<h5 id="touchMove-id-x-y"><a href="#touchMove-id-x-y" class="headerlink" title="touchMove(id, x, y)"></a>touchMove(id, x, y)</h5><blockquote>
<p>Move the finger to coordinate (x,y).</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Press by one finger at coordinate (100,200) and move the finger to coordinate (200,200).</span></span><br><span class="line">touchDown(<span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">usleep(<span class="number">16000</span>);</span><br><span class="line">touchMove(<span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Press by three fingers at three locations on the screen and move to new location.</span></span><br><span class="line">touchDown(<span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">touchDown(<span class="number">1</span>, <span class="number">200</span>, <span class="number">300</span>);</span><br><span class="line">touchDown(<span class="number">2</span>, <span class="number">300</span>, <span class="number">400</span>);</span><br><span class="line">usleep(<span class="number">16000</span>);</span><br><span class="line">touchMove(<span class="number">0</span>, <span class="number">150</span>, <span class="number">250</span>);</span><br><span class="line">touchMove(<span class="number">1</span>, <span class="number">250</span>, <span class="number">350</span>);</span><br><span class="line">touchMove(<span class="number">2</span>, <span class="number">350</span>, <span class="number">450</span>);</span><br></pre></td></tr></table></figure>

<h5 id="touchUp-id-x-y"><a href="#touchUp-id-x-y" class="headerlink" title="touchUp(id, x, y)"></a>touchUp(id, x, y)</h5><blockquote>
<p>Lift the finger from coordinate (x,y)</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Click the screen once by one finger at coordinate (100,200).</span></span><br><span class="line">touchDown(<span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">usleep(<span class="number">16000</span>);</span><br><span class="line">touchUp(<span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Press by three fingers at three locations on the screen, move to new location, and then lift the finger.</span></span><br><span class="line">touchDown(<span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">touchDown(<span class="number">1</span>, <span class="number">200</span>, <span class="number">300</span>);</span><br><span class="line">touchDown(<span class="number">2</span>, <span class="number">300</span>, <span class="number">400</span>);</span><br><span class="line">usleep(<span class="number">16000</span>);</span><br><span class="line">touchMove(<span class="number">0</span>, <span class="number">150</span>, <span class="number">250</span>);</span><br><span class="line">touchMove(<span class="number">1</span>, <span class="number">250</span>, <span class="number">350</span>);</span><br><span class="line">touchMove(<span class="number">2</span>, <span class="number">350</span>, <span class="number">450</span>);</span><br><span class="line">usleep(<span class="number">16000</span>);</span><br><span class="line">touchUp(<span class="number">0</span>, <span class="number">150</span>, <span class="number">250</span>);</span><br><span class="line">touchUp(<span class="number">1</span>, <span class="number">250</span>, <span class="number">350</span>);</span><br><span class="line">touchUp(<span class="number">2</span>, <span class="number">350</span>, <span class="number">450</span>);</span><br></pre></td></tr></table></figure>

<h5 id="keyDown-keyType"><a href="#keyDown-keyType" class="headerlink" title="keyDown(keyType)"></a>keyDown(keyType)</h5><blockquote>
<p>Simulate the pressing of physical key</p>
</blockquote>
<p>Home Button：KEY_TYPE.HOME_BUTTON</p>
<p>Volume – Button：KEY_TYPE.VOLUME_DOWN_BUTTON</p>
<p>Volume + Button：KEY_TYPE.VOLUME_UP_BUTTON</p>
<p>Power Button：KEY_TYPE.POWER_BUTTON</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Simulate the pressing of Home Key.</span></span><br><span class="line">keyDown(KEY_TYPE.HOME_BUTTON);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- How to simulate a key pressing?</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">keyPress</span><span class="params">(keyType)</span></span></span><br><span class="line">    keyDown(keyType);</span><br><span class="line">    usleep(<span class="number">10000</span>);</span><br><span class="line">    keyUp(keyType);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">keyPress(KEY_TYPE.HOME_BUTTON);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- How to simulate a screen lock function?</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lockScreen</span><span class="params">()</span></span></span><br><span class="line">    keyDown(KEY_TYPE.POWER_BUTTON);</span><br><span class="line">    keyUp(KEY_TYPE.POWER_BUTTON);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- How to simulate a screen unlock function?</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unlockScreen</span><span class="params">()</span></span></span><br><span class="line">    keyDown(KEY_TYPE.POWER_BUTTON);</span><br><span class="line">    keyUp(KEY_TYPE.POWER_BUTTON);</span><br><span class="line"></span><br><span class="line">    usleep(<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> w, h = getScreenResolution();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">local</span> gap = <span class="number">120</span>;</span><br><span class="line">    touchDown(<span class="number">0</span>, x, <span class="number">200</span>);</span><br><span class="line">    <span class="keyword">while</span> x &lt; w <span class="keyword">do</span></span><br><span class="line">        x = x + gap;</span><br><span class="line">        usleep(<span class="number">16000</span>);</span><br><span class="line">        touchMove(<span class="number">0</span>, x, <span class="number">200</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    touchUp(<span class="number">0</span>, x, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h5 id="keyUp-keyType"><a href="#keyUp-keyType" class="headerlink" title="keyUp(keyType)"></a>keyUp(keyType)</h5><blockquote>
<p>Simulate the lifting of physical key</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Simulate the action of pressing and lifting Home Key.</span></span><br><span class="line">keyDown(KEY_TYPE.HOME_BUTTON);</span><br><span class="line">usleep(<span class="number">10000</span>);</span><br><span class="line">keyUp(KEY_TYPE.HOME_BUTTON);</span><br></pre></td></tr></table></figure>

<h5 id="getColor-x-y"><a href="#getColor-x-y" class="headerlink" title="getColor(x, y)"></a>getColor(x, y)</h5><blockquote>
<p>Get the color value of the pixel point of the specified coordinate on current screen</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> color = getColor(<span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">alert(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Pixel color is :%d&quot;</span>, color))</span><br><span class="line"><span class="comment">-- Pop up color: 16777215</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Keep gettting color of a location until it matches a specify color</span></span><br><span class="line"><span class="keyword">local</span> color</span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">   color = getColor(<span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">   usleep(<span class="number">50000</span>) <span class="comment">-- Wait a while</span></span><br><span class="line"><span class="keyword">until</span>( color == <span class="number">123456</span> )</span><br><span class="line"><span class="comment">-- Continue to do what&#x27;s next</span></span><br></pre></td></tr></table></figure>

<h5 id="getColors-locations"><a href="#getColors-locations" class="headerlink" title="getColors(locations)"></a>getColors(locations)</h5><blockquote>
<p>Get the color values of the pixel points of the specified coordinates on current screen</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> result = getColors(&#123; &#123;<span class="number">100</span>, <span class="number">200</span>&#125;, &#123;<span class="number">200</span>, <span class="number">300</span>&#125;, &#123;<span class="number">300</span>, <span class="number">400</span>&#125; &#125;);</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">pairs</span>(result) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Gotten color:%d&quot;</span>, v));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h5 id="findColor"><a href="#findColor" class="headerlink" title="findColor()"></a>findColor()</h5><p>findColor(color, count, region, debug, rightToLeft, bottomToTop)</p>
<blockquote>
<p>Search the coordinates of the pixel points matching the specified color on current screen</p>
</blockquote>
<table>
<thead>
<tr>
<th>Parameter</th>
<th align="left">Type</th>
<th>Optional</th>
<th>Default</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td align="left">Integer</td>
<td>NO</td>
<td></td>
</tr>
<tr>
<td>count</td>
<td align="left">Integer</td>
<td>NO</td>
<td>0</td>
</tr>
<tr>
<td>region</td>
<td align="left">table</td>
<td>NO</td>
<td>nil</td>
</tr>
<tr>
<td>debug</td>
<td align="left">boolean</td>
<td>YES</td>
<td>false</td>
</tr>
<tr>
<td>rightToLeft</td>
<td align="left">boolean</td>
<td>YES</td>
<td>false</td>
</tr>
<tr>
<td>bottonToTop</td>
<td align="left">boolean</td>
<td>YES</td>
<td>false</td>
</tr>
</tbody></table>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Example:</span></span><br><span class="line"><span class="keyword">local</span> result = findColor(<span class="number">0x0000ff</span>, <span class="number">2</span>, <span class="literal">nil</span>);</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">pairs</span>(result) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Found pixel: x:%f, y:%f&quot;</span>, v[<span class="number">1</span>], v[<span class="number">2</span>]));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Example: Search from right to left, from bottom to top</span></span><br><span class="line"><span class="keyword">local</span> result = findColor(<span class="number">0x0000ff</span>, <span class="number">2</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">pairs</span>(result) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Found rect at: x:%f, y:%f&quot;</span>, v[<span class="number">1</span>], v[<span class="number">2</span>]));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Example:</span></span><br><span class="line"><span class="keyword">local</span> result = findColor(<span class="number">0x00ddff</span>, <span class="number">0</span>, &#123;<span class="number">100</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">200</span>&#125;);</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">pairs</span>(result) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Found pixel: x:%f, y:%f&quot;</span>, v[<span class="number">1</span>], v[<span class="number">2</span>]));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Example:</span></span><br><span class="line"><span class="keyword">local</span> region = &#123;<span class="number">100</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">200</span>&#125;;</span><br><span class="line"><span class="keyword">local</span> result = findColor(<span class="number">0x00ddff</span>, <span class="number">0</span>, region);</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">pairs</span>(result) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Found pixel: x:%f, y:%f&quot;</span>, v[<span class="number">1</span>], v[<span class="number">2</span>]));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Example:</span></span><br><span class="line"><span class="comment">-- Keep finding a speficied color until it&#x27;s found.</span></span><br><span class="line"><span class="keyword">local</span> locations</span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">   <span class="keyword">local</span> locations = findColor(<span class="number">0x0000ff</span>, <span class="number">2</span>, <span class="literal">nil</span>);</span><br><span class="line">   usleep(<span class="number">50000</span>) <span class="comment">-- Wait a while</span></span><br><span class="line"><span class="keyword">until</span>(locations &gt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">-- Log the locations if found</span></span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">pairs</span>(locations) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Found pixel: x:%f, y:%f&quot;</span>, v[<span class="number">1</span>], v[<span class="number">2</span>]));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h5 id="findColors"><a href="#findColors" class="headerlink" title="findColors()"></a>findColors()</h5><p> findColors(colors, count, region, debug, rightToLeft, bottomToTop)</p>
<blockquote>
<p>colors: { {0x00ddff,0,0}, {0x00eeff,10,10}, {0x0000ff,0,20} }</p>
<p>the first is the color value. The second and the third are the corresponding locations of the colors </p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Example:</span></span><br><span class="line"><span class="keyword">local</span> result = findColors(&#123; &#123;<span class="number">0x00ddff</span>,<span class="number">0</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0x00eeff</span>,<span class="number">10</span>,<span class="number">10</span>&#125;, &#123;<span class="number">0x0000ff</span>,<span class="number">0</span>,<span class="number">20</span>&#125; &#125;, <span class="number">2</span>, <span class="literal">nil</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">pairs</span>(result) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Found rect at: x:%f, y:%f&quot;</span>, v[<span class="number">1</span>], v[<span class="number">2</span>]));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Example: Search from right to left, from bottom to top</span></span><br><span class="line"><span class="keyword">local</span> result = findColors(&#123; &#123;<span class="number">0x00ddff</span>,<span class="number">0</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0x00eeff</span>,<span class="number">10</span>,<span class="number">10</span>&#125;, &#123;<span class="number">0x0000ff</span>,<span class="number">0</span>,<span class="number">20</span>&#125; &#125;, <span class="number">2</span>, <span class="literal">nil</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">pairs</span>(result) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Found rect at: x:%f, y:%f&quot;</span>, v[<span class="number">1</span>], v[<span class="number">2</span>]));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Example:</span></span><br><span class="line"><span class="keyword">local</span> colors = &#123; &#123;<span class="number">0x00ddff</span>,<span class="number">0</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0x00eeff</span>,<span class="number">10</span>,<span class="number">10</span>&#125;, &#123;<span class="number">0x0000ff</span>,<span class="number">0</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">local</span> result = findColors(colors, <span class="number">0</span>, <span class="literal">nil</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">pairs</span>(result) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Found rect at: x:%f, y:%f&quot;</span>, v[<span class="number">1</span>], v[<span class="number">2</span>]));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Example:</span></span><br><span class="line"><span class="keyword">local</span> colors = &#123; &#123;<span class="number">0x00ddff</span>,<span class="number">0</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0x00eeff</span>,<span class="number">10</span>,<span class="number">10</span>&#125;, &#123;<span class="number">0x0000ff</span>,<span class="number">0</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">local</span> region = &#123;<span class="number">100</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">200</span>&#125;;</span><br><span class="line"><span class="keyword">local</span> result = findColors(colors, <span class="number">0</span>, region);</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">pairs</span>(result) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Found rect at: x:%f, y:%f&quot;</span>, v[<span class="number">1</span>], v[<span class="number">2</span>]));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h5 id="findImage"><a href="#findImage" class="headerlink" title="findImage()"></a>findImage()</h5><p>findImage(targetImagePath, count, threshold, region, debug, method)</p>
<blockquote>
<p>Search areas matching the specified image on current screen and return the center coordinates</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>Type</th>
<th>Specification</th>
<th>Optional</th>
<th>Default</th>
</tr>
</thead>
<tbody><tr>
<td>targetImagePath</td>
<td></td>
<td>for example: “images/gold.PNG”, If the path starts with character “/“, it will be treated as absolute path, if not, it will be treated as relative path</td>
<td>NO</td>
<td></td>
</tr>
<tr>
<td>count</td>
<td>integer</td>
<td>How many areas to find, Pass 0 or nil</td>
<td>YES</td>
<td>0</td>
</tr>
<tr>
<td>threshold</td>
<td>float</td>
<td>maximum value is 1 means totally the same, minimum value is -1 means non same, default is 0.9, usually 0.99 is good. Pass nil if you just want to use the default value</td>
<td>YES</td>
<td>0.9</td>
</tr>
<tr>
<td>region</td>
<td>table</td>
<td>Do searching in which region</td>
<td>YES</td>
<td>Whole screen</td>
</tr>
<tr>
<td>debug</td>
<td>boolean</td>
<td>If pass debug=true, it will produce a image ends with “-Debug.PNG” marked the matching areas.</td>
<td>YES</td>
<td>false</td>
</tr>
<tr>
<td>method</td>
<td>integer</td>
<td>Searching method, default is 1, pass 2 if you want to use the more intelligent method which is able to cover size scale, orientation, color changed, it will be a little slower than method 1.</td>
<td>YES</td>
<td>1</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Return</th>
<th>Type</th>
<th>Specification</th>
</tr>
</thead>
<tbody><tr>
<td>center locations</td>
<td>table</td>
<td>Center coordinates of the matching areas</td>
</tr>
</tbody></table>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Example:</span></span><br><span class="line"><span class="keyword">local</span> result = findImage(<span class="string">&quot;images/Gold.PNG&quot;</span>, <span class="number">5</span>, <span class="number">0.99</span>, <span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">pairs</span>(result) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Found rect at: x:%f, y:%f&quot;</span>, v[<span class="number">1</span>], v[<span class="number">2</span>]));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Example:</span></span><br><span class="line"><span class="keyword">local</span> result = findImage(<span class="string">&quot;images/Gold.PNG&quot;</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">pairs</span>(result) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Found rect at: x:%f, y:%f&quot;</span>, v[<span class="number">1</span>], v[<span class="number">2</span>]));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Example:</span></span><br><span class="line"><span class="keyword">local</span> result = findImage(<span class="string">&quot;images/Gold.PNG&quot;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">pairs</span>(result) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">log</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Found rect at: x:%f, y:%f&quot;</span>, v[<span class="number">1</span>], v[<span class="number">2</span>]));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Example:</span></span><br><span class="line"><span class="keyword">local</span> imagePath = <span class="string">&quot;images/spirit.PNG&quot;</span>;</span><br><span class="line"><span class="keyword">local</span> region = &#123;<span class="number">100</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">300</span>&#125;;</span><br><span class="line"><span class="keyword">local</span> result = findImage(imagePath, <span class="number">2</span>, <span class="number">0.98</span>, region, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">pairs</span>(result) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> x = v[<span class="number">1</span>], y = v[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">log</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Found rect at: x:%f, y:%f&quot;</span>, x, y));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- Click the found location once.</span></span><br><span class="line">    tap(x, y);</span><br><span class="line">    usleep(<span class="number">16000</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Example:</span></span><br><span class="line"><span class="keyword">local</span> imagePath = <span class="string">&quot;images/spirit.PNG&quot;</span>;</span><br><span class="line"><span class="keyword">local</span> region = &#123;<span class="number">100</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">300</span>&#125;;</span><br><span class="line"><span class="comment">-- Use method 2 to find image</span></span><br><span class="line"><span class="keyword">local</span> result = findImage(imagePath, <span class="number">2</span>, <span class="number">0.98</span>, region, <span class="literal">true</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h5 id="screenshot-filePath-region"><a href="#screenshot-filePath-region" class="headerlink" title="screenshot(filePath, region)"></a>screenshot(filePath, region)</h5><blockquote>
<p>Take a screenshot for the whole screen or specified area</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Take shot of the whole screen and save into  &quot;AutoTouch&quot; album of iOS Photo Library.</span></span><br><span class="line">screenshot();</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Take a screenshot of the whole screen and save to the specified path, if no PNG as path extension, .PNG will automatically added.</span></span><br><span class="line">screenshot (<span class="string">&quot;images/screenshot1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Take a screenshot of the specified area and save.</span></span><br><span class="line">screenshot (<span class="string">&quot;images/screenshot2.PNG&quot;</span>, &#123;<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">200</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Take a screenshot of the specified area and save into  &quot;AutoTouch&quot; album of iOS Photo Library.</span></span><br><span class="line">screenshot (<span class="literal">nil</span>, &#123;<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">200</span>&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="appRun-appidentifier"><a href="#appRun-appidentifier" class="headerlink" title="appRun(appidentifier)"></a>appRun(appidentifier)</h5><blockquote>
<p>Run specified application</p>
</blockquote>
<p>或者 appActivate</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">appRun(<span class="string">&quot;com.apple.mobilesafari&quot;</span>)</span><br><span class="line">appActivate(<span class="string">&quot;com.taobao.taobao4iphone&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="appKill（appidentifier）"><a href="#appKill（appidentifier）" class="headerlink" title="appKill（appidentifier）"></a>appKill（appidentifier）</h5><blockquote>
<p>Kill specified application</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">appKill(<span class="string">&quot;com.apple.mobilesafari&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="appState-appidentifier"><a href="#appState-appidentifier" class="headerlink" title="appState(appidentifier)"></a>appState(appidentifier)</h5><blockquote>
<p>Get the running state of the specified application</p>
</blockquote>
<p>“NOT RUNNING”, “ACTIVATED”, “DEACTIVATED”</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Get the state of Safari.</span></span><br><span class="line"><span class="keyword">local</span> state = appState(<span class="string">&quot;com.apple.mobilesafari&quot;</span>);</span><br><span class="line">alert(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;State of Safari: %s&quot;</span>, state));</span><br><span class="line"><span class="comment">-- Pop up the state of Safari: &quot;ACTIVATED&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="rootDir"><a href="#rootDir" class="headerlink" title="rootDir()"></a>rootDir()</h5><blockquote>
<p>Get the default directory address of the saved script</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> dirPath = rootDir();</span><br><span class="line">alert(dirPath);</span><br><span class="line"><span class="comment">-- Popup &quot;/var/mobile/Library/AutoTouch/Scripts/&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="currentDir"><a href="#currentDir" class="headerlink" title="currentDir()"></a>currentDir()</h5><blockquote>
<p>Get directory of current executing script in runtime</p>
</blockquote>
<p>7.0.33 不支持</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> dir = currentDir();</span><br><span class="line">alert(dir);</span><br><span class="line"><span class="comment">-- &quot;/var/mobile/Library/AutoTouch/Scripts&quot;</span></span><br><span class="line"><span class="comment">-- Or maybe in tmp place for encrypted scripts: &quot;/tmp/xxxxxxxxxxxx/&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="botPath"><a href="#botPath" class="headerlink" title="botPath"></a>botPath</h5><blockquote>
<p>Get original path of the bot, relative to the runtime path of encrypted scripts</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">path</span> = botPath();</span><br><span class="line">alert(<span class="built_in">path</span>);</span><br><span class="line"><span class="comment">-- &quot;/var/mobile/Library/AutoTouch/Scripts/test.lua&quot;</span></span><br><span class="line"><span class="comment">-- &quot;/var/mobile/Library/AutoTouch/Scripts/test1.ate&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="usleep-microseconds"><a href="#usleep-microseconds" class="headerlink" title="usleep(microseconds)"></a>usleep(microseconds)</h5><blockquote>
<p>Sleep several microseconds (1/1000000 second)</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Sleep 1 second.</span></span><br><span class="line">usleep(<span class="number">1000000</span>);</span><br></pre></td></tr></table></figure>

<h5 id="log-content"><a href="#log-content" class="headerlink" title="log(content)"></a>log(content)</h5><blockquote>
<p>Record log, can be seen in the log interface</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">log</span>(<span class="string">&quot;play here...&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="alert-message"><a href="#alert-message" class="headerlink" title="alert(message)"></a>alert(message)</h5><blockquote>
<p>Pop up the dialog box to show specified content</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">alert(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="toast-message-delay"><a href="#toast-message-delay" class="headerlink" title="toast(message, delay)"></a>toast(message, delay)</h5><blockquote>
<p>Show messages with Toast style and delay for some seconds</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">toast(<span class="string">&quot;Hello I&#x27;m a toast!&quot;</span>, <span class="number">5</span>); <span class="comment">-- Show message for 5 seconds.</span></span><br><span class="line">toast(<span class="string">&quot;Hello again!&quot;</span>); <span class="comment">-- Show message for 2 seconds.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello again!&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="vibrate"><a href="#vibrate" class="headerlink" title="vibrate()"></a>vibrate()</h5><blockquote>
<p>Vibrate once</p>
</blockquote>
<p>震动一次 7.0.33 没生效</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Vibrate once.</span></span><br><span class="line">vibrate();</span><br></pre></td></tr></table></figure>

<h5 id="playAudio-audioFile-times"><a href="#playAudio-audioFile-times" class="headerlink" title="playAudio(audioFile, times)"></a>playAudio(audioFile, times)</h5><blockquote>
<p>Play audio document at specified location</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Play audio infinitely.</span></span><br><span class="line">playAudio(<span class="string">&quot;/var/audio.mp3&quot;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h5 id="stopAudio"><a href="#stopAudio" class="headerlink" title="stopAudio"></a>stopAudio</h5><blockquote>
<p>Stop playing audio</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Stop playing audio.</span></span><br><span class="line">stopAudio();</span><br></pre></td></tr></table></figure>

<h5 id="getOrientation"><a href="#getOrientation" class="headerlink" title="getOrientation()"></a>getOrientation()</h5><blockquote>
<p>Get orientation of the screen</p>
</blockquote>
<table>
<thead>
<tr>
<th>Value</th>
<th>Specification</th>
</tr>
</thead>
<tbody><tr>
<td>ORIENTATION_TYPE.UNKNOWN</td>
<td>Unknown orientation. Practical value is 0.</td>
</tr>
<tr>
<td>ORIENTATION_TYPE.PORTRAIT</td>
<td>Portrait screen. Home button is at the bottom. Practical value is 1.</td>
</tr>
<tr>
<td>ORIENTATION_TYPE.PORTRAIT_UPSIDE_DOWN</td>
<td>Upside-down portrait screen. Home button on the top. Practical value is 2.</td>
</tr>
<tr>
<td>ORIENTATION_TYPE.LANDSCAPE_LEFT</td>
<td>Landscape left screen. Home Key is in the left. Practical value is 3.</td>
</tr>
<tr>
<td>ORIENTATION_TYPE.LANDSCAPE_RIGHT</td>
<td>Landscape right screen. Home key is in the right. Practical value is 4.</td>
</tr>
</tbody></table>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> o = getOrientation();</span><br><span class="line">alert(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Screen orientation is : %d&quot;</span>, <span class="number">0</span>))</span><br><span class="line"><span class="comment">-- Pop up the orientation 2 of the screen, and mark the reversed screen.</span></span><br></pre></td></tr></table></figure>

<h5 id="getScreenResolution"><a href="#getScreenResolution" class="headerlink" title="getScreenResolution"></a>getScreenResolution</h5><blockquote>
<p>Get screen resolution bese on pixels</p>
</blockquote>
<table>
<thead>
<tr>
<th>Return</th>
<th align="center">Type</th>
<th>Specification</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td align="center">Integer</td>
<td>Width of screen resolution.</td>
</tr>
<tr>
<td>height</td>
<td align="center">Integer</td>
<td>Height of screen resolution</td>
</tr>
</tbody></table>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> w, h = getScreenResolution();</span><br><span class="line">alert(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Resolution of iPhone 6 Plus: width:%d, height:%d&quot;</span>, w, h));</span><br><span class="line"><span class="comment">-- iPhone 6 Plus’s resolution width is 1242 and resolution height is 2208.</span></span><br></pre></td></tr></table></figure>

<h5 id="getSN"><a href="#getSN" class="headerlink" title="getSN()"></a>getSN()</h5><blockquote>
<p>Get Serial Number of the device</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> sn = getSN();</span><br><span class="line">alert(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;SN is : %s&quot;</span>, sn));</span><br><span class="line"><span class="comment">-- Popup shows the SN of the device: C15NFK32TWD2</span></span><br></pre></td></tr></table></figure>

<h5 id="getVersion"><a href="#getVersion" class="headerlink" title="getVersion()"></a>getVersion()</h5><blockquote>
<p>Get version of AutoTouch</p>
</blockquote>
<p>7.0.33 返回 nil</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> version = getVersion();</span><br><span class="line">alert(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Current version of AutoTouch is : %s&quot;</span>, version));</span><br><span class="line"><span class="comment">-- Pop up shows current version of AutoTouch: 3.5.3-4</span></span><br></pre></td></tr></table></figure>

<h5 id="frontMostAppid"><a href="#frontMostAppid" class="headerlink" title="frontMostAppid()"></a>frontMostAppid()</h5><blockquote>
<p>Get identifier of current front most App</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> appId = frontMostAppId();</span><br><span class="line">alert(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Current front most App is : %s&quot;</span>, appId))</span><br></pre></td></tr></table></figure>

<h5 id="frontMostAppOrientation"><a href="#frontMostAppOrientation" class="headerlink" title="frontMostAppOrientation()"></a>frontMostAppOrientation()</h5><blockquote>
<p>Get orientation of current front most App</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> orientation = frontMostAppOrientation();</span><br><span class="line">alert(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Orientation of current front most App is : %d&quot;</span>, orientation))</span><br></pre></td></tr></table></figure>

<h5 id="intToRgb-intColor"><a href="#intToRgb-intColor" class="headerlink" title="intToRgb(intColor)"></a>intToRgb(intColor)</h5><blockquote>
<p>Transit integer color to independent values of R,G,B.</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> r, g, b = intToRgb(<span class="number">0x2b2b2b</span>);</span><br><span class="line">alert(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;R:%d, G:%d, B:%d&quot;</span>, r, g, b))</span><br></pre></td></tr></table></figure>

<h5 id="rgbToInt-r-g-b"><a href="#rgbToInt-r-g-b" class="headerlink" title="rgbToInt(r, g, b)"></a>rgbToInt(r, g, b)</h5><blockquote>
<p>Transit values of R,G,B to integer color value</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> intColor = rgbToInt(<span class="number">200</span>, <span class="number">255</span>, <span class="number">100</span>);</span><br><span class="line">alert(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Int type color: %d&quot;</span>, intColor))</span><br></pre></td></tr></table></figure>

<h5 id="copyText-text"><a href="#copyText-text" class="headerlink" title="copyText(text)"></a>copyText(text)</h5><blockquote>
<p>Copy specified text to clipboard</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">copyText(<span class="string">&quot;This is a copied text!&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="clipText"><a href="#clipText" class="headerlink" title="clipText()"></a>clipText()</h5><blockquote>
<p>Get the text in the clipboard</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> text = clipText();</span><br><span class="line">alert(text);</span><br><span class="line"><span class="comment">-- Popup shows the text to be copied: &quot;This is a copied text!&quot;;</span></span><br></pre></td></tr></table></figure>

<h5 id="inputText"><a href="#inputText" class="headerlink" title="inputText()"></a>inputText()</h5><blockquote>
<p>Input text to the input box selected now. You can delete a character backspace by inputText(“\b”).<strong>ATTENSION:</strong> Enable inoutText function at AutoTouch Settings &gt; Features before using it</p>
</blockquote>
<p>7.0.33 没有这个设置</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">inputText(<span class="string">&quot;Let&#x27;s input some text automatically without tapping the keyboard!&quot;</span>);</span><br><span class="line"><span class="comment">--  Delete 3 character by inputing 3 backspaces.</span></span><br><span class="line">inputText(<span class="string">&quot;\b\b\b&quot;</span>); </span><br></pre></td></tr></table></figure>

<h5 id="dialog-controls-orientations"><a href="#dialog-controls-orientations" class="headerlink" title="dialog(controls, orientations)"></a>dialog(controls, orientations)</h5><blockquote>
<p>Pop up self-defined dialog box to accept the user input. Please refer to the example for specific usage</p>
</blockquote>
<table>
<thead>
<tr>
<th>Value</th>
<th>Specification</th>
</tr>
</thead>
<tbody><tr>
<td>CONTROLLER_TYPE.LABEL</td>
<td>Text label</td>
</tr>
<tr>
<td>CONTROLLER_TYPE.INPUT</td>
<td>Input box</td>
</tr>
<tr>
<td>CONTROLLER_TYPE.PICKER</td>
<td>Picker</td>
</tr>
<tr>
<td>CONTROLLER_TYPE.SWITCH</td>
<td>Switch</td>
</tr>
<tr>
<td>CONTROLLER_TYPE.BUTTON</td>
<td>Button</td>
</tr>
<tr>
<td>CONTROLLER_TYPE.REMEMBER</td>
<td>Switch for remember user inputs</td>
</tr>
</tbody></table>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> label = &#123;<span class="built_in">type</span>=CONTROLLER_TYPE.LABEL, text=<span class="string">&quot;Would you mind to provide some personal informations?&quot;</span>&#125;</span><br><span class="line"><span class="keyword">local</span> nameInput = &#123;<span class="built_in">type</span>=CONTROLLER_TYPE.INPUT, title=<span class="string">&quot;Name:&quot;</span>, key=<span class="string">&quot;Name&quot;</span>, value=<span class="string">&quot;Bob&quot;</span>&#125;</span><br><span class="line"><span class="keyword">local</span> positionPicker = &#123;<span class="built_in">type</span>=CONTROLLER_TYPE.PICKER, title=<span class="string">&quot;Position:&quot;</span>, key=<span class="string">&quot;Position&quot;</span>, value=<span class="string">&quot;CEO&quot;</span>, options=&#123;<span class="string">&quot;CEO&quot;</span>, <span class="string">&quot;CTO&quot;</span>, <span class="string">&quot;CFO&quot;</span>, <span class="string">&quot;CXO&quot;</span>&#125; &#125;</span><br><span class="line"><span class="keyword">local</span> developerSwitch = &#123;<span class="built_in">type</span>=CONTROLLER_TYPE.SWITCH, title=<span class="string">&quot;A Developer:&quot;</span>, key=<span class="string">&quot;ADeveloper&quot;</span>, value=<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- It&#x27;s an option for users to determine weather the inputs should be remembered, if you use this control in the dialog.</span></span><br><span class="line"><span class="keyword">local</span> remember = &#123;<span class="built_in">type</span>=CONTROLLER_TYPE.REMEMBER, on=<span class="literal">false</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[ Define buttons:</span></span><br><span class="line"><span class="comment">type = CONTROLLER_TYPE.BUTTON</span></span><br><span class="line"><span class="comment">title = Button text</span></span><br><span class="line"><span class="comment">color = Button background color, it&#x27;s optional, the default value is 0x428BCA</span></span><br><span class="line"><span class="comment">width = Button width upon percentage of the dialog width, it&#x27;s optional, the default value is 0.5, max value is 1.0.</span></span><br><span class="line"><span class="comment">flag = Integer type of button flag for identifying which button is tapped.</span></span><br><span class="line"><span class="comment">collectInputs = Boolean type specifying wheather the dialog should collect the inputs while this button is tapped. ]]</span><span class="comment">--</span></span><br><span class="line"><span class="keyword">local</span> btn1 = &#123;<span class="built_in">type</span>=CONTROLLER_TYPE.BUTTON, title=<span class="string">&quot;Button 1&quot;</span>, color=<span class="number">0x71C69E</span>, width=<span class="number">0.8</span>, flag=<span class="number">1</span>, collectInputs=<span class="literal">false</span>&#125;</span><br><span class="line"><span class="keyword">local</span> btn2 = &#123;<span class="built_in">type</span>=CONTROLLER_TYPE.BUTTON, title=<span class="string">&quot;Button 2&quot;</span>, color=<span class="number">0xFF5733</span>, flag=<span class="number">2</span>, collectInputs=<span class="literal">true</span>&#125;</span><br><span class="line"><span class="keyword">local</span> btn3 = &#123;<span class="built_in">type</span>=CONTROLLER_TYPE.BUTTON, title=<span class="string">&quot;Button 3&quot;</span>, color=<span class="number">0xFFB7D0</span>, width=<span class="number">1.0</span>, flag=<span class="number">3</span>, collectInputs=<span class="literal">false</span>&#125;</span><br><span class="line"><span class="keyword">local</span> btn4 = &#123;<span class="built_in">type</span>=CONTROLLER_TYPE.BUTTON, title=<span class="string">&quot;Button 4&quot;</span>, width=<span class="number">1.0</span>, flag=<span class="number">4</span>, collectInputs=<span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> controls = &#123;label, nameInput, positionPicker, developerSwitch, btn1, btn2, remember, btn3, btn4&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Pop up the dialog. After popping, the script will suspend waiting for user input until any button is tapped, then returns the flag of tapped button.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- What orientations the dialog could be, it&#x27;s optional</span></span><br><span class="line"><span class="keyword">local</span> orientations = &#123; ORIENTATION_TYPE.PORTRAIT &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> result = dialog(controls, orientations);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    alert(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;name:%s, birthday:%s, gender:%d&quot;</span>, nameInput.value, positionPicker.value, developerSwitch.value))</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    alert(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;Dialog returned: %s&quot;</span>, result))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h5 id="cleanDialogValues-script"><a href="#cleanDialogValues-script" class="headerlink" title="cleanDialogValues(script)"></a>cleanDialogValues(script)</h5><blockquote>
<p>Clear the remembered values of the dialog created by the function dialog</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- There is a dialog.lua script in the scripts list</span></span><br><span class="line">clearDialogValues(<span class="string">&quot;dialog.lua&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="openURL-urlString"><a href="#openURL-urlString" class="headerlink" title="openURL(urlString)"></a>openURL(urlString)</h5><blockquote>
<p>Open url, or open other apps’ url scheme</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">openURL(<span class="string">&quot;https://autotouch.net&quot;</span>)</span><br><span class="line">openURL(<span class="string">&quot;prefs:root=General&amp;path=About&quot;</span>)</span><br><span class="line">openURL(<span class="string">&quot;musics://&quot;</span>)</span><br><span class="line">openURL(<span class="string">&quot;itms-apps://itunes.apple.com&quot;</span>)</span><br><span class="line">openURL(<span class="string">&quot;tel://+1123456&quot;</span>)</span><br><span class="line">openURL(<span class="string">&quot;clashofclans://&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="isLicensed"><a href="#isLicensed" class="headerlink" title="isLicensed()"></a>isLicensed()</h5><blockquote>
<p>Check if the current device is running licensed AutoTouch</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> isLicensed() <span class="keyword">then</span></span><br><span class="line">    alert(<span class="string">&quot;Your device is licensed by AutoTouch!&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h5 id="setAutoLaunch-scriptPath-on"><a href="#setAutoLaunch-scriptPath-on" class="headerlink" title="setAutoLaunch(scriptPath, on)"></a>setAutoLaunch(scriptPath, on)</h5><blockquote>
<p>Switch on/off a script as auto launch</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">setAutoLaunch(<span class="string">&quot;Records/test.lua&quot;</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<h5 id="listAutoLaunch"><a href="#listAutoLaunch" class="headerlink" title="listAutoLaunch()"></a>listAutoLaunch()</h5><blockquote>
<p>List all auto launch scripts</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> scripts = listAutoLaunch()</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">pairs</span>(scripts) <span class="keyword">do</span></span><br><span class="line">    alert(v);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h5 id="stop"><a href="#stop" class="headerlink" title="stop()"></a>stop()</h5><blockquote>
<p>SStop the current script execution.</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Exit execution</span></span><br><span class="line">stop();</span><br></pre></td></tr></table></figure>

<h5 id="ocr"><a href="#ocr" class="headerlink" title="ocr"></a>ocr</h5><p>ocr(region, languages, threshold, whitelist, blacklist, timeout, tessdataParentDir, debug)</p>
<p> 需要识别的语言，下载需要的语言到相同的目录 </p>
<p><code>/var/mobile/Library/AutoTouch/Library/tessadata</code></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th align="center">Type</th>
<th>Specification</th>
<th align="center">Optional</th>
<th align="center">Default</th>
</tr>
</thead>
<tbody><tr>
<td>region</td>
<td align="center">table</td>
<td>What region you want to recognize text at the screen.</td>
<td align="center">YES</td>
<td align="center">Whole screen</td>
</tr>
<tr>
<td>languages</td>
<td align="center">String</td>
<td>Languages you want to recognize, by default AutoTouch has included <code>eng.traineddata</code> at <code>/var/mobile/Library/AutoTouch/Library/tessadata</code>, you may download other languages you needed to the same dir from <a href="https://github.com/tesseract-ocr/tessdata/tree/3.04.00">https://github.com/tesseract-ocr/tessdata/tree/3.04.00</a>. Somewhat you may even train your own data for <code>tesseract orc</code> and put it at <code>tessadata</code> dir.</td>
<td align="center">YES</td>
<td align="center">“eng”</td>
</tr>
<tr>
<td>threshold</td>
<td align="center">Integer</td>
<td>Threshold the image, Adjust this value to improve the accurancy. Value range is from 0 to 255.</td>
<td align="center">YES</td>
<td align="center">100</td>
</tr>
<tr>
<td>whitelist</td>
<td align="center">String</td>
<td>What characters you want to recognize in the region, such as “0123456789” will find numbers only.</td>
<td align="center">YES</td>
<td align="center">NULL</td>
</tr>
<tr>
<td>blacklist</td>
<td align="center">String</td>
<td>What characters you do not want to recognize from the region.</td>
<td align="center">YES</td>
<td align="center">NULL</td>
</tr>
<tr>
<td>timeout</td>
<td align="center">Integer</td>
<td>Timeout in seconds.</td>
<td align="center">YES</td>
<td align="center">3</td>
</tr>
<tr>
<td>tessdataParentDir</td>
<td align="center">String</td>
<td>Parent directory path of the <code>tessdata</code> directory, google to know more about <code>tessdata</code> of <code>tesseract ocr</code>. If this parameter starts with “/“, it will be treated as an absolute path, otherwise it will be treated as a relative path. The real <code>traineddata</code> files will be at <code>tessdata</code>dir inside <code>tessdataParentDir</code>. <strong>ATTENSION</strong> this parameter is the <strong>parent dir</strong> of the <code>tessdata</code> folder!!! And the folder containers traineddata files must be named <code>tessdata</code>.</td>
<td align="center">YES</td>
<td align="center"><code>/var/mobile/Library/AutoTouch/Library/</code></td>
</tr>
<tr>
<td>debug</td>
<td align="center">boolean</td>
<td>If pass debug=true, it will produce a image ends with “-Debug.PNG” marked the matching areas.</td>
<td align="center">YES</td>
<td align="center">false</td>
</tr>
</tbody></table>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Example:</span></span><br><span class="line"><span class="keyword">local</span> result = ocr(&#123;<span class="number">100</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">300</span>&#125;, <span class="string">&#x27;eng&#x27;</span>, <span class="number">220</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Example:</span></span><br><span class="line"><span class="keyword">local</span> result = ocr(&#123;<span class="number">100</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">300</span>&#125;, <span class="string">&#x27;eng+fra&#x27;</span>, <span class="number">220</span>, <span class="string">&#x27;0123456789 &#x27;</span>, <span class="string">&#x27;..........&#x27;</span>, <span class="number">5</span>, <span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Example:</span></span><br><span class="line"><span class="comment">-- Find English+France at the specified region with threshold 220, using the traindata in `tessdata` folder at the current directory.</span></span><br><span class="line"><span class="comment">-- Like this example, you can put the traindata inside your package project, so you can encrypt and pack them to a single bot.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--+TestOrcProject.at</span></span><br><span class="line"><span class="comment">--+----tesseract</span></span><br><span class="line"><span class="comment">--+--------eng.traindata</span></span><br><span class="line"><span class="comment">--+--------fra.traindata</span></span><br><span class="line"><span class="comment">--+----main.lua</span></span><br><span class="line"><span class="comment">--+----worker.lua</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- `./` means under current directory, it will find `tessdata` folder in current directory.</span></span><br><span class="line"><span class="keyword">local</span> result = ocr(&#123;<span class="number">100</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">300</span>&#125;, <span class="string">&#x27;eng+fra&#x27;</span>, <span class="number">220</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="number">5</span>, <span class="string">&#x27;./&#x27;</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>识别当前界面范围， 7.0.33 识别 result = nil</p>
<p>中文识别 chi_sim 死机了。。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> result = ocr(&#123;<span class="number">80.28</span>,<span class="number">225</span>, <span class="number">176.41</span>, <span class="number">120.42</span>&#125;,<span class="string">&#x27;eng&#x27;</span>, <span class="number">220</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="number">5</span>, <span class="string">&#x27;./&#x27;</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<h5 id="recognizeText"><a href="#recognizeText" class="headerlink" title="recognizeText()"></a>recognizeText()</h5><blockquote>
<p>Recognize text on the screen</p>
</blockquote>
<p>7.0.33 版本不支持 recognizeText</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Recognize text on the screen or a specified region</span></span><br><span class="line"><span class="comment">-- recognizeText(region, customWords, minimumTextHeight, level, languages, correct, debug)</span></span><br><span class="line"><span class="comment">-- @param &#123;region&#125; - specified the region to recognize text</span></span><br><span class="line"><span class="comment">-- @param &#123;customWords&#125; - an array of strings to supplement the recognized languages at the word recognition stage.</span></span><br><span class="line"><span class="comment">-- @param &#123;minimumTextHeight&#125; - the minimum height of the text expected to be recognized, relative to the region/screen height, default is 1/32.</span></span><br><span class="line"><span class="comment">-- @param &#123;level&#125; - 0 means accurate first, 1 means speed first</span></span><br><span class="line"><span class="comment">-- @param &#123;languages&#125; - an array of languages to detect, in priority order, only `en-US` supported now. ISO language codes: http://www.lingoes.net/en/translator/langcode.htm. Use function `at.recognizeTextSupportedLanguages()` of `JavaScript` API to get the supported languages</span></span><br><span class="line"><span class="comment">-- @param &#123;correct&#125; - whether use language correction during the recognition process.</span></span><br><span class="line"><span class="comment">-- @param &#123;debug&#125; - whether you want to produce debug image</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> region = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">500</span>, <span class="number">600</span>&#125;; <span class="comment">-- nil for default means hole screen, </span></span><br><span class="line"><span class="keyword">local</span> customWords = <span class="literal">nil</span>; <span class="comment">-- nil for default, or something like [&#x27;Deploy&#x27;, &#x27;Troops&#x27;]</span></span><br><span class="line"><span class="keyword">local</span> minimumTextHeight = <span class="literal">nil</span>; <span class="comment">-- nil for default</span></span><br><span class="line"><span class="keyword">local</span> level = <span class="literal">nil</span>; <span class="comment">-- nil for default means value 0</span></span><br><span class="line"><span class="keyword">local</span> languages = <span class="literal">nil</span>; <span class="comment">-- nil for default, or something like [&#x27;en-US&#x27;, &quot;fr-FR&quot;, &#x27;zh-Hans&#x27;].</span></span><br><span class="line"><span class="keyword">local</span> correct = <span class="literal">nil</span>; <span class="comment">-- nil for default value false</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">debug</span> = <span class="literal">nil</span>; <span class="comment">-- nil for default value false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> result = recognizeText(region, customWords, minimumTextHeight, level, languages, correct, <span class="built_in">debug</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Got result of recognizeText:</span></span><br><span class="line"><span class="comment">-- &#123;</span></span><br><span class="line"><span class="comment">--     &#123;</span></span><br><span class="line"><span class="comment">--         &quot;text&quot;: &quot;Example&quot;,</span></span><br><span class="line"><span class="comment">--         &quot;rectangle&quot;: &#123;</span></span><br><span class="line"><span class="comment">--             &quot;bottomRight&quot;: &#123;</span></span><br><span class="line"><span class="comment">--                 &quot;x&quot;: 300.47,</span></span><br><span class="line"><span class="comment">--                 &quot;y&quot;: 177.78</span></span><br><span class="line"><span class="comment">--             &#125;,</span></span><br><span class="line"><span class="comment">--             &quot;topRight&quot;: &#123;</span></span><br><span class="line"><span class="comment">--                 &quot;x&quot;: 300.47,</span></span><br><span class="line"><span class="comment">--                 &quot;y&quot;: 237.52</span></span><br><span class="line"><span class="comment">--             &#125;,</span></span><br><span class="line"><span class="comment">--             &quot;topLeft&quot;: &#123;</span></span><br><span class="line"><span class="comment">--                 &quot;x&quot;: 33.51,</span></span><br><span class="line"><span class="comment">--                 &quot;y&quot;: 237.42</span></span><br><span class="line"><span class="comment">--             &#125;,</span></span><br><span class="line"><span class="comment">--             &quot;bottomLeft&quot;: &#123;</span></span><br><span class="line"><span class="comment">--                 &quot;x&quot;: 33.51,</span></span><br><span class="line"><span class="comment">--                 &quot;y&quot;: 177.68</span></span><br><span class="line"><span class="comment">--             &#125;</span></span><br><span class="line"><span class="comment">--         &#125;</span></span><br><span class="line"><span class="comment">--     &#125;</span></span><br><span class="line"><span class="comment">-- &#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="appInfo-appidentifier"><a href="#appInfo-appidentifier" class="headerlink" title="appInfo(appidentifier)"></a>appInfo(appidentifier)</h5><blockquote>
<p>Get the speficied App’s displayName,executablePath,bundleContainerPath,dataContainerPath</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> result = appInfo(<span class="string">&quot;com.apple.mobilesafari&quot;</span>)</span><br><span class="line">alert(<span class="built_in">table</span>.<span class="built_in">tostring</span>(result))</span><br></pre></td></tr></table></figure>

<h5 id="setTimer-scriptPath-fireTime-repeat-interval"><a href="#setTimer-scriptPath-fireTime-repeat-interval" class="headerlink" title="setTimer(scriptPath, fireTime, repeat, interval)"></a>setTimer(scriptPath, fireTime, repeat, interval)</h5><blockquote>
<p>Set timer for a script</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- trigger after 1000 seconds</span></span><br><span class="line"><span class="keyword">local</span> done = setTimer(<span class="string">&quot;Records/test.lua&quot;</span>, <span class="number">1000</span>, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">-- Equals to</span></span><br><span class="line">const done = at.setTimer(<span class="string">&quot;/var/mobile/Library/AutoTouch/Scripts/Records/test.lua&quot;</span>, <span class="number">1000</span>, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- trigger at 2019-09-17 08:12:52 and repeat every 10000 seconds</span></span><br><span class="line"><span class="keyword">local</span> done = setTimer(<span class="string">&quot;Records/test.lua&quot;</span>, <span class="string">&quot;2019-09-17 08:12:52&quot;</span>, <span class="literal">true</span>, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure>

<h5 id="removeTimer-scriptPath"><a href="#removeTimer-scriptPath" class="headerlink" title="removeTimer(scriptPath)"></a>removeTimer(scriptPath)</h5><blockquote>
<p>Remove timer of a script</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> done = removeTimer(<span class="string">&quot;/Records/test.lua&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="keepAutoTouchAwake-keepAwake"><a href="#keepAutoTouchAwake-keepAwake" class="headerlink" title="keepAutoTouchAwake(keepAwake)"></a>keepAutoTouchAwake(keepAwake)</h5><blockquote>
<p>Keep AutoTouch awake aginst iOS idle sleep</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">keepAutoTouchAwake(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>



<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> socket = <span class="built_in">require</span>(<span class="string">&quot;socket&quot;</span>)</span><br><span class="line"><span class="comment">-- 获取时间戳</span></span><br><span class="line"><span class="built_in">log</span>(<span class="built_in">os</span>.<span class="built_in">time</span>())        <span class="comment">-- 1632985348</span></span><br><span class="line"><span class="built_in">log</span>(socket.gettime()) <span class="comment">-- 1632985348.2712</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span><span class="params">(n)</span></span></span><br><span class="line">   socket.<span class="built_in">select</span>(<span class="literal">nil</span>, <span class="literal">nil</span>, n)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 休眠0.1秒</span></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">usleep(<span class="number">100000</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>













<p><a href="http://www.lua.org/manual/5.3/">Lua Official Reference Manual</a></p>
]]></content>
  </entry>
  <entry>
    <title>Dart</title>
    <url>/2022/02/09/Dart/</url>
    <content><![CDATA[<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><ul>
<li>Hello Dart</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main标准写法</span></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dart中void类型，作为函数返回值类型可以省略</span></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Hello World!&#x27;</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果函数内部只有一个表达式，可以省略大括号，使用&quot;=&gt;&quot;箭头函数; </span></span><br><span class="line"><span class="keyword">void</span> main() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line"><span class="comment">//最简写形式</span></span><br><span class="line">main() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="二-数据类型"><a href="#二-数据类型" class="headerlink" title="二. 数据类型"></a>二. 数据类型</h4><h5 id="1-布尔类型-bool"><a href="#1-布尔类型-bool" class="headerlink" title="1. 布尔类型 bool"></a>1. 布尔类型 bool</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> isClosed = <span class="keyword">true</span>;</span><br><span class="line"><span class="built_in">bool</span> isOpened = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<h5 id="2-数字类型-num、int、double"><a href="#2-数字类型-num、int、double" class="headerlink" title="2. 数字类型 num、int、double"></a>2. 数字类型 num、int、double</h5><p>flutter 中 num、int、double 都是类，int、double 都继承 num 抽象类</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span> pi = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="built_in">int</span> width = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">int</span> height = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">print</span>(width / height);  <span class="comment">//1.3333333</span></span><br><span class="line"><span class="built_in">print</span>(width ~/ height); <span class="comment">//1 整除</span></span><br></pre></td></tr></table></figure>

<p>dart 一些数字常用函数</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">3.141592653</span>.toStringAsFixed(<span class="number">3</span>)); <span class="comment">//3.142 保留有效数字</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">6.6</span>.floor());<span class="comment">//6向下取整</span></span><br><span class="line"><span class="built_in">print</span>((<span class="number">-6.6</span>).ceil()); <span class="comment">//-6 向上取整</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">9.9</span>.ceil()); <span class="comment">//10 向上取整</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">666.6</span>.round()); <span class="comment">//667 四舍五入</span></span><br><span class="line"><span class="built_in">print</span>((<span class="number">-666.6</span>).abs()); <span class="comment">// 666.6 取绝对值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">666.6</span>.toInt()); <span class="comment">//666 转化成int,这中toInt、toDouble和Kotlin类似</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">999.</span>isEven); <span class="comment">//false 是否是偶数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">999.</span>isOdd); <span class="comment">//true 是否是奇数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">666.6</span>.toString()); <span class="comment">//666.6 转化成字符串</span></span><br></pre></td></tr></table></figure>

<h5 id="3-字符串-String"><a href="#3-字符串-String" class="headerlink" title="3. 字符串 String"></a>3. 字符串 String</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> name = <span class="string">&#x27;Hello Dart!&#x27;</span>;<span class="comment">//单引号</span></span><br><span class="line"><span class="built_in">String</span> title = <span class="string">&quot;&#x27;Hello Dart!&#x27;&quot;</span>;<span class="comment">//双引号</span></span><br><span class="line"><span class="built_in">String</span> description = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      Hello Dart! Hello Dart!</span></span><br><span class="line"><span class="string">      Hello Dart!</span></span><br><span class="line"><span class="string">      Hello Dart! Hello Dart!</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>;<span class="comment">//三引号</span></span><br><span class="line"><span class="built_in">num</span> value = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">String</span> result = <span class="string">&quot;The result is <span class="subst">$value</span>&quot;</span>;<span class="comment">//单值引用</span></span><br><span class="line"><span class="built_in">num</span> width = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">num</span> height = <span class="number">300</span>;</span><br><span class="line"><span class="built_in">String</span> square = <span class="string">&quot;The square is <span class="subst">$&#123;width * height&#125;</span>&quot;</span>;<span class="comment">//表达式的值引用</span></span><br></pre></td></tr></table></figure>

<p>字符串操作方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> url = <span class="string">&quot;https://mrale.ph/dartvm/&quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(url.split(<span class="string">&quot;://&quot;</span>)[<span class="number">0</span>]); <span class="comment">//字符串分割split方法，https</span></span><br><span class="line"><span class="built_in">print</span>(url.substring(<span class="number">3</span>, <span class="number">9</span>)); <span class="comment">//字符串截取substring方法，ps://m</span></span><br><span class="line"><span class="built_in">print</span>(url.codeUnitAt(<span class="number">0</span>)); <span class="comment">//取当前索引位置字符的UTF-16码，104</span></span><br><span class="line"><span class="built_in">print</span>(url.startsWith(<span class="string">&quot;https&quot;</span>)); <span class="comment">//当前字符串是否以指定字符开头，true</span></span><br><span class="line"><span class="built_in">print</span>(url.endsWith(<span class="string">&quot;/&quot;</span>)); <span class="comment">//当前字符串是否以指定字符结尾，true</span></span><br><span class="line"><span class="built_in">print</span>(url.toUpperCase()); <span class="comment">//大写</span></span><br><span class="line"><span class="built_in">print</span>(url.toLowerCase()); <span class="comment">//小写</span></span><br><span class="line"><span class="built_in">print</span>(url.indexOf(<span class="string">&quot;ph&quot;</span>)); <span class="comment">//获取指定字符的索引位置，14</span></span><br><span class="line"><span class="built_in">print</span>(url.contains(<span class="string">&quot;http&quot;</span>)); <span class="comment">//字符串是否包含指定字符，true</span></span><br><span class="line"><span class="built_in">print</span>(url.trim()); <span class="comment">//去除字符串的首尾空格</span></span><br><span class="line"><span class="built_in">print</span>(url.length); <span class="comment">//获取字符串长度，24</span></span><br><span class="line"><span class="built_in">print</span>(url.replaceFirst(<span class="string">&quot;t&quot;</span>, <span class="string">&quot;A&quot;</span>)); <span class="comment">//替换第一次出现t字符位置的字符</span></span><br><span class="line"><span class="built_in">print</span>(url.replaceAll(<span class="string">&quot;m&quot;</span>, <span class="string">&quot;M&quot;</span>)); <span class="comment">//全部替换</span></span><br></pre></td></tr></table></figure>

<h5 id="4-类型检查和强制类型转换-as"><a href="#4-类型检查和强制类型转换-as" class="headerlink" title="4. 类型检查和强制类型转换 as"></a>4. 类型检查和强制类型转换 as</h5><p>通过 is 关键字来对类型进行检查 as 关键字对类型进行强制转换，判断不是某个类型使用 is！</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> number = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">double</span> distance = <span class="number">200.5</span>;</span><br><span class="line"><span class="built_in">num</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">print</span>(number <span class="keyword">is</span> <span class="built_in">num</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">print</span>(distance <span class="keyword">is</span>! <span class="built_in">int</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">print</span>(age <span class="keyword">as</span> <span class="built_in">int</span>);<span class="comment">//18</span></span><br></pre></td></tr></table></figure>

<h5 id="5-Object-类型"><a href="#5-Object-类型" class="headerlink" title="5. Object 类型"></a>5. Object 类型</h5><p>dart 中所有东西都是对象，都继承于 object，可以使用 object 定义任何的变量，赋值后类型可以更改</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span> color = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">color = <span class="number">0xff000000</span>;<span class="comment">//运行正常，0xff000000类型是int, int也继承于Object   </span></span><br></pre></td></tr></table></figure>

<h5 id="6-dynamic-类型"><a href="#6-dynamic-类型" class="headerlink" title="6. dynamic 类型"></a>6. dynamic 类型</h5><p>一般用于无法确定具体类型，不要滥用 dynamic，一般尽量使用 object</p>
<p>object 和 dynamic 区别：object 会在编译阶段检查类型，dynamic 不会</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> color = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">color = <span class="number">0xff000000</span>;<span class="comment">//运行正常，0xff000000类型是int, int也继承于Object</span></span><br></pre></td></tr></table></figure>

<h4 id="三-变量和常量"><a href="#三-变量和常量" class="headerlink" title="三. 变量和常量"></a>三. 变量和常量</h4><h5 id="1-var-关键字"><a href="#1-var-关键字" class="headerlink" title="1. var 关键字"></a>1. var 关键字</h5><p>dart 中可以使用 var 来替代具体类型的声明，会自动推导变量的类型</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> colorValue = <span class="number">0xff000000</span>;</span><br><span class="line"><span class="keyword">var</span> colorKey = <span class="string">&#x27;black&#x27;</span>; <span class="comment">//var声明变量 自动根据赋值的类型，推导为String类型 </span></span><br><span class="line"><span class="comment">// 使用var声明集合变量 </span></span><br><span class="line"><span class="keyword">var</span> colorList = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> colorSet = &#123;<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> colorMap = &#123;<span class="string">&#x27;white&#x27;</span>: <span class="number">0xffffffff</span>, <span class="string">&#x27;black&#x27;</span>: <span class="number">0xff000000</span>&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="2-常量（final和const）"><a href="#2-常量（final和const）" class="headerlink" title="2. 常量（final和const）"></a>2. 常量（final和const）</h5><p>声明常量可以使用 final 或 const，区别：如果常量是编译期就能初始化的用 const，如果常量是运行时期初始化的就用 final</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.141592653</span>;<span class="comment">//const定义常量    </span></span><br><span class="line"><span class="keyword">final</span> nowTime = <span class="built_in">DateTime</span>.now();<span class="comment">//final定义常量</span></span><br></pre></td></tr></table></figure>

<h4 id="四-集合-List、Set、Map"><a href="#四-集合-List、Set、Map" class="headerlink" title="四. 集合 List、Set、Map"></a>四. 集合 List、Set、Map</h4><h5 id="1-集合-List"><a href="#1-集合-List" class="headerlink" title="1. 集合 List"></a>1. 集合 List</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; colorList = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];<span class="comment">//直接使用[]形式初始化       </span></span><br><span class="line"><span class="keyword">var</span> colorList = &lt;<span class="built_in">String</span>&gt; [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];   </span><br></pre></td></tr></table></figure>

<p>常用函数</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; colorList = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];       </span><br><span class="line">colorList.add(<span class="string">&#x27;white&#x27;</span>); <span class="comment">//通过add添加一个新的元素       </span></span><br><span class="line"><span class="built_in">print</span>(colorList[<span class="number">2</span>]); <span class="comment">//直接使用数组下标形式访问元素       </span></span><br><span class="line"><span class="built_in">print</span>(colorList.length);<span class="comment">//获取集合的长度    </span></span><br><span class="line">colorList.insert(<span class="number">1</span>, <span class="string">&#x27;black&#x27;</span>);<span class="comment">//在集合指定index位置插入指定的元素       </span></span><br><span class="line">colorList.removeAt(<span class="number">2</span>);<span class="comment">//移除集合指定的index=2的元素，第3个元素       </span></span><br><span class="line">colorList.clear();<span class="comment">//清除所有元素       </span></span><br><span class="line"><span class="built_in">print</span>(colorList.sublist(<span class="number">1</span>,<span class="number">3</span>));<span class="comment">//截取子集合       </span></span><br><span class="line"><span class="built_in">print</span>(colorList.getRange(<span class="number">1</span>, <span class="number">3</span>));<span class="comment">//获取集合中某个范围元素       </span></span><br><span class="line"><span class="built_in">print</span>(colorList.join(<span class="string">&#x27;&lt;---&gt;&#x27;</span>));<span class="comment">//输出: red&lt;---&gt;yellow&lt;---&gt;blue&lt;---&gt;green       </span></span><br><span class="line"><span class="built_in">print</span>(colorList.isEmpty);       </span><br><span class="line"><span class="built_in">print</span>(colorList.contains(<span class="string">&#x27;green&#x27;</span>));  </span><br></pre></td></tr></table></figure>

<p>遍历</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; colorList = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];<span class="comment">//for-i遍历       </span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; colorList.length; i++) &#123;<span class="comment">//可以使用var或int           </span></span><br><span class="line">     <span class="built_in">print</span>(colorList[i]);               </span><br><span class="line"> &#125;       </span><br><span class="line"><span class="comment">//forEach遍历       </span></span><br><span class="line"><span class="comment">//forEach的参数为Function. =&gt;使用了箭头函数</span></span><br><span class="line">colorList.forEach((color) =&gt; <span class="built_in">print</span>(color));       </span><br><span class="line"><span class="comment">//for-in遍历       </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> color <span class="keyword">in</span> colorList) &#123;</span><br><span class="line">    <span class="built_in">print</span>(color);       </span><br><span class="line">&#125;       </span><br><span class="line"><span class="comment">//while+iterator迭代器遍历，类似Java中的iteator       </span></span><br><span class="line"><span class="keyword">while</span>(colorList.iterator.moveNext()) &#123;           </span><br><span class="line">    <span class="built_in">print</span>(colorList.iterator.current);       </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h5 id="2-集合-Set"><a href="#2-集合-Set" class="headerlink" title="2. 集合 Set"></a>2. 集合 Set</h5><p>集合中元素不能重复，添加重复元素时会返回 false，表示添加不成功</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; colorSet= &#123;<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>&#125;;<span class="comment">//直接使用&#123;&#125;形式初始化       </span></span><br><span class="line"><span class="keyword">var</span> colorList = &lt;<span class="built_in">String</span>&gt; &#123;<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>&#125;; </span><br></pre></td></tr></table></figure>

<p>集合中的交、并、补集</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colorSet1 = &#123;<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>&#125;;       </span><br><span class="line"><span class="keyword">var</span> colorSet2 = &#123;<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;white&#x27;</span>&#125;;       </span><br><span class="line"><span class="built_in">print</span>(colorSet1.intersection(colorSet2));<span class="comment">//交集--&gt;输出: &#123;&#x27;yellow&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;&#125;       </span></span><br><span class="line"><span class="built_in">print</span>(colorSet1.union(colorSet2));<span class="comment">//并集---&gt;输出: &#123;&#x27;black&#x27;, &#x27;red&#x27;, &#x27;yellow&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;white&#x27;&#125;       </span></span><br><span class="line"><span class="built_in">print</span>(colorSet1.difference(colorSet2));<span class="comment">//补集---&gt;输出: &#123;&#x27;red&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>Set 的遍历方式和 List 一样</p>
<h5 id="3-集合-Map"><a href="#3-集合-Map" class="headerlink" title="3. 集合 Map"></a>3. 集合 Map</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt; colorMap = &#123;<span class="string">&#x27;white&#x27;</span>: <span class="number">0xffffffff</span>, <span class="string">&#x27;black&#x27;</span>:<span class="number">0xff000000</span>&#125;;<span class="comment">//使用&#123;key:value&#125;形式初始化    </span></span><br><span class="line"><span class="keyword">var</span> colorMap = &lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt;&#123;<span class="string">&#x27;white&#x27;</span>: <span class="number">0xffffffff</span>, <span class="string">&#x27;black&#x27;</span>:<span class="number">0xff000000</span>&#125;;  </span><br></pre></td></tr></table></figure>

<p>常用函数</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt; colorMap = &#123;<span class="string">&#x27;white&#x27;</span>: <span class="number">0xffffffff</span>, <span class="string">&#x27;black&#x27;</span>:<span class="number">0xff000000</span>&#125;;       </span><br><span class="line"><span class="built_in">print</span>(colorMap.containsKey(<span class="string">&#x27;green&#x27;</span>));<span class="comment">//false       </span></span><br><span class="line"><span class="built_in">print</span>(colorMap.containsValue(<span class="number">0xff000000</span>));<span class="comment">//true       </span></span><br><span class="line"><span class="built_in">print</span>(colorMap.keys.toList());<span class="comment">//[&#x27;white&#x27;,&#x27;black&#x27;]       </span></span><br><span class="line"><span class="built_in">print</span>(colorMap.values.toList());<span class="comment">//[0xffffffff, 0xff000000]       </span></span><br><span class="line">colorMap[<span class="string">&#x27;white&#x27;</span>] = <span class="number">0xfffff000</span>;<span class="comment">//修改指定key的元素       </span></span><br><span class="line">colorMap.remove(<span class="string">&#x27;black&#x27;</span>);<span class="comment">//移除指定key的元素 </span></span><br></pre></td></tr></table></figure>

<p>Map 遍历</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt; colorMap = &#123;<span class="string">&#x27;white&#x27;</span>: <span class="number">0xffffffff</span>, <span class="string">&#x27;black&#x27;</span>:<span class="number">0xff000000</span>&#125;;       </span><br><span class="line"><span class="comment">//for-each key-value       </span></span><br><span class="line">colorMap.forEach((key, value) =&gt; <span class="built_in">print</span>(<span class="string">&#x27;color is <span class="subst">$key</span>, color value is <span class="subst">$value</span>&#x27;</span>));   </span><br></pre></td></tr></table></figure>

<p>Map.fromIterables 将 List 集合转换成 Map</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; colorKeys = [<span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;black&#x27;</span>];       </span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; colorValues = [<span class="number">0xffffffff</span>, <span class="number">0xff000000</span>];       </span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">int</span>&gt; colorMap = <span class="built_in">Map</span>.fromIterables(colorKeys, colorValues);   </span><br></pre></td></tr></table></figure>

<h5 id="4-集合常用操作符"><a href="#4-集合常用操作符" class="headerlink" title="4. 集合常用操作符"></a>4. 集合常用操作符</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; colorList = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line"><span class="comment">//forEach箭头函数遍历</span></span><br><span class="line">colorList.forEach((color) =&gt; &#123;<span class="built_in">print</span>(color)&#125;);</span><br><span class="line">colorList.forEach((color) =&gt; <span class="built_in">print</span>(color)); <span class="comment">//箭头函数遍历，如果箭头函数内部只有一个表达式可以省略大括号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//map函数的使用</span></span><br><span class="line"><span class="built_in">print</span>(colorList.map((color) =&gt; <span class="string">&#x27;<span class="subst">$color_font</span>&#x27;</span>).join(<span class="string">&quot;,&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//every函数的使用，判断里面的元素是否都满足条件，返回值为true/false</span></span><br><span class="line"><span class="built_in">print</span>(colorList.every((color) =&gt; color == <span class="string">&#x27;red&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//sort函数的使用</span></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; numbers = [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line">numbers.sort((num1, num2) =&gt; num1 - num2); <span class="comment">//升序排序</span></span><br><span class="line">numbers.sort((num1, num2) =&gt; num2 - num1); <span class="comment">//降序排序</span></span><br><span class="line"><span class="built_in">print</span>(numbers);</span><br><span class="line"></span><br><span class="line"><span class="comment">//where函数使用，相当于Kotlin中的filter操作符，返回符合条件元素的集合</span></span><br><span class="line"><span class="built_in">print</span>(numbers.where((<span class="built_in">num</span>) =&gt; <span class="built_in">num</span> &gt; <span class="number">6</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//firstWhere函数的使用，相当于Kotlin中的find操作符，返回符合条件的第一个元素，如果没找到返回null</span></span><br><span class="line"><span class="built_in">print</span>(numbers.firstWhere((<span class="built_in">num</span>) =&gt; <span class="built_in">num</span> == <span class="number">5</span>, orElse: () =&gt; <span class="number">-1</span>)); <span class="comment">//注意: 如果没有找到，执行orElse代码块，可返回一个指定的默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//singleWhere函数的使用，返回符合条件的第一个元素，如果没找到返回null，但是前提是集合中只有一个符合条件的元素, 否则就会抛出异常</span></span><br><span class="line"><span class="built_in">print</span>(numbers.singleWhere((<span class="built_in">num</span>) =&gt; <span class="built_in">num</span> == <span class="number">4</span>, orElse: () =&gt; <span class="number">-1</span>)); <span class="comment">//注意: 如果没有找到，执行orElse代码块，可返回一个指定的默认值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//take(n)、skip(n)函数的使用，take(n)表示取当前集合前n个元素, skip(n)表示跳过前n个元素，然后取剩余所有的元素</span></span><br><span class="line"><span class="built_in">print</span>(numbers.take(<span class="number">5</span>).skip(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//List.from函数的使用，从给定集合中创建一个新的集合,相当于clone一个集合</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">List</span>.from(numbers));</span><br><span class="line"></span><br><span class="line"><span class="comment">//expand函数的使用, 将集合一个元素扩展成多个元素或者将多个元素组成二维数组展开成平铺一个一位数组</span></span><br><span class="line"><span class="keyword">var</span> pair = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">];</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flatten list: <span class="subst">$&#123;pair.expand((pair) =&gt; pair)&#125;</span>&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inputs = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;duplicated list: <span class="subst">$&#123;inputs.expand((number) =&gt;[</span></span></span><br><span class="line"><span class="string"><span class="subst">  number,</span></span></span><br><span class="line"><span class="string"><span class="subst">  number,</span></span></span><br><span class="line"><span class="string"><span class="subst">  number</span></span></span><br><span class="line"><span class="string"><span class="subst">])&#125;</span>&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="五-流程控制"><a href="#五-流程控制" class="headerlink" title="五. 流程控制"></a>五. 流程控制</h4><h5 id="1-for-循环"><a href="#1-for-循环" class="headerlink" title="1. for 循环"></a>1. for 循环</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; colorList = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; colorList.length; i++) &#123;<span class="comment">//可以用var或int</span></span><br><span class="line">    <span class="built_in">print</span>(colorList[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-do-while-循环"><a href="#2-do-while-循环" class="headerlink" title="2. do-while 循环"></a>2. do-while 循环</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; colorList = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(colorList[index++]);</span><br><span class="line">&#125; <span class="keyword">while</span> (index &lt; colorList.length);</span><br></pre></td></tr></table></figure>

<h5 id="3-while-循环"><a href="#3-while-循环" class="headerlink" title="3. while 循环"></a>3. while 循环</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; colorList = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (index &lt; colorList.length) &#123;</span><br><span class="line">    <span class="built_in">print</span>(colorList[index++]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-break-和-continue"><a href="#4-break-和-continue" class="headerlink" title="4. break 和 continue"></a>4. break 和 continue</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; colorList = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; colorList.length; i++) &#123;<span class="comment">//可以用var或int</span></span><br><span class="line">    <span class="keyword">if</span>(colorList[i] == <span class="string">&#x27;yellow&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(colorList[i] == <span class="string">&#x27;blue&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(colorList[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-if-else"><a href="#5-if-else" class="headerlink" title="5. if-else"></a>5. if-else</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (numbers[i].isEven) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;偶数: <span class="subst">$&#123;numbers[i]&#125;</span>&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[i].isOdd) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;奇数: <span class="subst">$&#123;numbers[i]&#125;</span>&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;非法数字&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-三目运算（-）"><a href="#6-三目运算（-）" class="headerlink" title="6. 三目运算（?:）"></a>6. 三目运算（?:）</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">    <span class="built_in">num</span> targetNumber = numbers[i].isEven ? numbers[i] * <span class="number">2</span> : numbers[i] + <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">print</span>(targetNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-switch-case"><a href="#7-switch-case" class="headerlink" title="7. switch-case"></a>7. switch-case</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Color getColor(<span class="built_in">String</span> colorName) &#123;</span><br><span class="line">  Color currentColor = Colors.blue;</span><br><span class="line">  <span class="keyword">switch</span> (colorName) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;read&quot;</span>:</span><br><span class="line">      currentColor = Colors.red;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;blue&quot;</span>:</span><br><span class="line">      currentColor = Colors.blue;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;yellow&quot;</span>:</span><br><span class="line">      currentColor = Colors.yellow;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> currentColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-Assert-断言"><a href="#8-Assert-断言" class="headerlink" title="8. Assert 断言"></a>8. Assert 断言</h5><p>断言只在检查模式下运行有效，生产模式运行断言不生效</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span>(text != <span class="keyword">null</span>);<span class="comment">//text为null,就会中断后续代码执行</span></span><br><span class="line"><span class="keyword">assert</span>(urlString.startsWith(<span class="string">&#x27;https&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="六-运算符"><a href="#六-运算符" class="headerlink" title="六. 运算符"></a>六. 运算符</h4><h5 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//+ - * /</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="number">3</span>~/<span class="number">5</span>; <span class="comment">//0 整除</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="number">5</span>%<span class="number">3</span>;  <span class="comment">//2 取余</span></span><br></pre></td></tr></table></figure>

<h5 id="2-条件运算符"><a href="#2-条件运算符" class="headerlink" title="2. 条件运算符"></a>2. 条件运算符</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&gt; &lt; == != &gt;= &lt;=</span></span><br></pre></td></tr></table></figure>

<h5 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a>3. 逻辑运算符</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//|| &amp;&amp; !</span></span><br></pre></td></tr></table></figure>

<h5 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4. 位运算符"></a>4. 位运算符</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&amp; ! ^ &lt;&lt; &gt;&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="5-三目运算符"><a href="#5-三目运算符" class="headerlink" title="5. 三目运算符"></a>5. 三目运算符</h5><h5 id="6-空安全运算符"><a href="#6-空安全运算符" class="headerlink" title="6. 空安全运算符"></a>6. 空安全运算符</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">result = expr1 ?? expr2; </span><br><span class="line">expr1 ??= expr2; <span class="comment">// expr1为null则把expr2值赋值给expr1</span></span><br><span class="line">result = expr1?.value </span><br></pre></td></tr></table></figure>

<h5 id="7-级联操作符（-）"><a href="#7-级联操作符（-）" class="headerlink" title="7. 级联操作符（..）"></a>7. 级联操作符（..）</h5><p>级联操作符 .. 可以让你对一个对象中字段进行链式调用操作</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">question</span><br><span class="line">    ..id = <span class="string">&#x27;10001&#x27;</span></span><br><span class="line">    ..stem = <span class="string">&#x27;第一题: xxxxxx&#x27;</span></span><br><span class="line">    ..choices = &lt;<span class="built_in">String</span>&gt; [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>]</span><br><span class="line">    ..hint = <span class="string">&#x27;听音频做题&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="8-运算符重载"><a href="#8-运算符重载" class="headerlink" title="8. 运算符重载"></a>8. 运算符重载</h5><p>dart 支持运算符自定义重载，使用 operator 关键字定义重载函数</p>
<h5 id="9-异常"><a href="#9-异常" class="headerlink" title="9. 异常"></a>9. 异常</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">num</span> = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  result = <span class="built_in">num</span> ~/ <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;<span class="comment">//捕获到IntegerDivisionByZeroException</span></span><br><span class="line">  <span class="built_in">print</span>(e.toString());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$result</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用on关键字捕获特定的异常</span></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="built_in">int</span> <span class="built_in">num</span> = <span class="number">18</span>;</span><br><span class="line">  <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    result = <span class="built_in">num</span> ~/ <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">on</span> IntegerDivisionByZeroException <span class="keyword">catch</span> (e) &#123;<span class="comment">//捕获特定异常</span></span><br><span class="line">    <span class="built_in">print</span>(e.toString());</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$result</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="八-函数"><a href="#八-函数" class="headerlink" title="八. 函数"></a>八. 函数</h4><h5 id="1-函数基本用法"><a href="#1-函数基本用法" class="headerlink" title="1. 函数基本用法"></a>1. 函数基本用法</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;sum is <span class="subst">$&#123;sum(<span class="number">2</span>, <span class="number">5</span>)&#125;</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">num</span> sum(<span class="built_in">num</span> a, <span class="built_in">num</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-函数参数列表传参规则"><a href="#2-函数参数列表传参规则" class="headerlink" title="2. 函数参数列表传参规则"></a>2. 函数参数列表传参规则</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//num a, num b, num c, num d 最普通的传参: 调用时，参数个数和参数顺序必须固定</span></span><br><span class="line">add1(<span class="built_in">num</span> a, <span class="built_in">num</span> b, <span class="built_in">num</span> c, <span class="built_in">num</span> d) &#123;</span><br><span class="line">  <span class="built_in">print</span>(a + b + c + d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[num a, num b, num c, num d]传参: 调用时，参数个数不固定，但是参数顺序需要一一对应, 不支持命名参数</span></span><br><span class="line">add2([<span class="built_in">num</span> a, <span class="built_in">num</span> b, <span class="built_in">num</span> c, <span class="built_in">num</span> d]) &#123;</span><br><span class="line">  <span class="built_in">print</span>(a + b + c + d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;num a, num b, num c, num d&#125;传参: 调用时，参数个数不固定，参数顺序也可以不固定，支持命名参数,也叫可选参数，是dart中的一大特性，这就是为啥Flutter代码那么多可选属性，大量使用可选参数</span></span><br><span class="line">add3(&#123;<span class="built_in">num</span> a, <span class="built_in">num</span> b, <span class="built_in">num</span> c, <span class="built_in">num</span> d&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(a + b + c + d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//num a, num b, &#123;num c, num d&#125;传参: 调用时，a,b参数个数固定顺序固定，c,d参数个数和顺序也可以不固定</span></span><br><span class="line">add4(<span class="built_in">num</span> a, <span class="built_in">num</span> b, &#123;<span class="built_in">num</span> c, <span class="built_in">num</span> d&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(a + b + c + d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  add1(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>); <span class="comment">//最普通的传参: 调用时，参数个数和参数顺序必须固定</span></span><br><span class="line">  add2(<span class="number">100</span>, <span class="number">100</span>); <span class="comment">//调用时，参数个数不固定，但是参数顺序需要一一对应, 不支持命名参数(也就意味着顺序不变)</span></span><br><span class="line">  add3(</span><br><span class="line">      b: <span class="number">200</span>,</span><br><span class="line">      a: <span class="number">200</span>,</span><br><span class="line">      c: <span class="number">100</span>,</span><br><span class="line">      d: <span class="number">100</span>); <span class="comment">//调用时，参数个数不固定，参数顺序也可以不固定，支持命名参数(也就意味着顺序可变)</span></span><br><span class="line">  add4(<span class="number">100</span>, <span class="number">100</span>, d: <span class="number">100</span>, c: <span class="number">100</span>); <span class="comment">//调用时，a,b参数个数固定顺序笃定，c,d参数个数和顺序也可以不固定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-函数默认参数和可选参数"><a href="#3-函数默认参数和可选参数" class="headerlink" title="3. 函数默认参数和可选参数"></a>3. 函数默认参数和可选参数</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">add3(&#123;<span class="built_in">num</span> a, <span class="built_in">num</span> b, <span class="built_in">num</span> c, <span class="built_in">num</span> d = <span class="number">100</span>&#125;) &#123;<span class="comment">//d就是默认值参数，给的默认值是100</span></span><br><span class="line">   <span class="built_in">print</span>(a + b + c + d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">    add3(b: <span class="number">200</span>, a: <span class="number">100</span>, c: <span class="number">800</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-函数类型与高阶函数"><a href="#4-函数类型与高阶函数" class="headerlink" title="4. 函数类型与高阶函数"></a>4. 函数类型与高阶函数</h5><p>dart 函数也是一种类型 Function，可以作为函数参数传递，也可作为返回值</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="built_in">Function</span> square = (a) &#123;</span><br><span class="line">    <span class="keyword">return</span> a * a;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Function</span> square2 = (a) &#123;</span><br><span class="line">    <span class="keyword">return</span> a * a * a;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  add(<span class="number">3</span>, <span class="number">4</span>, square, square2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">num</span> add(<span class="built_in">num</span> a, <span class="built_in">num</span> b, [<span class="built_in">Function</span> op, <span class="built_in">Function</span> op2]) &#123;</span><br><span class="line">  <span class="comment">//函数作为参数传递</span></span><br><span class="line">  <span class="keyword">return</span> op(a) + op2(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-函数的简化及箭头函数"><a href="#5-函数的简化及箭头函数" class="headerlink" title="5. 函数的简化及箭头函数"></a>5. 函数的简化及箭头函数</h5><p>dart 中函数体内只有一个表达式，可以使用箭头函数来简化代码</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">add4(<span class="built_in">num</span> a, <span class="built_in">num</span> b, &#123;<span class="built_in">num</span> c, <span class="built_in">num</span> d&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(a + b + c + d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add5(<span class="built_in">num</span> a, <span class="built_in">num</span> b, &#123;<span class="built_in">num</span> c, <span class="built_in">num</span> d&#125;)  =&gt;  <span class="built_in">print</span>(a + b + c + d);</span><br></pre></td></tr></table></figure>

<h4 id="九-面向对象"><a href="#九-面向对象" class="headerlink" title="九. 面向对象"></a>九. 面向对象</h4><h5 id="1-类的基本定义和使用"><a href="#1-类的基本定义和使用" class="headerlink" title="1. 类的基本定义和使用"></a>1. 类的基本定义和使用</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="built_in">String</span> name;</span><br><span class="line">    <span class="built_in">int</span> age;</span><br><span class="line">    <span class="built_in">double</span> height;</span><br><span class="line">    Person(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age, <span class="keyword">this</span>.height);<span class="comment">//注意，这里写法可能大家没见过， 这点和Java是不一样，这里实际上是一个dart的语法糖。但是这里不如Kotlin，Kotlin是直接把this.name传值的过程都省了。</span></span><br><span class="line">    <span class="comment">//与上述的等价代码,当然这也是Java中必须要写的代码</span></span><br><span class="line">    Person(<span class="built_in">String</span> name, <span class="built_in">int</span> age, <span class="built_in">double</span> height) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//然而Kotlin很彻底只需要声明属性就行,下面是Kotlin实现代码</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="title">val</span> <span class="title">name</span>: <span class="title">String</span>, <span class="title">val</span> <span class="title">age</span>: <span class="title">Int</span>, <span class="title">val</span> <span class="title">height</span>: <span class="title">Double</span>)     </span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;<span class="comment">//使用extends关键字表示继承</span></span><br><span class="line">    Student(<span class="built_in">String</span> name, <span class="built_in">int</span> age, <span class="built_in">double</span> height, <span class="built_in">double</span> grade): <span class="keyword">super</span>(name, age, height);<span class="comment">//在 Dart里：类名(变量，变量,...) 是构造函数的写法, :super()表示该构造调用父类，这里构造时传入三个参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

































<p><a href="https://zhuanlan.zhihu.com/p/88728224">Dart语法之基础语法</a></p>
<p><a href="https://dart.dev/guides/language/language-tour#instance-variables">Dart</a></p>
<p><a href="https://dart.cn/guides">Dart.cn</a></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Core Audio</title>
    <url>/2021/08/06/Core-Audio/</url>
    <content><![CDATA[<h4 id="Core-Audio"><a href="#Core-Audio" class="headerlink" title="Core Audio"></a>Core Audio</h4><p>Core Audio 结构分层（<a href="https://developer.apple.com/library/archive/documentation/MusicAudio/Conceptual/CoreAudioOverview/CoreAudioEssentials/CoreAudioEssentials.html#//apple_ref/doc/uid/TP40003577-CH10-SW1">官方文档</a>）</p>
<img src="API Architectural Layers.png" alt="Architectural Layers"/>

<ul>
<li>Low-Level Services：底层跟硬件打交道</li>
</ul>
<p>I/O Kit：与硬件驱动交互<br>Audio HAL：音频硬件抽象层，使API调用与实际硬件相分离<br>Core MIDI：提供与MIDI（乐器数字接口）设备（包括硬件键盘和合成器）进行通信的API<br>Host Time Services：访问硬件时钟</p>
<ul>
<li>Mid-Level Services：Core Audio 中的中间层包括用于数据格式转换、读写磁盘、解析流和使用插件的服务</li>
</ul>
<p>Audio Convert Services：负责音频数据格式的转换<br>Audio File Services：负责音频数据读写<br>Audio Unit Services 和 Audio Processing Graph Services 使应用程序可以使用数字信号处理（DSP）插件，例如均衡器和混频器<br>Core Audio Clock Services：用于音频和MIDI同步以及时间格式管理<br>Audio File Stream Services：创建可以解析流的应用程序，负责流解析，对音频进行解码</p>
<ul>
<li>High-Level Services</li>
</ul>
<p>AVAudioPlayer：高级接口，可以完成整个音频播放的过程<br>Audio Queue Services：录制、播放、暂停、循环、同步音频<br>Extended Audio File Services：Audio File Services 和 Audio Converter services的结合体<br>OpenAL：游戏音频</p>
<h4 id="Audio-Session"><a href="#Audio-Session" class="headerlink" title="Audio Session"></a>Audio Session</h4><p><a href="https://links.jianshu.com/go?to=https://developer.apple.com/library/archive/documentation/Audio/Conceptual/AudioSessionProgrammingGuide/Introduction/Introduction.html%23//apple_ref/doc/uid/TP40007875-CH1-SW1">官方文档 Audio Session Programming Guide</a></p>
<img src="Audio Session.png" alt="Audio Session" style="zoom:60%;" />

<p>可以使用 AVAudioSession 实例与应用程序的音频会话进行交互</p>
<ul>
<li>配置音频会话的类别和模式，告诉系统如何使用音频</li>
<li>激活音频会话使设置的类别和模式使设置生效</li>
<li>订阅并响应音频会话通知，例如音频中断和路由更改</li>
<li>执行高级别的音频设备配置，例如采样率，I/O缓冲持续时间和通道数</li>
</ul>
<h5 id="配置-Audio-Session"><a href="#配置-Audio-Session" class="headerlink" title="配置 Audio Session"></a>配置 Audio Session</h5><p>Audio Session 默认行为</p>
<ul>
<li>支持音频播放，但不允许录音</li>
<li>iOS中，将”铃声/静音”开关设置为静音模式会使应用播放的任何音频静音</li>
<li>iOS中，将设备锁定时，应用程序的音频将静音</li>
<li>当你的应用播放音频时，其他任何背景音频（如音乐应用正在播放的音频）都将静音</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let session &#x3D; AVAudioSession.sharedInstance()</span><br><span class="line">do &#123;</span><br><span class="line">    try session.setCategory(.playback, mode: .moviePlayback, options: [])</span><br><span class="line">&#125; catch let error as NSError &#123;</span><br><span class="line">    print(&quot;Failed to set the audio session category and mode: \(error.localizedDescription)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Category 设置音频的基本行为，可以通过设置 Mode 进一步设置这些行为</p>
<p>例如：IP电话（VoIP）Category设置为 AVAudioSessionCategoryPlayAndRecord，Mode 设置为 AVAudioSessionModeVoiceChat 此模式可确保通过系统提供的信号处理来优化语音信号</p>
<p>某些Category通过会话上设置一个或多个Category选项来支持覆盖默认行为，如AVAudioSessionCategoryPlayback 类别的默认行为会在激活会话时中断其他系统音频，如果您希望音频与其他系统音频混合，则可以通过 AVAudioSessionCategoryOptionMixWithOthers 在会话上设置选项来覆盖此行为</p>
<img src="Category behavior.jpg" alt="Category behavior"/>

<p>大多数应用在启动时只需要设置一次Category，但可以根据需要更改Category，可以在音频会话处于激活状态进行更改，最好在更改Category或者其他会话属性前停用音频会话，停用会话的同时进行这些更改可以防止音频系统不必要的重新配置</p>
<img src="AudioSession mode.png" alt="AudioSession mode"/>

<h6 id="Multiroute-Category"><a href="#Multiroute-Category" class="headerlink" title="Multiroute Category"></a>Multiroute Category</h6><p>多路由Category使应用程序可以使用所有连接的输出端口，而不仅仅使用最后的使用端口</p>
<p>例如，你正在通过HDMI输出路径收听音频并插入耳机，则你的应用将继续通过HDMI输出路径输出音频，同时还通过耳机播放音频</p>
<p>还可以将不同的音频流发送到不同的输出路由，例如，应用可以将一个音频发送到左耳机，将另一个音频发送到右耳机，将第三个音频流发送到HDMI路由</p>
<img src="multiroute.png" alt="multiroute" style="zoom:50%;" />

<p>有效输出路径组合</p>
<ul>
<li>USB和耳机</li>
<li>HDMI和耳机</li>
<li>LineOut和耳机</li>
</ul>
<p>注：仅当未连接任何其他输出端口（USB，HDMI，LineOut）时，才可以使用内置扬声器</p>
<h6 id="选择AirPlay的Category和mode"><a href="#选择AirPlay的Category和mode" class="headerlink" title="选择AirPlay的Category和mode"></a>选择AirPlay的Category和mode</h6><p>仅特定Category和mode支持AirPlay，以下类别通知支持AirPlay的镜像和非镜像版本</p>
<ul>
<li>AVAudioSessionCategorySoloAmbient</li>
<li>AVAudioSessionCategoryAmbient</li>
<li>AVAudioSessionCategoryPlayback<br>AVAudioSessionCategoryPlayAndRecord 类别和以下mode仅支持AirPlay镜像版本</li>
<li>AVAudioSessionModeDefault</li>
<li>AVAudioSessionModeVideoChat</li>
<li>AVAudioSessionModeGameChat</li>
</ul>
<p>注：从 iOS 10 开始，您可以在使用 AVAudioSessionCategoryPlayAndRecord 类别时通过使用 AVAudioSessionCategoryOptionAllowAirPlay 选项激活会话来启用 AirPlay 输出</p>
<h6 id="背景音频"><a href="#背景音频" class="headerlink" title="背景音频"></a>背景音频</h6><p>Capabilities 打开 Background Modes 的 Audio,AirPlay,and Picture in Picture</p>
<h5 id="激活-Audio-Session"><a href="#激活-Audio-Session" class="headerlink" title="激活 Audio Session"></a>激活 Audio Session</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let session &#x3D; AVAudioSession.sharedInstance()</span><br><span class="line">do &#123;</span><br><span class="line">    &#x2F;&#x2F; 1) Configure your audio session category, options, and mode</span><br><span class="line">    &#x2F;&#x2F; 2) Activate your audio session to enable your custom configuration</span><br><span class="line">    try session.setActive(true, options: [])</span><br><span class="line">&#125; catch let error as NSError &#123;</span><br><span class="line">    print(&quot;Unable to activate audio session:  \(error.localizedDescription)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用AVFoundation对象（AVPlayer，AVAudioRecoder）播放或录制音频时，系统会在中断结束时重新激活音频会话，但是如果注册了通知消息并显式重新激活音频会话，则可以验证重新激活成功，还可以更新应用程序的状态和用户界面</p>
<h6 id="检测是否正在播放其他音频"><a href="#检测是否正在播放其他音频" class="headerlink" title="检测是否正在播放其他音频"></a>检测是否正在播放其他音频</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func setupNotification() &#123;</span><br><span class="line">    NotificationCenter.default.addObserver(self,</span><br><span class="line">             selector: #selector(handleSecondaryAudio(notification:)),</span><br><span class="line">             name: AVAudioSession.silenceSecondaryAudioHintNotification,</span><br><span class="line">             object: AVAudioSession.sharedInstance())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@objc func handleSecondaryAudio(notification: Notification) &#123;</span><br><span class="line">    guard let userinfo &#x3D; notification.userInfo ,</span><br><span class="line">    let typeValue &#x3D; userinfo[AVAudioSessionSilenceSecondaryAudioHintTypeKey] as? UInt,</span><br><span class="line">    let type &#x3D; AVAudioSession.SilenceSecondaryAudioHintType(rawValue: typeValue) else &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    if type &#x3D;&#x3D; .begin &#123;</span><br><span class="line">        &#x2F;&#x2F;其他应用音频开始播放 - 将辅助音频静音</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;其他应用音频停止播放 - 重新启动辅助音频</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="响应中断"><a href="#响应中断" class="headerlink" title="响应中断"></a>响应中断</h6><p>你的应用程序可能会中断后暂停，当发生接听电话时，系统会发出中断结束消息，你的应用将继续运行，要恢复音频，必须重新激活音频会话</p>
<img src="Interruption.png" alt="Interruption" style="zoom:60%;" />

<ol>
<li>应用处于活跃状态，正在播放音频</li>
<li>FaceTime请求到达，系统激活FaceTime的音频会话</li>
<li>系统将停用你的音频会话，此时你的应用播放停止</li>
<li>系统发布通知，通知你的会话已被停用</li>
<li>你的应用处理通知，如更新界面保存停止播放点继续播放所需的信息</li>
<li>如果用户取消中断（忽略FaceTime请求），系统发送通知我们应用中断结束</li>
<li>你的应用处理中断结束操作，如更新界面重新激活音频会话并恢复播放</li>
<li>如果没有6的中断，而是接听了电话，你的应用将被暂停</li>
</ol>
<ul>
<li>音频中断处理<br>中断开始后：保存状态和上下文，更新用户界面<br>中断结束后：恢复状态和上下文，更新用户界面，重新激活音频会话</li>
</ul>
<ul>
<li>观察音频中断 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func registerForNotification() &#123;</span><br><span class="line">    NotificationCenter.default.addObserver(self, selector: #selector(handleInterruption(notification:)),</span><br><span class="line">                                           name: AVAudioSession.interruptionNotification,</span><br><span class="line">                                           object: AVAudioSession.sharedInstance())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@objc func handleInterruption(notification: Notification) &#123;</span><br><span class="line">    guard let userinfo &#x3D; notification.userInfo,</span><br><span class="line">          let typeValue &#x3D; userinfo[AVAudioSessionInterruptionTypeKey] as? UInt,</span><br><span class="line">          let type &#x3D; AVAudioSession.InterruptionType(rawValue: typeValue) else &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    if type &#x3D;&#x3D; .began &#123;</span><br><span class="line">        &#x2F;&#x2F;中断开始 采取适当措施（保存状态更新界面）</span><br><span class="line">    &#125; else if type &#x3D;&#x3D; .ended &#123;</span><br><span class="line">        guard let optionsValue &#x3D; userinfo[AVAudioSessionInterruptionOptionKey] as? UInt else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        let options &#x3D; AVAudioSession.InterruptionOptions(rawValue: optionsValue)</span><br><span class="line">        if options.contains(.shouldResume) &#123;</span><br><span class="line">            &#x2F;&#x2F;中断结束 恢复播放</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="响应路由变更"><a href="#响应路由变更" class="headerlink" title="响应路由变更"></a>响应路由变更</h6><p>当用户插入或拔出耳机时，系统会自动更改音频硬件路由</p>
<img src="routechange.png" alt="routechange" style="zoom:60%;" />

<p>你的应用启动后，系统会首先确定音频路由，应用运行时，它将继续监听活动路由</p>
<p>录制期间，用户可以插入和拔出耳机，作为响应，系统发送包含更改原因和先前路由的路由更改通知，应用停止录制</p>
<ul>
<li>观察音频路由变更</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func setupNotification() &#123;</span><br><span class="line">    NotificationCenter.default.addObserver(self, </span><br><span class="line">         selector: #selector(handleRouteChange(notification:)),</span><br><span class="line">         name: AVAudioSession.routeChangeNotification,</span><br><span class="line">         object: AVAudioSession.sharedInstance())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@objc func handleRouteChange(notification: Notification) &#123;</span><br><span class="line">    guard let userinfo &#x3D; notification.userInfo,</span><br><span class="line">          let reasonValue &#x3D; userinfo[AVAudioSessionRouteChangeReasonKey] as? UInt,</span><br><span class="line">          let reason &#x3D; AVAudioSession.RouteChangeReason(rawValue: reasonValue) else &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    switch reason &#123;</span><br><span class="line">    case .newDeviceAvailable:</span><br><span class="line">        print(&quot;处理可用新设备&quot;)</span><br><span class="line">        let session &#x3D; AVAudioSession.sharedInstance()</span><br><span class="line">        for output in session.currentRoute.outputs where output.portType &#x3D;&#x3D; AVAudioSessionPortHeadphones &#123;</span><br><span class="line">            &#x2F;&#x2F;耳机连接true</span><br><span class="line">            headphonesConnected &#x3D; true</span><br><span class="line">        &#125;</span><br><span class="line">    case .oldDeviceUnavailable:</span><br><span class="line">        print(&quot;处理旧设备&quot;)</span><br><span class="line">        if let previousRoute &#x3D;</span><br><span class="line">            userInfo[AVAudioSessionRouteChangePreviousRouteKey] as? AVAudioSessionRouteDescription &#123;</span><br><span class="line">            for output in previousRoute.outputs where output.portType &#x3D;&#x3D; AVAudioSessionPortHeadphones &#123;</span><br><span class="line">                &#x2F;&#x2F;耳机连接false</span><br><span class="line">                headphonesConnected &#x3D; false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    default:</span><br><span class="line">        ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当有新设备时，可以查询音频会话currentRoute属性，返回AVAudioSessionRouteDescription对象，其中列出了音频会话的所有输入和输出</p>
<p>如果路由更改原因是原因 AVAudioSessionRouteChangeReasonOldDeviceUnavailable ，则媒体播放应用应暂停播放，但如果原因是，则不应暂停播放 AVAudioSessionRouteChangeReasonOverride</p>
<p>配置设备硬件</p>
<table>
<thead>
<tr>
<th>设置</th>
<th align="center">首选采样率</th>
<th align="left">首选I/O缓冲区持续时间</th>
</tr>
</thead>
<tbody><tr>
<td>High value</td>
<td align="center">示例：48Hz +高音质 -大文件或缓冲区大小</td>
<td align="left">示例：500ms +较少的文件访问 -更长的延迟</td>
</tr>
<tr>
<td>Low value</td>
<td align="center">示例：8Hz +大文件或缓冲区大小 -低音频质量</td>
<td align="left">示例：5ms +低延迟 -频繁的文件访问</td>
</tr>
</tbody></table>
<p>如果音频质量在你应用中非常重要，并且文件或缓冲区的大小不是主要问题，则可以指定高采样率的首选项</p>
<p>默认音频I/O缓存持续时间（44.1kHz约0.02s）为大多数应用提供了足够的响应速度，可以对延迟有严格要求的应用（如现场乐器监控）设置较低的I/O持续时间，但对大多数应用，无需修改此设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Category and mode</span><br><span class="line">let session &#x3D; AVAudioSession.sharedInstance()</span><br><span class="line">do &#123;</span><br><span class="line">    try session.setCategory(.record, mode: .default, options: [])</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    print(&quot;Unable to set Category: \(error.localizedDescription)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;Set preferred sample rate</span><br><span class="line">do &#123;</span><br><span class="line">    try session.setPreferredSampleRate(44_100)</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    print(&quot;Unable to set preferred sample rate \(error.localizedDescription)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;Set preferred I&#x2F;O buffer duration</span><br><span class="line">do &#123;</span><br><span class="line">    try session.setPreferredIOBufferDuration(0.005)</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    print(&quot;Unable to set preferred I&#x2F;O bufferr duration \(error.localizedDescription)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;Active the audio session</span><br><span class="line">do &#123;</span><br><span class="line">    try session.setActive(true)</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    print(&quot;Unable to active session \(error.localizedDescription)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="选择和配置麦克风"><a href="#选择和配置麦克风" class="headerlink" title="选择和配置麦克风"></a>选择和配置麦克风</h6><ul>
<li>设置首选输入 Setting a Preferred Input<br>要发现内置或已连接的输入端口，使用音频会话的<code>availableInputs</code>属性，返回一个<code>AVAudioSessionPortDescription</code>对象数组，这些对象描述设备的可用输入端口，可用通过端口<code>protType</code>属性标识端口，要设置首选输入端口（内置麦克风，有线麦克风，USB输入等）使用音频会话的<code>setPreferredInput:error:</code>方法</li>
<li>设置首选数据源 Setting a Preferred Data Source<br>某些端口（如内置麦克风和某些USB附件）支持数据源，可用通过查询端口描述的<code>DataSource</code>属性发现可用数据源。<br>对于内置麦克风，返回的数据源描述对象代表每个单独的麦克风，不同设备的内置麦克风返回不同的值。如<code>iPhone4</code>和<code>iPhone4s</code>有两个麦克风：底部和顶部<br>可通过数据源描述的<code>location</code>属性（上部下部）和<code>orientation</code>属性（正面背面）的组合来标识各个内置麦克风，使用<code>setPreferredDataSource:error:</code>方法设置首选数据源<code>AVAudioSessionPortDescription</code></li>
<li>设置首选极性模式 Setting a Preferred Polar Pattern<br>某些iOS设备支持为某些内置麦克风配置麦克风极性模式，麦克风的极性模式定义了其对声音相对于声源方向的灵敏度<br><code>supportedPolarPatterns</code>数据源描述对象的属性返回可用模式。此属性返回数据源支持的极性图案的数组，例如心形或全向，或者<code>nil</code>在没有可用的可选图案时返回。如果数据源具有许多受支持的极性图案，则可以使用数据源描述的<code>[setPreferredPolarPattern:error:</code>方法来设置首选的极性图案</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Preferred Mic &#x3D; Front, Preferred Polar Pattern &#x3D; Cardioid</span><br><span class="line">let preferredMicOrientation &#x3D; AVAudioSession.Orientation.front</span><br><span class="line">let preferredPolarPattern   &#x3D; AVAudioSession.PolarPattern.cardioid</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Retrieve your configured and activated audio session</span><br><span class="line">let session &#x3D; AVAudioSession.sharedInstance()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Get available inputs</span><br><span class="line">guard let inputs &#x3D; session.availableInputs else &#123; return &#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Find built-in mic</span><br><span class="line">guard let builtInMic &#x3D; inputs.first(where: &#123;</span><br><span class="line">    $0.portType &#x3D;&#x3D; AVAudioSession.Port.builtInMic</span><br><span class="line">&#125;) else &#123; return &#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Find the data source at the specified orientation</span><br><span class="line">guard let dataSource &#x3D; builtInMic.dataSources?.first (where: &#123;</span><br><span class="line">    $0.orientation &#x3D;&#x3D; preferredMicOrientation</span><br><span class="line">&#125;) else &#123; return &#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Set data source&#39;s polar pattern</span><br><span class="line">do &#123;</span><br><span class="line">    try dataSource.setPreferredPolarPattern(preferredPolarPattern)</span><br><span class="line">&#125; catch let error as NSError &#123;</span><br><span class="line">    print(&quot;Unable to preferred polar pattern: \(error.localizedDescription)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Set the data source as the input&#39;s preferred data source</span><br><span class="line">do &#123;</span><br><span class="line">    try builtInMic.setPreferredDataSource(dataSource)</span><br><span class="line">&#125; catch let error as NSError &#123;</span><br><span class="line">    print(&quot;Unable to preferred dataSource: \(error.localizedDescription)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Set the built-in mic as the preferred input</span><br><span class="line">&#x2F;&#x2F; This call will be a no-op if already selected</span><br><span class="line">do &#123;</span><br><span class="line">    try session.setPreferredInput(builtInMic)</span><br><span class="line">&#125; catch let error as NSError &#123;</span><br><span class="line">    print(&quot;Unable to preferred input: \(error.localizedDescription)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Print Active Configuration</span><br><span class="line">session.currentRoute.inputs.forEach &#123; portDesc in</span><br><span class="line">    print(&quot;Port: \(portDesc.portType)&quot;)</span><br><span class="line">    if let ds &#x3D; portDesc.selectedDataSource &#123;</span><br><span class="line">        print(&quot;Name: \(ds.dataSourceName)&quot;)</span><br><span class="line">        print(&quot;Polar Pattern: \(ds.selectedPolarPattern) ?? [None]&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="保护隐私"><a href="#保护隐私" class="headerlink" title="保护隐私"></a>保护隐私</h5><p>录制音频前询问并获得用户许可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AVAudioSession.sharedInstance().requestRecordPermission &#123; granted in</span><br><span class="line">    if granted &#123;</span><br><span class="line">        &#x2F;&#x2F; User granted access. Present recording interface.</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Present message to user indicating that recording</span><br><span class="line">        &#x2F;&#x2F; can&#39;t be performed until they change their preference</span><br><span class="line">        &#x2F;&#x2F; under Settings -&gt; Privacy -&gt; Microphone</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问麦克风 Info.plist 添加 NSMicrophoneUsageDescription </p>
]]></content>
  </entry>
  <entry>
    <title>Python</title>
    <url>/2021/03/02/Python/</url>
    <content><![CDATA[<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p><code>r&#39;&#39; </code> 表示 <code>&#39;&#39;</code>  内部的字符串不转义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(r&#39;\\\t\\&#39;)</span><br><span class="line">\\\t\\</span><br></pre></td></tr></table></figure>

<p>多行输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&#39;&#39;&#39;line1</span><br><span class="line">line2</span><br><span class="line">line3&#39;&#39;&#39;)</span><br></pre></td></tr></table></figure>

<p>输入 让用户输入并存放到一个变量里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; name &#x3D; input()</span><br><span class="line">John</span><br><span class="line">&gt;&gt;&gt; print(name)</span><br><span class="line">John</span><br><span class="line">字符串提示输入 </span><br><span class="line">&gt;&gt;&gt; name &#x3D; input(&#39;please enter your name: &#39;)</span><br><span class="line">please enter your name: J</span><br></pre></td></tr></table></figure>

<h5 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h5><p>% 运算符就是用来格式化字符串的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#39;Hello, %s&#39; % &#39;world&#39;)</span><br><span class="line">Hello, world</span><br></pre></td></tr></table></figure>

<p>占位符：%d 整数  %f 浮点数 %s 字符串 %x 十六进制数</p>
<p>如果字符串里面有 % ，需要转义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;growth rate: %d %%&#39; % 7</span><br></pre></td></tr></table></figure>

<h5 id="list-列表"><a href="#list-列表" class="headerlink" title="list 列表"></a>list 列表</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">classmate &#x3D; [&#39;Michael&#39;, &#39;Bob&#39;]</span><br><span class="line">print(classmate, len(classmate), classmate[0])</span><br></pre></td></tr></table></figure>

<p>取最后一个元素 <code>classmate[-1]</code> 倒数第 2 个 <code>classmate[-2]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;追加元素</span><br><span class="line">classmate.append(&#39;Adam&#39;)</span><br><span class="line">&#x2F;&#x2F;插入元素到指定位置</span><br><span class="line">classmate.insert(1, &#39;Jack&#39;)</span><br><span class="line">&#x2F;&#x2F;删除最后元素</span><br><span class="line">classmate.pop()</span><br><span class="line">&#x2F;&#x2F;删除指定位置元素</span><br><span class="line">classmate.pop(1)</span><br><span class="line">&#x2F;&#x2F;替换元素</span><br><span class="line">classmate[1] &#x3D; &#39;Sarah&#39;</span><br></pre></td></tr></table></figure>

<p>list 里面元素类型可以不同，list 元素也可以是 list，取的时候  <code>s[2][1]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [&#39;Apple&#39;, 123, True]</span><br><span class="line">s &#x3D; [&#39;python&#39;, &#39;java&#39;, [&#39;asp&#39;, &#39;php&#39;], &#39;scheme&#39;]</span><br></pre></td></tr></table></figure>

<h5 id="tuple-元组"><a href="#tuple-元组" class="headerlink" title="tuple 元组"></a>tuple 元组</h5><p>初始化后不能修改，tuple 有元素是 list， list 可以变</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">classmates &#x3D; (&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;)</span><br></pre></td></tr></table></figure>

<h5 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">age &#x3D; 3</span><br><span class="line">if age &gt;&#x3D; 18:</span><br><span class="line">    print(&#39;adult&#39;)</span><br><span class="line">elif age &gt;&#x3D; 6:</span><br><span class="line">    print(&#39;teenager&#39;)</span><br><span class="line">else:</span><br><span class="line">    print(&#39;kid&#39;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if x:</span><br><span class="line">    print(&#39;True&#39;)</span><br></pre></td></tr></table></figure>

<h5 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">names &#x3D; [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]</span><br><span class="line">for name in names:</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure>

<p>range() 函数，可以生成一个整数序列，通过 list() 函数可以转换成 list</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list(range(5))</span><br><span class="line">[0, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<h5 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h5><p>get() 方法，如果 key 不存在，可以返回 None，或者自己指定的 value</p>
<p>pop(key) 删除一个 key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d &#x3D; &#123;&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85&#125;</span><br><span class="line">d.get(&#39;Thomas&#39;)</span><br><span class="line">d.get(&#39;Thomas&#39;, -1)</span><br><span class="line">d.pop(&#39;Bob&#39;)</span><br></pre></td></tr></table></figure>

<h5 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h5><p>没有重复的 key，重复元素会自动过滤</p>
<p>add(key) 添加元素</p>
<p>remove(key) 删除元素</p>
<p>两个 set 可以做数学意义上的交集、并集</p>
<p>创建一个 set 需要提供一个 list 作为集合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; set([1, 2, 3])</span><br><span class="line">s &#x3D; set([1, 1, 2, 2, 3, 3])</span><br><span class="line">s.add(4)</span><br><span class="line">s1 &#x3D; set([4, 5, 6])</span><br><span class="line">s &amp; s1</span><br></pre></td></tr></table></figure>

<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if x &gt;&#x3D; 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure>

<p>定义空函数什么也不做，pass 用来做占位符，还没写好的函数可以先放一个 pass</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def nop():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>参数类型检查 isinstance 内置函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if not isinstance(x, (int, float)):</span><br><span class="line">        raise TypeError(&#39;bad operand type&#39;)</span><br><span class="line">    if x &gt;&#x3D; 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure>

<h5 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import math</span><br><span class="line">def move(x, y, step, angle&#x3D;0):</span><br><span class="line">    nx &#x3D; x + step * math.cos(angle)</span><br><span class="line">    ny &#x3D; y - step * math.sin(angle)</span><br><span class="line">    return nx, ny</span><br></pre></td></tr></table></figure>

<p>同时获得返回值，返回一个tuple</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x, y &#x3D; move(100, 100, 60, math.pi &#x2F; 6)</span><br></pre></td></tr></table></figure>

<h5 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h5><p>调用 power(5)，power(5, 3)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def power(x, n&#x3D;2):</span><br><span class="line">    s &#x3D; 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n &#x3D; n - 1</span><br><span class="line">        s &#x3D; s * x</span><br><span class="line">    return s</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def enroll(name, gender, age&#x3D;6, city&#x3D;&#39;Beijing&#39;):</span><br><span class="line">    print(&#39;name:&#39;, name)</span><br><span class="line">    print(&#39;gender:&#39;, gender)</span><br><span class="line">    print(&#39;age:&#39;, age)</span><br><span class="line">    print(&#39;city:&#39;, city)</span><br><span class="line"></span><br><span class="line">enroll(&#39;Bob&#39;, &#39;M&#39;, 7) city参数依然是默认</span><br><span class="line">enroll(&#39;Adam&#39;, &#39;M&#39;, city&#x3D;&#39;Tianjin’) age默认 city用传的值</span><br></pre></td></tr></table></figure>

<h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def calc(numbers):</span><br><span class="line">    sum &#x3D; 0</span><br><span class="line">    for n in numbers:</span><br><span class="line">        sum &#x3D; sum + n * n</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure>

<p>调用的时候传入 list 或 tuple</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">calc([1, 2, 3])</span><br><span class="line">calc((1, 3, 5, 7))</span><br></pre></td></tr></table></figure>

<p>改成可变参数，参数前面加一个 * ，函数内部 nubmers 接收的是一个 tuple</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def calc(*numbers):</span><br><span class="line">    sum &#x3D; 0</span><br><span class="line">    for n in numbers:</span><br><span class="line">        sum &#x3D; sum + n * n</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure>

<p>调用可以传任意参数，或者 0 个参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">calc(1, 2)</span><br><span class="line">calc()</span><br></pre></td></tr></table></figure>

<h5 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h5><p>除了必选参数 name 和 age 外，还接受关键字参数 kw</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def person(name, age, **kw):</span><br><span class="line">    print(&#39;name:&#39;, name, &#39;age:&#39;, age, &#39;other:&#39;, kw)</span><br></pre></td></tr></table></figure>

<p>可以传入任意个数关键字参数，关键字参数在函数内部自动组装为一个 dict</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">person(&#39;Bob&#39;, 35, city&#x3D;&#39;Beijing&#39;)</span><br><span class="line">person(&#39;Adam&#39;, 45, gender&#x3D;&#39;M&#39;, job&#x3D;&#39;Engineer&#39;)</span><br><span class="line"></span><br><span class="line">extra &#x3D; &#123;&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;&#125;</span><br><span class="line">person(&#39;Jack&#39;, 24, city&#x3D;extra[&#39;city&#39;], job&#x3D;extra[&#39;job&#39;])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;把 extra dict 所有 key-value 用关键字参数传入，kw 将获得一个 dict</span><br><span class="line">person(&#39;Jack&#39;, 24, **extra)</span><br><span class="line">&#x2F;&#x2F;name: Jack age: 24 other: &#123;&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>检查参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def person(name, age, **kw):</span><br><span class="line">    if &#39;city&#39; in kw:</span><br><span class="line">        # 有city参数</span><br><span class="line">               pass</span><br><span class="line">    if &#39;job&#39; in kw:</span><br><span class="line">        # 有job参数</span><br><span class="line">               pass</span><br><span class="line">    print(&#39;name:&#39;, name, &#39;age:&#39;, age, &#39;other:&#39;, kw)</span><br></pre></td></tr></table></figure>

<h5 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h5><p>限制关键字参数名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def person(name, age, *, city, job):</span><br><span class="line">    print(name, age, city, job)</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; person(&#39;Jack&#39;, 24, city&#x3D;&#39;Beijing&#39;, job&#x3D;&#39;Engineer&#39;)</span><br></pre></td></tr></table></figure>

<p>如果已经有一个可变参数，后面命名关键字参数就不需要特殊分隔符 * 了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def person(name, age, *args, city, job):</span><br><span class="line">    print(name, age, args, city, job)</span><br></pre></td></tr></table></figure>

<p>调用需要加参数名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">person(&#39;Jack&#39;, 24, job&#x3D;&#39;Engineer&#39;)</span><br></pre></td></tr></table></figure>

<h5 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h5><p>必选参数、默认参数、可变参数、命名关键字参数、关键字参数，5种参数可以组合使用</p>
<p>顺序必须是：必选参数、默认参数、可变参数、命名关键字参数、关键字参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def f1(a, b, c&#x3D;0, *args, **kw):</span><br><span class="line">    print(&#39;a &#x3D;&#39;, a, &#39;b &#x3D;&#39;, b, &#39;c &#x3D;&#39;, c, &#39;args &#x3D;&#39;, args, &#39;kw &#x3D;&#39;, kw)</span><br><span class="line"></span><br><span class="line">def f2(a, b, c&#x3D;0, *, d, **kw):</span><br><span class="line">    print(&#39;a &#x3D;&#39;, a, &#39;b &#x3D;&#39;, b, &#39;c &#x3D;&#39;, c, &#39;d &#x3D;&#39;, d, &#39;kw &#x3D;&#39;, kw)</span><br></pre></td></tr></table></figure>

<p>不要用太多组合，否则理解性很差</p>
<h4 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h4><h5 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h5><p>L[0:3] 从索引 0 开始取，直到索引 3 为止，不包括 3，如果第一个索引是0，可以省略 L[:3]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;, &#39;Bob&#39;, &#39;Jack&#39;]</span><br><span class="line">print(L[0:3])</span><br></pre></td></tr></table></figure>

<p>支持倒数切片 L[-1] 取倒数第一个元素</p>
<p>0-99的数列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; list(range(100))</span><br><span class="line">取前10个数   L[:10]</span><br><span class="line">取后10个数   L[-10:]</span><br><span class="line">取前11-20个数 L[10：20]</span><br><span class="line">前10个数每两个取一个  L[:10:2]</span><br><span class="line">所有数每5个取一个  L[::5]</span><br><span class="line">原样复制一个 list  L[:]</span><br></pre></td></tr></table></figure>

<p>tuple 和 str 也可以用切片操作</p>
<h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;</span><br><span class="line">for key in d:</span><br><span class="line">	print(key)</span><br><span class="line">	</span><br><span class="line">for value in d.values()</span><br><span class="line">for k, v in d.items()</span><br></pre></td></tr></table></figure>

<p>使用<code>for</code>循环时，只要作用于一个可迭代对象，<code>for</code>循环就可以正常运行</p>
<p>通过 collections 模块的 Iterable 类型判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import Iterable</span><br><span class="line">isinstance(&#39;abc&#39;, Iterable)</span><br><span class="line">isinstance([1, 2, 3], Iterable)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i, value in enumerate([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]):</span><br><span class="line">	print(i, value)</span><br></pre></td></tr></table></figure>

<h5 id="列表生成"><a href="#列表生成" class="headerlink" title="列表生成"></a>列表生成</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L &#x3D; [&#39;Hello&#39;, &#39;World&#39;, &#39;IBM&#39;, &#39;Apple&#39;]</span><br><span class="line">&gt;&gt;&gt; [s.lower() for s in L]</span><br><span class="line">[&#39;hello&#39;, &#39;world&#39;, &#39;ibm&#39;, &#39;apple&#39;]</span><br></pre></td></tr></table></figure>

<p>要生成 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; list(range(1, 11))</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure>

<p>生成 [1x1, 2x2, 3x3, …, 10x10]</p>
<p>生成列表时 把要生成的元素x*x放到前面 后面for循环就可以把list创建出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [x * x for x in range(1, 11)]</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure>

<p>循环后面还可以加上 if 判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[x * x for x in range(1, 11) if x % 2 &#x3D;&#x3D; 0]</span><br></pre></td></tr></table></figure>

<p>还可以使用两层循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]</span><br><span class="line">[&#39;AX&#39;, &#39;AY&#39;, &#39;AZ&#39;, &#39;BX&#39;, &#39;BY&#39;, &#39;BZ&#39;, &#39;CX&#39;, &#39;CY&#39;, &#39;CZ&#39;]</span><br></pre></td></tr></table></figure>

<h5 id="生成器-generator"><a href="#生成器-generator" class="headerlink" title="生成器 generator"></a>生成器 generator</h5><p>把列表生成式的 [] 改成 ()，就创建了一个 generator</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g &#x3D; (x * x for x in range(10))</span><br><span class="line">    print(g) &#x2F;&#x2F;&lt;generator object &lt;genexpr&gt; at 0x7f9c13a0bba0&gt;</span><br><span class="line">    for n in g:</span><br><span class="line">        print(n)</span><br></pre></td></tr></table></figure>

<p>generator 在每次调用 next() 的时候执行，遇到 yield 语句返回，再次执行的时候从上次返回的 yield 语句处继续执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def odd():</span><br><span class="line">    print(&#39;step 1&#39;)</span><br><span class="line">    yield 1</span><br><span class="line">    print(&#39;step 2&#39;)</span><br><span class="line">    yield(3)</span><br><span class="line">    print(&#39;step 3&#39;)</span><br><span class="line">    yield(5)</span><br></pre></td></tr></table></figure>

<p>调用时首先生成一个 generator 对象 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">o &#x3D; odd()</span><br><span class="line">next(o)</span><br><span class="line">next(o)</span><br></pre></td></tr></table></figure>

<h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><p>可直接作用于 for 循环的对象称为可迭代对象： <code>Iterable</code></p>
<p>使用 isinstance()，判断一个对象是否是 Iterable</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections.abc import Iterable</span><br><span class="line">isinstance([], Iterable)</span><br><span class="line">isinstance(&#39;abc&#39;, Iterable)</span><br></pre></td></tr></table></figure>

<p>生成器不但可以作用于 for 循环，还可以被 next 函数不断调用返回下一个值，知道最后抛出 StopIteration 错误表示无法继续返回下一个值</p>
<p>可以被 next() 函数调用并返回下一个值的对象称为迭代器：<code> Iterator</code></p>
<p>把 list、dict、str 等 Iterable 变成 Iterator 可以使用 iter() 函数</p>
<h5 id="函数式变成"><a href="#函数式变成" class="headerlink" title="函数式变成"></a>函数式变成</h5><ul>
<li>高阶函数</li>
<li>返回函数</li>
<li>匿名函数</li>
<li>装饰器</li>
</ul>
<p>函数对象有一个  <code>__name__</code> 属性，可以拿到函数的名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def now():</span><br><span class="line">...     print(&#39;2015-3-25&#39;)</span><br><span class="line">&gt;&gt;&gt; now.__name__</span><br></pre></td></tr></table></figure>

<p>代码运行期间动态增加功能的方式，称为装饰器 Decorator</p>
<ul>
<li>偏函数</li>
</ul>
<h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>用包来组织模块，每个包目录下都有一个 <code>__init__.py</code>，文件，必须存在，否则 python 就把这个目录当成一个普通目录，而不是一个包，可以是空文件</p>
<ul>
<li>使用模块</li>
</ul>
<p>以内建的 sys 模块为例， 编写一个 hello 模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python3</span><br><span class="line"># -*- coding: utf-8 -*-  </span><br><span class="line"></span><br><span class="line">&#39; a test module &#39; # 任何模块代码的第一个字符串都被视为模块的文档注释</span><br><span class="line"></span><br><span class="line">__author__ &#x3D; &#39;Michael Liao&#39;</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def test():</span><br><span class="line">    args &#x3D; sys.argv</span><br><span class="line">    if len(args)&#x3D;&#x3D;1:</span><br><span class="line">        print(&#39;Hello, world!&#39;)</span><br><span class="line">    elif len(args)&#x3D;&#x3D;2:</span><br><span class="line">        print(&#39;Hello, %s!&#39; % args[1])</span><br><span class="line">    else:</span><br><span class="line">        print(&#39;Too many arguments!&#39;)</span><br><span class="line"></span><br><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure>

<p>第 1 行 第 2 行是标准注释</p>
<ul>
<li>模块搜索路径</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path</span><br></pre></td></tr></table></figure>

<h5 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h5><ul>
<li>创建 Logger 记录器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger &#x3D; logging.getLogger()</span><br></pre></td></tr></table></figure>

<p>设置日志级别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.setLevel(logging.INFO)</span><br></pre></td></tr></table></figure>

<ul>
<li>Handler 处理器</li>
</ul>
<p>常用三种 StreamHandler、FileHandler、NullHandler</p>
<p>创建 StreamHandler 之后，可以设置日志级别，设置格式化器 Formatter，增加或删除过滤器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console_handler &#x3D; logging.StreamHandler()</span><br><span class="line"># 指定日志级别 低于WARN级别日志将被忽略</span><br><span class="line">console_handler.setLevel(logging.WARN)</span><br><span class="line"># 设置一个格式化器 formatter</span><br><span class="line">console_handler.setFormatter(formatter_name)</span><br><span class="line"># 增加过滤器</span><br><span class="line">console_handler.addFilter(filter_name)</span><br><span class="line"># 删除过滤器</span><br><span class="line">console_handler.removeFilter(filter_name)</span><br></pre></td></tr></table></figure>

<p>jd_logger.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import logging</span><br><span class="line">import logging.handlers</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">日志模块</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">LOG_FILENAME &#x3D; &#39;..&#x2F;jd_seckill.log&#39;</span><br><span class="line">logger &#x3D; logging.getLogger()</span><br><span class="line"></span><br><span class="line">def set_logger():</span><br><span class="line">    logger.setLevel(logging.INFO)</span><br><span class="line">    formatter &#x3D; logging.Formatter(&#39;%(asctime)s - %(process)d-%(threadName)s - &#39;</span><br><span class="line">                                  &#39;%(pathname)s[line:%(lineno)d] - %(levelname)s: %(message)s&#39;)</span><br><span class="line">    console_handler &#x3D; logging.StreamHandler()</span><br><span class="line">    console_handler.setFormatter(formatter)</span><br><span class="line">    logger.addHandler(console_handler)</span><br><span class="line">    file_handler &#x3D; logging.handlers.RotatingFileHandler(</span><br><span class="line">        LOG_FILENAME, maxBytes&#x3D;10485760, backupCount&#x3D;5, encoding&#x3D;&quot;utf-8&quot;)</span><br><span class="line">    file_handler.setFormatter(formatter)</span><br><span class="line">    logger.addHandler(file_handler)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set_logger()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%(levelno)s 打印日志级别的数值 </span><br><span class="line">%(levelname)s 打印日志级别名称</span><br><span class="line">%(pathname)s 打印当前执行程序的路径 </span><br><span class="line">%(filename)s 打印当前执行程序名称</span><br><span class="line">%(funcName)s 打印日志的当前函数 </span><br><span class="line">%(lineno)d 打印日志的当前行号 </span><br><span class="line">%(asctime)s 打印日志的时间 </span><br><span class="line">%(thread)d 打印线程id </span><br><span class="line">%(threadName)s 打印线程名称</span><br><span class="line">%(process)d 打印进程ID</span><br><span class="line">%(message)s 打印日志信息</span><br></pre></td></tr></table></figure>







<h4 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h4><h5 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h5><p>(object) 表示从哪个类继承下来的</p>
<p>第一个参数固定self 表示创建实例本身</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student(object) </span><br><span class="line">	def __init__(self, name, score):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.score &#x3D; score</span><br><span class="line">  def print_score(self):</span><br><span class="line">        print(&#39;%s: %s&#39; % (self.name, self.score))</span><br></pre></td></tr></table></figure>

<p>有了init方法 创建实例的时候就不能传空参数了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bart &#x3D; Student(&#39;Bart&#39;, 59)</span><br></pre></td></tr></table></figure>

<h5 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h5><p>如果要让内部属性不被外部访问，名称前加两个下划线 <code>__</code>，就变成私有变量，这样外部就不能访问了，如果要外部访问可以增加 get 方法</p>
<p>添加 get set 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def get_name(self):</span><br><span class="line">    return self.__name</span><br><span class="line">def get_score(self):</span><br><span class="line">    return self.__score</span><br><span class="line">def set_score(self, score):</span><br><span class="line">    self.__score &#x3D; score</span><br></pre></td></tr></table></figure>

<ul>
<li>对象信息</li>
</ul>
<p>type()  判断对象类型、isinstance()</p>
<p>获取对象所有属性和方法 dir()， 返回包含字符串的 list</p>
<ul>
<li>实例属性和类属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    name &#x3D; &#39;Student&#39; # 类属性</span><br></pre></td></tr></table></figure>

<h4 id="面向对象高级编程"><a href="#面向对象高级编程" class="headerlink" title="面向对象高级编程"></a>面向对象高级编程</h4><h4 id="错误、调试和测试"><a href="#错误、调试和测试" class="headerlink" title="错误、调试和测试"></a>错误、调试和测试</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    print(&#39;try...&#39;)</span><br><span class="line">    r &#x3D; 10 &#x2F; int(&#39;a&#39;)</span><br><span class="line">    print(&#39;result:&#39;, r)</span><br><span class="line">except ValueError as e:</span><br><span class="line">    print(&#39;ValueError:&#39;, e)</span><br><span class="line">except ZeroDivisionError as e:</span><br><span class="line">    print(&#39;ZeroDivisionError:&#39;, e)</span><br><span class="line">finally:</span><br><span class="line">    print(&#39;finally...&#39;)</span><br><span class="line">print(&#39;END&#39;)</span><br></pre></td></tr></table></figure>

<p>Python 所有的错误都是从 BaseException 类派生的</p>
<p>常见的错误类型和继承关系 <a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy">https://docs.python.org/3/library/exceptions.html#exception-hierarchy</a></p>
<ul>
<li>记录错误</li>
</ul>
<p>内置的 logging 模块可以非常容易的记录错误，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># err_logging.py</span><br><span class="line">import logging</span><br><span class="line"></span><br><span class="line">def foo(s):</span><br><span class="line">    return 10 &#x2F; int(s)</span><br><span class="line">def bar(s):</span><br><span class="line">    return foo(s) * 2</span><br><span class="line">def main():</span><br><span class="line">    try:</span><br><span class="line">        bar(&#39;0&#39;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        logging.exception(e)</span><br><span class="line">main()</span><br><span class="line">print(&#39;END&#39;)</span><br></pre></td></tr></table></figure>

<p>通过配置 loging 还可以把错误记录到日志文件里</p>
<p>抛出错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># err_raise.py</span><br><span class="line">class FooError(ValueError):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def foo(s):</span><br><span class="line">    n &#x3D; int(s)</span><br><span class="line">    if n&#x3D;&#x3D;0:</span><br><span class="line">        raise FooError(&#39;invalid value: %s&#39; % s)</span><br><span class="line">    return 10 &#x2F; n</span><br><span class="line"></span><br><span class="line">foo(&#39;0&#39;)</span><br></pre></td></tr></table></figure>











<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p><a href="https://tool.oschina.net/regex">正则表达式测试工具</a></p>
<table>
<thead>
<tr>
<th align="left">\w</th>
<th align="left">匹配字母、数字、下划线,等价于[a-zA-Z0-9_]</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\W</td>
<td align="left">匹配不是字母、数字、下划线的其他字符</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配任意空白字符,等价于(\t\n\r\f)</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">匹配任意非空字符</td>
</tr>
<tr>
<td align="left">\d</td>
<td align="left">匹配数字,等价于[0-9]</td>
</tr>
<tr>
<td align="left">\D</td>
<td align="left">匹配不是数字的字符</td>
</tr>
<tr>
<td align="left">\A</td>
<td align="left">匹配字符串开头</td>
</tr>
<tr>
<td align="left">\Z</td>
<td align="left">匹配字符串结尾的,如果存在换行,只匹配到换行前的结束字符串</td>
</tr>
<tr>
<td align="left">\z</td>
<td align="left">匹配字符串结尾的,如果存在换行,匹配到换行符\n</td>
</tr>
<tr>
<td align="left">\G</td>
<td align="left">最好完成匹配的位置</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">匹配一个换行符</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">匹配一个制表符(tab)</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">匹配一行字符串的开头</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配一行字符串的结尾</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配任意字符,除了换行符.当re.DOTALL标记被指定时,这可以匹配包括换行符在内的任字符</td>
</tr>
<tr>
<td align="left">[…]</td>
<td align="left">用来表示一组字符,比如[abc]表示匹配a或b或c,[a-z],[0-9]</td>
</tr>
<tr>
<td align="left">[^…]</td>
<td align="left">匹配不在[]里面的字符,比如[^abc]匹配除a,b,c以外的字符</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">匹配0个或多个字符</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">匹配1个或多个字符</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">匹配0个或1个前面的正则表达式片段,(.*?)表示尽可能少地匹配字符</td>
</tr>
<tr>
<td align="left">{n}</td>
<td align="left">精确匹配前面n个前面的表达式,如\d{5}表示匹配5个数字</td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left">匹配前面的表达式n到m次,贪婪模式</td>
</tr>
<tr>
<td align="left">a|b</td>
<td align="left">匹配a或者b</td>
</tr>
<tr>
<td align="left">(…)</td>
<td align="left">匹配括号里的表达式,也可以表示一个组</td>
</tr>
</tbody></table>
<h5 id="匹配目标"><a href="#匹配目标" class="headerlink" title="匹配目标"></a>匹配目标</h5><p>使用 （） 括号将想提取的字符串括起来，调用 group() 方法提取结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">content &#x3D; &#39;Hello 1234567 World This is a Regex Demo&#39;</span><br><span class="line">result &#x3D; re.match(&#39;^Hello\s(\d+)\sWorld&#39;, content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group(1))</span><br><span class="line">print(result.span())</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;re.Match object; span&#x3D;(0, 19), match&#x3D;&#39;Hello 1234567 World&#39;&gt;</span><br><span class="line">1234567</span><br><span class="line">(0, 19)</span><br></pre></td></tr></table></figure>

<p>想将字符串中的 1234567 提取出来，可以将数字部分的正则表达式用 （）括起来，然后调用 group(1) 获取匹配结果，如果后面还有（）内容，依次用 group(2) 获取</p>
<p>span 输出匹配范围</p>
<h5 id="通用匹配"><a href="#通用匹配" class="headerlink" title="通用匹配"></a>通用匹配</h5><p>.* 匹配任意字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; re.match(&#39;^Hello.*Demo$&#39;, content)</span><br><span class="line">print(result.group())</span><br></pre></td></tr></table></figure>

<p>中间部分省略，最后加一个结尾字符串</p>
<p>group() 输出匹配的全部字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello 123 4567 World This is a Regex Demo</span><br></pre></td></tr></table></figure>

<h5 id="贪婪与非贪婪"><a href="#贪婪与非贪婪" class="headerlink" title="贪婪与非贪婪"></a>贪婪与非贪婪</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">content &#x3D; &#39;Hello 1234567 World This is a Regex Demo&#39;</span><br><span class="line">result &#x3D; re.match(&#39;^He.*(\d+).*Demo$&#39;, content)</span><br><span class="line">print(result.group(1))</span><br></pre></td></tr></table></figure>

<p>依然想匹配中间数字，数字两边比较乱，省略都写成 <code> .*</code>，结果打印只有 7</p>
<p>贪婪匹配 .* 会匹配尽可能多的字符，123456 也被前面匹配了，最后得到内容只有 7</p>
<p>非贪婪匹配，尽可能匹配少的字符，<code>.*?</code> 来代替 <code>.*</code> ，最后得到结果 1234567</p>
<h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">content &#x3D; &#39;&#39;&#39;Hello 1234567 World This </span><br><span class="line">is a Regex Demo&#39;&#39;&#39;</span><br><span class="line">result &#x3D; re.match(&#39;^He.*?(\d+).*?Demo$&#39;, content)</span><br><span class="line">print(result.group(1))</span><br></pre></td></tr></table></figure>

<p>修改在字符串中加了换行符，没有匹配到结果，又调用了 group 会报错</p>
<p>因为匹配的是除换行符之外的任意字符，遇到换行符时，.* 就不能匹配了，导致匹配失败，只需要加一个修饰符 re.S 修正</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; re.match(&#39;^He.*?(\d+).*?Demo$&#39;, content, re.S)</span><br></pre></td></tr></table></figure>

<p>re.S 使匹配包括换行在内的所有字符</p>
<p>re.I 使匹配对大小写不敏感</p>
<h5 id="修饰符-1"><a href="#修饰符-1" class="headerlink" title="修饰符"></a>修饰符</h5><p>正则匹配遇到特殊字符时，使用转义 \</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">content &#x3D; &#39;(百度)www.baidu.com&#39;</span><br><span class="line">result &#x3D; re.match(&#39;\(百度\)www\.baidu\.com&#39;, content)</span><br></pre></td></tr></table></figure>

<h5 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h5><p>match() 是从字符串开头开始匹配的，开头不匹配就会失效</p>
<p>Search() 匹配时会扫描整个字符串，返回一个成功匹配结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html &#x3D; &#39;&#39;&#39;</span><br><span class="line">&lt;div id&#x3D;&quot;songs-list&quot;&gt;</span><br><span class="line">&lt;h2 class&#x3D;&quot;title&quot;&gt;经典老歌&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;p class&#x3D;&quot;introduction&quot;&gt;经典老歌列表</span><br><span class="line">&lt;ul id&#x3D;&quot;list&quot; class&#x3D;&quot;list-group&quot;&gt;</span><br><span class="line">	&lt;li data-view&#x3D;&quot;2&quot;&gt;一路上有你&lt;&#x2F;li&gt;</span><br><span class="line">	&lt;li data-view&#x3D;&quot;7”&gt;</span><br><span class="line">		&lt;a href&#x3D;&quot;&#x2F;2.mp3&quot; singer&#x3D;&quot;任贤齐&quot;&gt;沧海一卢笑&lt;&#x2F;a&gt; </span><br><span class="line">	&lt;&#x2F;li&gt;</span><br><span class="line">	&lt;li data-view&#x3D;&quot;4&quot; class&#x3D;&quot;active&quot;&gt;</span><br><span class="line">		&lt;a href&#x3D;&quot;&#x2F;3.mp3&quot; singer&#x3D;&quot;齐秦&quot;&gt;往事随风&lt;&#x2F;a&gt;</span><br><span class="line">	&lt;&#x2F;li&gt;</span><br><span class="line">	&lt;li data-view&#x3D;&quot;6&quot;&gt;&lt;a href&#x3D;&quot;&#x2F;4.mp3&quot; singer&#x3D;&quot;beyond&quot;&gt;尤辉岁月&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; </span><br><span class="line">	&lt;li data-view&#x3D;&quot;5&quot;&gt;&lt;a href&#x3D;&quot;&#x2F;S.mp3&quot; singer&#x3D;&quot;陈慧琳&quot;&gt;记事本&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; </span><br><span class="line">	&lt;li data-view&#x3D;&quot;5&quot;&gt;</span><br><span class="line">		&lt;a href&#x3D;&quot;&#x2F;6.mp3&quot; singer&#x3D;&quot;邓丽君&quot;&gt;但愿人长久&lt;&#x2F;a&gt;</span><br><span class="line">	&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;&#39;&#39;&#39;</span><br></pre></td></tr></table></figure>

<p>尝试获取 class 为 active 的 li 节点内部超链接包含的歌手名和歌名</p>
<p>此时需要提取第三个 li 节点下 a 节点的 singer 属性和文本</p>
<p>正则表达式可以以 li 开头，寻找下一个标识符 active，中间部分用 .<em>? 来匹配，接下来取 singer 属性值</em></p>
<p> <code>singer=&quot;(.*?)&quot;</code>  需要提取部分用小括号括起来，用 group 提取，两侧的便捷是双引号</p>
<p>接下来匹配 a 节点文本，左边界是  <code>&gt;</code>  右边界是 <code>&lt;/a&gt;</code> 目标内容用 <code>.*?</code> 匹配</p>
<p><code>&lt;li.*?active.*?singer=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; re.search(&#39;&lt;li.*?active.*?singer&#x3D;&quot;(.*?)&quot;&gt;(.*?)&lt;&#x2F;a&gt;&#39;, html, re.S)</span><br><span class="line">if result:</span><br><span class="line">	print(result.group(1), result.group(2))</span><br></pre></td></tr></table></figure>

<h5 id="findall"><a href="#findall" class="headerlink" title="findall"></a>findall</h5><p>search 返回匹配正则表达式第一个内容，想要匹配所有内容使用 findall() ，会搜索整个字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">results &#x3D; re.findall(&#39;&lt;li.*?href&#x3D;&quot;(.*?)&quot;.*?singer&#x3D;&quot;(.*?)&quot;&gt;(.*?)&lt;&#x2F;a&gt;&#39;, html, re.S)</span><br><span class="line">print(type(results))</span><br><span class="line">for result in results:</span><br><span class="line">print(result[0], result[1], result[2])</span><br></pre></td></tr></table></figure>

<p>返回的每个元素都是元组类型，用对应索引依次取出</p>
<h5 id="sub"><a href="#sub" class="headerlink" title="sub"></a>sub</h5><p>修改文本，把一串字符串中的数字去掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">content &#x3D; &#39;54aKS4yrsoiRS4ix5L2g&#39;</span><br><span class="line">content &#x3D; re.sub(&#39;\d+&#39;,&#39;&#39;, content)</span><br></pre></td></tr></table></figure>

<p>上面 html 中需要获取歌名，直接正则表达式提取比较麻烦</p>
<p>借助 sub 方法将 a 节点去掉只留下文本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html &#x3D; re.sub(&#39;&lt;a.*?&gt;|&lt;&#x2F;a&gt;&#39;, &#39;&#39;, html)</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;songs-list&quot;&gt;</span><br><span class="line">&lt;h2 class&#x3D;&quot;title&quot;&gt;经典老歌&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;p class&#x3D;&quot;introduction&quot;&gt;经典老歌列表</span><br><span class="line">&lt;ul id&#x3D;&quot;list&quot; class&#x3D;&quot;list-group&quot;&gt;</span><br><span class="line">	&lt;li data-view&#x3D;&quot;2&quot;&gt;一路上有你&lt;&#x2F;li&gt;</span><br><span class="line">	&lt;li data-view&#x3D;&quot;7”&gt;</span><br><span class="line">		沧海一卢笑 </span><br><span class="line">	&lt;&#x2F;li&gt;</span><br><span class="line">	&lt;li data-view&#x3D;&quot;4&quot; class&#x3D;&quot;active&quot;&gt;</span><br><span class="line">		往事随风</span><br><span class="line">	&lt;&#x2F;li&gt;</span><br><span class="line">	&lt;li data-view&#x3D;&quot;6&quot;&gt;尤辉岁月&lt;&#x2F;li&gt; </span><br><span class="line">	&lt;li data-view&#x3D;&quot;5&quot;&gt;记事本&lt;&#x2F;li&gt; </span><br><span class="line">	&lt;li data-view&#x3D;&quot;5&quot;&gt;</span><br><span class="line">		但愿人长久</span><br><span class="line">	&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>再利用 findall 提取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">results &#x3D; re.findall(&#39;&lt;li.*?&gt;(.*?)&lt;&#x2F;li&gt;&#39;, html, re.S)</span><br><span class="line">for result in results:</span><br><span class="line">	print(result.strip())</span><br></pre></td></tr></table></figure>

<p>strip 移除字符串首尾指定字符 strip() 去除首尾空格，strip(‘0’) 去除首尾字符 0</p>
<h5 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h5><p>将正则字符串编译成正则表达式对象，以便在后面的匹配中复用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">content1 &#x3D; &#39;2016-12-15 12:00&#39;</span><br><span class="line">content2 &#x3D; &#39;2016-12-17 12:55&#39;</span><br><span class="line">content3 &#x3D; &#39;2016-12-22 13:21&#39;</span><br><span class="line">pattern &#x3D; re.compile(&#39;\d&#123;2&#125;:\d&#123;2&#125;&#39;)</span><br><span class="line">result1 &#x3D; re.sub(pattern, &#39;&#39;, content1)</span><br><span class="line">result2 &#x3D; re.sub(pattern, &#39;&#39;, content2)</span><br><span class="line">result3 &#x3D; re.sub(pattern, &#39;&#39;, content3)</span><br><span class="line">print(result1, result2, result3)</span><br></pre></td></tr></table></figure>

<p>通过 compile 编译成正则表达式对象，后面就不用重复写正则表达式</p>
<hr>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4>]]></content>
  </entry>
  <entry>
    <title>RxSwift（三）</title>
    <url>/2021/09/03/RxSwift%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h4 id="1-错误处理"><a href="#1-错误处理" class="headerlink" title="1 错误处理"></a>1 错误处理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum MyError: Error &#123;</span><br><span class="line">    case A</span><br><span class="line">    case B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-catchErrorJustReturn"><a href="#1-1-catchErrorJustReturn" class="headerlink" title="1.1 catchErrorJustReturn"></a>1.1 catchErrorJustReturn</h5><p>遇到error事件时，就返回指定的值，然后结束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sequenceFailed &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">sequenceFailed</span><br><span class="line">    .catchErrorJustReturn(&quot;错误&quot;)</span><br><span class="line">    .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">sequenceFailed.onNext(&quot;a&quot;)</span><br><span class="line">sequenceFailed.onNext(&quot;b&quot;)</span><br><span class="line">sequenceFailed.onError(MyError.A)</span><br><span class="line">sequenceFailed.onNext(&quot;c&quot;)</span><br><span class="line">结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">错误</span><br></pre></td></tr></table></figure>

<h5 id="1-2-catchError"><a href="#1-2-catchError" class="headerlink" title="1.2 catchError"></a>1.2 catchError</h5><p>捕获error，并对其处理，同时还能返回另一个observable序列进行订阅</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sequenceFailed &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">let recoverSequence &#x3D; Observable.of(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)</span><br><span class="line">    sequenceFailed</span><br><span class="line">        .catchError &#123;</span><br><span class="line">            print(&quot;Error:&quot;, $0)</span><br><span class="line">            return recoverSequence</span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">    sequenceFailed.onNext(&quot;a&quot;)</span><br><span class="line">    sequenceFailed.onNext(&quot;b&quot;)</span><br><span class="line">    sequenceFailed.onError(MyError.A)</span><br><span class="line">    sequenceFailed.onNext(&quot;c&quot;)</span><br><span class="line">结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">Error: A</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h5 id="1-3-retry"><a href="#1-3-retry" class="headerlink" title="1.3 retry"></a>1.3 retry</h5><p>遇到错误的时候，重新订阅该序列<br>retry()传入数字表示重试次数，不传默认1次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var count &#x3D; 1</span><br><span class="line">let sequenceError &#x3D; Observable&lt;String&gt;.create &#123; (observer) -&gt; Disposable in</span><br><span class="line">    observer.onNext(&quot;a&quot;)</span><br><span class="line">    observer.onNext(&quot;b&quot;)</span><br><span class="line">    if count &#x3D;&#x3D; 1 &#123;</span><br><span class="line">        observer.onError(MyError.A)</span><br><span class="line">        print(&quot;error&quot;)</span><br><span class="line">        count +&#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">    observer.onNext(&quot;c&quot;)</span><br><span class="line">    observer.onCompleted()</span><br><span class="line">    return Disposables.create()</span><br><span class="line">&#125;</span><br><span class="line">sequenceError</span><br><span class="line">.retry(2)</span><br><span class="line">.subscribe(onNext: &#123;print($0)&#125;)</span><br><span class="line">.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h4 id="2-调试操作"><a href="#2-调试操作" class="headerlink" title="2 调试操作"></a>2 调试操作</h4><h5 id="2-1-debug"><a href="#2-1-debug" class="headerlink" title="2.1 debug"></a>2.1 debug</h5><p>还可以传入标记参数<code>.debug(&quot;调试1&quot;)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.of(2, 3)</span><br><span class="line">  .startWith(1)</span><br><span class="line">  .debug()</span><br><span class="line">  .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class="line">  .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="2-2-RxSwift-Resources-total"><a href="#2-2-RxSwift-Resources-total" class="headerlink" title="2.2 RxSwift.Resources.total"></a>2.2 RxSwift.Resources.total</h5><p>将RxSwift.Resources.total打印出来可以查看当前RxSwift申请的所有资源数量 检查内存泄漏时有用<br>开启需要在Podfile开启配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(RxSwift.Resources.total)</span><br></pre></td></tr></table></figure>

<h4 id="3-特征序列"><a href="#3-特征序列" class="headerlink" title="3 特征序列"></a>3 特征序列</h4><h5 id="3-1-Single"><a href="#3-1-Single" class="headerlink" title="3.1 Single"></a>3.1 Single</h5><p>observable另一个版本，只能发出一个元素，要么产生一个error<br>不会共享状态变化<br>常用于执行HTTP请求，成功返回应答或错误</p>
<p>RxSwift为Single提供了一个枚举（SingleEvent）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum SingleEvent&lt;Element&gt; &#123;</span><br><span class="line">    case success(Element)</span><br><span class="line">    case error(Swift.Error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>样例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum DataError: Error &#123;</span><br><span class="line">    case cantParseJSON</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getPlayList(_ channel: String) -&gt; Single&lt;[String: Any]&gt; &#123;</span><br><span class="line">    return Single&lt;[String: Any]&gt;.create &#123; (single) -&gt; Disposable in</span><br><span class="line">        let url &#x3D; &quot;https:&#x2F;&#x2F;douban.fm&#x2F;j&#x2F;mine&#x2F;playlist?&quot; + &quot;type&#x3D;n&amp;channel&#x3D;\(channel)&amp;from&#x3D;mainsite&quot;</span><br><span class="line">        let task &#x3D; URLSession.shared.dataTask(with: URL(string: url)!) &#123; (data, _, error) in</span><br><span class="line">            if let error &#x3D; error &#123;</span><br><span class="line">                single(.error(error))</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            guard let data &#x3D; data,</span><br><span class="line">                  let json &#x3D; try? JSONSerialization.jsonObject(with: data, options: .mutableLeaves),</span><br><span class="line">                  let result &#x3D; json as? [String: Any] else &#123;</span><br><span class="line">                single(.error(DataError.cantParseJSON))</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            single(.success(result))</span><br><span class="line">        &#125;</span><br><span class="line">        task.resume()</span><br><span class="line">        return Disposables.create &#123; task.cancel() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 也可以用<code>subscribe(onSuccess:onError:)</code>方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getPlayList(&quot;0&quot;)</span><br><span class="line">    .subscribe &#123; (event) in</span><br><span class="line">        switch event &#123;</span><br><span class="line">        case.success(let json):</span><br><span class="line">            print(&quot;JSON结果：&quot;, json)</span><br><span class="line">        case .error(let error):</span><br><span class="line">            print(&quot;发生错误：&quot;, error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<ul>
<li>asSingle</li>
</ul>
<p>可以通过observable的asSingle()，转换为Single</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.of(&quot;1&quot;)</span><br><span class="line">    .asSingle()</span><br><span class="line">    .subscribe(&#123;print($0)&#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="3-2-Completable"><a href="#3-2-Completable" class="headerlink" title="3.2 Completable"></a>3.2 Completable</h5><p>要么只能产生一个completed事件，要么产生一个error事件<br>不会共享状态变化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func cacheLocally() -&gt; Completable &#123;</span><br><span class="line">    return Completable.create &#123; (completeable) -&gt; Disposable in</span><br><span class="line">        let success &#x3D; (arc4random() % 2 &#x3D;&#x3D; 0)</span><br><span class="line">        guard success else &#123;</span><br><span class="line">            completeable(.error(CacheError.failedCaching))</span><br><span class="line">            return Disposables.create &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completeable(.completed)</span><br><span class="line">        return Disposables.create &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">enum CacheError: Error &#123;</span><br><span class="line">   case failedCaching</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 也可使用<code>subscribe(onCompleted:onError:)</code>方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cacheLocally()</span><br><span class="line">    .subscribe &#123; (completable) in</span><br><span class="line">        switch completable &#123;</span><br><span class="line">        case .completed:</span><br><span class="line">            print(&quot;保存成功&quot;)</span><br><span class="line">        case .error(let error):</span><br><span class="line">            print(&quot;保存失败：\(error.localizedDescription)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="3-3-Maybe"><a href="#3-3-Maybe" class="headerlink" title="3.3 Maybe"></a>3.3 Maybe</h5><p>介于Single和Completable之间，要么只能发出一个元素，要么产生一个completable事件，要么产生error事件<br>不会共享状态变化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum MaybeEvent&lt;Element&gt; &#123;</span><br><span class="line">    case success(Element)</span><br><span class="line">    case error(Swift.Error)</span><br><span class="line">    case completed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func generateString() -&gt; Maybe&lt;String&gt; &#123;</span><br><span class="line">    return Maybe.create &#123; (maybe) -&gt; Disposable in</span><br><span class="line">        maybe(.success(&quot;hang&quot;))</span><br><span class="line">        maybe(.completed)</span><br><span class="line">        return Disposables.create &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>asMaybe</li>
</ul>
<p>可以通过observable的asMaybe()，转换为Maybe</p>
<h4 id="4-Driver"><a href="#4-Driver" class="headerlink" title="4 Driver"></a>4 Driver</h4><p>目标是提供一种简便的方式在UI层编写响应式代码<br>不会产生error事件<br>一定在主线程监听<br>共享状态变化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let results &#x3D; query.rx.text.asDriver()        &#x2F;&#x2F; 将普通序列转换为 Driver</span><br><span class="line">    .throttle(0.3, scheduler: MainScheduler.instance)</span><br><span class="line">    .flatMapLatest &#123; query in</span><br><span class="line">        fetchAutoCompleteItems(query)</span><br><span class="line">            .asDriver(onErrorJustReturn: [])  &#x2F;&#x2F; 仅仅提供发生错误时的备选返回值</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;将返回的结果绑定到显示结果数量的label上</span><br><span class="line">results</span><br><span class="line">    .map &#123; &quot;\($0.count)&quot; &#125;</span><br><span class="line">    .drive(resultCount.rx.text) &#x2F;&#x2F; 这里使用 drive 而不是 bindTo</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;将返回的结果绑定到tableView上</span><br><span class="line">results</span><br><span class="line">    .drive(resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123; &#x2F;&#x2F;  同样使用 drive 而不是 bindTo</span><br><span class="line">        (_, result, cell) in</span><br><span class="line">        cell.textLabel?.text &#x3D; &quot;\(result)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="4-1-asDriver"><a href="#4-1-asDriver" class="headerlink" title="4.1 asDriver"></a>4.1 asDriver</h5><p><code>query.rx.text.asDriver</code>将ControlProperty转换为Driver，将普通序列转换为Driver</p>
<h5 id="4-2-asDriver-onErrorJustReturn"><a href="#4-2-asDriver-onErrorJustReturn" class="headerlink" title="4.2 asDriver(onErrorJustReturn: )"></a>4.2 asDriver(onErrorJustReturn: )</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let disposeBag &#x3D; DisposeBag()</span><br><span class="line">let pubSubject &#x3D; PublishSubject&lt;Int&gt;()</span><br><span class="line"></span><br><span class="line">pubSubject.asDriver(onErrorJustReturn: 1000)</span><br><span class="line">    .drive(onNext: &#123;</span><br><span class="line">        print($0)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">pubSubject.onNext(10)</span><br><span class="line">pubSubject.onNext(29)</span><br><span class="line">pubSubject.onError(CustomError.test)</span><br></pre></td></tr></table></figure>

<h5 id="4-3-asDriver-onErrorDriveWith"><a href="#4-3-asDriver-onErrorDriveWith" class="headerlink" title="4.3 asDriver(onErrorDriveWith:)"></a>4.3 asDriver(onErrorDriveWith:)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let disposeBag &#x3D; DisposeBag()</span><br><span class="line">let pubSubject &#x3D; PublishSubject&lt;Int&gt;()</span><br><span class="line">let recoverySubject &#x3D; PublishSubject&lt;Int&gt;()</span><br><span class="line">pubSubject.asDriver(onErrorDriveWith:</span><br><span class="line">    recoverySubject.asDriver(onErrorJustReturn: 1000))</span><br><span class="line">        .drive(onNext: &#123;</span><br><span class="line">            print($0)</span><br><span class="line">        &#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br><span class="line">pubSubject.onNext(19)</span><br><span class="line">pubSubject.onError(CustomError.test)</span><br><span class="line">recoverySubject.onNext(10)</span><br></pre></td></tr></table></figure>

<h4 id="5-ControlProperty"><a href="#5-ControlProperty" class="headerlink" title="5 ControlProperty"></a>5 ControlProperty</h4><p>专门用来描述UI控件的属性，拥有该类型的属性都是被观察者observable<br>特性：<br>不会产生error事件，一定在主线程订阅，主线程监听，共享状态变化</p>
<p>UITextField+Rx.swift 中 UITextField 的 rx.text 属性类型便是 ControlProperty</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension Reactive where Base: UITextField &#123;</span><br><span class="line">    public var text: ControlProperty&lt;String?&gt; &#123;</span><br><span class="line">        return value</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public var value: ControlProperty&lt;String?&gt; &#123;</span><br><span class="line">        return base.rx.controlPropertyWithDefaultEvents(</span><br><span class="line">            getter: &#123; textField in</span><br><span class="line">                textField.text</span><br><span class="line">        &#125;,</span><br><span class="line">            setter: &#123; textField, value in</span><br><span class="line">                if textField.text !&#x3D; value &#123;</span><br><span class="line">                    textField.text &#x3D; value</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-ControlEvent"><a href="#6-ControlEvent" class="headerlink" title="6 ControlEvent"></a>6 ControlEvent</h4><p>专门用来描述UI所产生事件，拥有该类型的属性都是被观察者observable<br>特性：<br>不会产生error事件，一定在主线程订阅，主线程监听，共享状态变化</p>
<p>UIButton 的 rx.tap 方法类型便是 ControlEvent<Void></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension Reactive where Base: UIButton &#123;</span><br><span class="line">    public var tap: ControlEvent&lt;Void&gt; &#123;</span><br><span class="line">        return controlEvent(.touchUpInside)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 UIViewController 进行扩展</p>
<ul>
<li>将  viewDidLoad、viewDidAppear、viewDidLayoutSubviews 等各种 ViewController 生命周期的方法转成 ControlEvent 方便在 RxSwift 项目中使用。</li>
<li>增加 isVisible 序列属性，方便对视图的显示状态进行订阅。</li>
<li>增加 isDismissing 序列属性，方便对视图的释放进行订阅。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public extension Reactive where Base: UIViewController &#123;</span><br><span class="line">    public var viewDidLoad: ControlEvent&lt;Void&gt; &#123;</span><br><span class="line">        let source &#x3D; self.methodInvoked(#selector(Base.viewDidLoad)).map &#123; _ in &#125;</span><br><span class="line">        return ControlEvent(events: source)</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public var viewWillAppear: ControlEvent&lt;Bool&gt; &#123;</span><br><span class="line">        let source &#x3D; self.methodInvoked(#selector(Base.viewWillAppear))</span><br><span class="line">            .map &#123; $0.first as? Bool ?? false &#125;</span><br><span class="line">        return ControlEvent(events: source)</span><br><span class="line">    &#125;</span><br><span class="line">    public var viewDidAppear: ControlEvent&lt;Bool&gt; &#123;</span><br><span class="line">        let source &#x3D; self.methodInvoked(#selector(Base.viewDidAppear))</span><br><span class="line">            .map &#123; $0.first as? Bool ?? false &#125;</span><br><span class="line">        return ControlEvent(events: source)</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public var viewWillDisappear: ControlEvent&lt;Bool&gt; &#123;</span><br><span class="line">        let source &#x3D; self.methodInvoked(#selector(Base.viewWillDisappear))</span><br><span class="line">            .map &#123; $0.first as? Bool ?? false &#125;</span><br><span class="line">        return ControlEvent(events: source)</span><br><span class="line">    &#125;</span><br><span class="line">    public var viewDidDisappear: ControlEvent&lt;Bool&gt; &#123;</span><br><span class="line">        let source &#x3D; self.methodInvoked(#selector(Base.viewDidDisappear))</span><br><span class="line">            .map &#123; $0.first as? Bool ?? false &#125;</span><br><span class="line">        return ControlEvent(events: source)</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public var viewWillLayoutSubviews: ControlEvent&lt;Void&gt; &#123;</span><br><span class="line">        let source &#x3D; self.methodInvoked(#selector(Base.viewWillLayoutSubviews))</span><br><span class="line">            .map &#123; _ in &#125;</span><br><span class="line">        return ControlEvent(events: source)</span><br><span class="line">    &#125;</span><br><span class="line">    public var viewDidLayoutSubviews: ControlEvent&lt;Void&gt; &#123;</span><br><span class="line">        let source &#x3D; self.methodInvoked(#selector(Base.viewDidLayoutSubviews))</span><br><span class="line">            .map &#123; _ in &#125;</span><br><span class="line">        return ControlEvent(events: source)</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public var willMoveToParentViewController: ControlEvent&lt;UIViewController?&gt; &#123;</span><br><span class="line">        let source &#x3D; self.methodInvoked(#selector(Base.willMove))</span><br><span class="line">            .map &#123; $0.first as? UIViewController &#125;</span><br><span class="line">        return ControlEvent(events: source)</span><br><span class="line">    &#125;</span><br><span class="line">    public var didMoveToParentViewController: ControlEvent&lt;UIViewController?&gt; &#123;</span><br><span class="line">        let source &#x3D; self.methodInvoked(#selector(Base.didMove))</span><br><span class="line">            .map &#123; $0.first as? UIViewController &#125;</span><br><span class="line">        return ControlEvent(events: source)</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public var didReceiveMemoryWarning: ControlEvent&lt;Void&gt; &#123;</span><br><span class="line">        let source &#x3D; self.methodInvoked(#selector(Base.didReceiveMemoryWarning))</span><br><span class="line">            .map &#123; _ in &#125;</span><br><span class="line">        return ControlEvent(events: source)</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;表示视图是否显示的可观察序列，当VC显示状态改变时会触发</span><br><span class="line">    public var isVisible: Observable&lt;Bool&gt; &#123;</span><br><span class="line">        let viewDidAppearObservable &#x3D; self.base.rx.viewDidAppear.map &#123; _ in true &#125;</span><br><span class="line">        let viewWillDisappearObservable &#x3D; self.base.rx.viewWillDisappear</span><br><span class="line">            .map &#123; _ in false &#125;</span><br><span class="line">        return Observable&lt;Bool&gt;.merge(viewDidAppearObservable,</span><br><span class="line">                                      viewWillDisappearObservable)</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F;表示页面被释放的可观察序列，当VC被dismiss时会触发</span><br><span class="line">    public var isDismissing: ControlEvent&lt;Bool&gt; &#123;</span><br><span class="line">        let source &#x3D; self.sentMessage(#selector(Base.dismiss))</span><br><span class="line">            .map &#123; $0.first as? Bool ?? false &#125;</span><br><span class="line">        return ControlEvent(events: source)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-调度器"><a href="#7-调度器" class="headerlink" title="7 调度器"></a>7 调度器</h4><p>控制任务在哪个线程或队列运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let rxData: Observable&lt;Data&gt; &#x3D; ...</span><br><span class="line"> </span><br><span class="line">rxData</span><br><span class="line">    .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .userInitiated)) &#x2F;&#x2F;后台构建序列</span><br><span class="line">    .observeOn(MainScheduler.instance)  &#x2F;&#x2F;主线程监听并处理序列结果</span><br><span class="line">    .subscribe(onNext: &#123; [weak self] data in</span><br><span class="line">        self?.data &#x3D; data</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="7-1-subscribeOn"><a href="#7-1-subscribeOn" class="headerlink" title="7.1 subscribeOn()"></a>7.1 subscribeOn()</h5><p>决定数据序列的构建在哪个schedule上运行</p>
<p>比如上面样例，由于获取数据、解析数据需要花费一段时间的时间，所以通过 <strong>subscribeOn</strong> 将其切换到后台 <strong>Scheduler</strong> 来执行。这样可以避免主线程被阻塞</p>
<h5 id="7-2-observeOn"><a href="#7-2-observeOn" class="headerlink" title="7.2 observeOn()"></a>7.2 observeOn()</h5><p>决定哪个schedule上监听这个数据序列</p>
<p>比如上面样例，我们获取并解析完毕数据后又通过 <strong>observeOn</strong> 方法切换到主线程来监听并且处理结果</p>
<h4 id="8-双向绑定"><a href="#8-双向绑定" class="headerlink" title="8 双向绑定"></a>8 双向绑定</h4><p>比如控件的某个属性值与 ViewModel 里的某个 Subject 属性进行双向绑定</p>
<p>当 ViewModel 里的值发生改变时，可以同步反映到控件上</p>
<p>如果对控件值修改，ViewModel 那边值同时也会发生改变</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;将用户名与textField做双向绑定</span><br><span class="line">userVM.username.asObservable().bind(to: textField.rx.text).disposed(by: disposeBag)</span><br><span class="line">textField.rx.text.orEmpty.bind(to: userVM.username).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义双向绑定操作符</li>
</ul>
<p>xSwift自带的双向绑定操作符 &lt;-&gt;<br>在RxSwift项目文件夹中 RxExample中 Operators.swift</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;将用户名与textField做双向绑定</span><br><span class="line">_ &#x3D;  self.textField.rx.textInput &lt;-&gt;  self.userVM.username</span><br></pre></td></tr></table></figure>

<h4 id="9-UITableView"><a href="#9-UITableView" class="headerlink" title="9 UITableView"></a>9 UITableView</h4><h5 id="9-1-单分区的表格数据"><a href="#9-1-单分区的表格数据" class="headerlink" title="9.1 单分区的表格数据"></a>9.1 单分区的表格数据</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let items &#x3D; Observable.just([</span><br><span class="line">    &quot;First Item&quot;,</span><br><span class="line">    &quot;Second Item&quot;,</span><br><span class="line">    &quot;Third Item&quot;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>绑定数据一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">items</span><br><span class="line">    .bind(to: tableView.rx.items)</span><br><span class="line">    &#123; (tableView, row, element) in</span><br><span class="line">        let cell &#x3D; tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;)!</span><br><span class="line">        cell.textLabel?.text &#x3D; &quot;\(element) @ row \(row)&quot;</span><br><span class="line">        return cell</span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p>绑定数据二：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">items</span><br><span class="line">    .bind(to: tableView.rx.items(cellIdentifier: &quot;Cell&quot;, cellType: UITableViewCell.self))</span><br><span class="line">    &#123; (row, element, cell) in</span><br><span class="line">        cell.textLabel?.text &#x3D; &quot;\(element) @ row \(row)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<ul>
<li>单元格选中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tableView.rx.itemSelected.subscribe(onNext: &#123; indexPath in</span><br><span class="line">    print(&quot;选中index：\(indexPath.row)&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">.disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">tableView.rx.modelSelected(String.self).subscribe(onNext: &#123; item in</span><br><span class="line">    print(&quot;选中内容：\(item)&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<ul>
<li>同时获取索引和内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.zip(tableView.rx.itemSelected, tableView.rx.modelSelected(String.self))</span><br><span class="line">    .subscribe(onNext: &#123; indexPath, item in</span><br><span class="line">        print(&quot;\(indexPath) \(item)&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.zip(tableView.rx.itemSelected, tableView.rx.modelSelected(String.self))</span><br><span class="line">    .bind &#123; indexPath, item in</span><br><span class="line">        print(&quot;\(indexPath) \(item)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<ul>
<li>删除单元格</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tableView.rx.itemDeleted.subscribe(onNext: &#123; indexPath in</span><br><span class="line">    print(&quot;删除index: \(indexPath.row)&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h4 id="10-RxDataSource"><a href="#10-RxDataSource" class="headerlink" title="10 RxDataSource"></a>10 RxDataSource</h4><p>以 Section 来作为数据结构的</p>
<h5 id="10-1-单分区-TableView"><a href="#10-1-单分区-TableView" class="headerlink" title="10.1 单分区 TableView"></a>10.1 单分区 TableView</h5><p>使用自带 Section</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let items &#x3D; Observable.just([</span><br><span class="line">    SectionModel(model: &quot;&quot;, items: [</span><br><span class="line">        &quot;UILabel&quot;,</span><br><span class="line">        &quot;UITextView&quot;,</span><br><span class="line">        &quot;UIButton&quot;</span><br><span class="line">    ])</span><br><span class="line">])</span><br><span class="line">&#x2F;&#x2F;创建数据源</span><br><span class="line">let dataSource &#x3D; RxTableViewSectionedReloadDataSource&lt;SectionModel&lt;String, String&gt;&gt; &#123; dataSource, tableView, indexPath, element in</span><br><span class="line">    let cell &#x3D; tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;)!</span><br><span class="line">    cell.textLabel?.text &#x3D; &quot;index：\(indexPath.row) element: \(element)&quot;</span><br><span class="line">    return cell</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;绑定单元格数据</span><br><span class="line">items</span><br><span class="line">    .bind(to: tableView.rx.items(dataSource: dataSource))</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="10-2-多分区-TableView"><a href="#10-2-多分区-TableView" class="headerlink" title="10.2 多分区 TableView"></a>10.2 多分区 TableView</h5><p>使用自带 Section</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let items &#x3D; Observable.just([</span><br><span class="line">    SectionModel(model: &quot;基本控件&quot;, items: [</span><br><span class="line">        &quot;UILabel&quot;,</span><br><span class="line">        &quot;UIButton&quot;,</span><br><span class="line">    ]),</span><br><span class="line">    SectionModel(model: &quot;高级控件&quot;, items: [</span><br><span class="line">        &quot;UITableView&quot;,</span><br><span class="line">        &quot;UICollectionView&quot;,</span><br><span class="line">    ]),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建数据源</span><br><span class="line">let dataSource &#x3D; RxTableViewSectionedReloadDataSource&lt;SectionModel&lt;String, String&gt;&gt; &#123; dataSource, tableView, indexPath, element in</span><br><span class="line">    let cell &#x3D; tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;)!</span><br><span class="line">    cell.textLabel?.text &#x3D; &quot;index：\(indexPath.row) element: \(element)&quot;</span><br><span class="line">    return cell</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置分区头标题</span><br><span class="line">dataSource.titleForHeaderInSection &#x3D; &#123; dataSource, index in</span><br><span class="line">    return dataSource.sectionModels[index].model</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">items</span><br><span class="line">    .bind(to: tableView.rx.items(dataSource: dataSource))</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="10-3-使用自定义-Section"><a href="#10-3-使用自定义-Section" class="headerlink" title="10.3 使用自定义 Section"></a>10.3 使用自定义 Section</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let items &#x3D; Observable.just([</span><br><span class="line">    MySection(header: &quot;基本控件&quot;, items: [</span><br><span class="line">        &quot;UILabel&quot;,</span><br><span class="line">        &quot;UIButton&quot;,</span><br><span class="line">    ]),</span><br><span class="line">    MySection(header: &quot;高级控件&quot;, items: [</span><br><span class="line">        &quot;UITableView&quot;,</span><br><span class="line">        &quot;UICollectionView&quot;,</span><br><span class="line">    ]),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建数据源</span><br><span class="line">let dataSource &#x3D; RxTableViewSectionedReloadDataSource&lt;MySection&gt; &#123; dataSource, tableView, indexPath, element in</span><br><span class="line">    let cell &#x3D; tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;)!</span><br><span class="line">    cell.textLabel?.text &#x3D; &quot;index：\(indexPath.row) element: \(element)&quot;</span><br><span class="line">    return cell</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置分区头标题</span><br><span class="line">dataSource.titleForHeaderInSection &#x3D; &#123; dataSource, index in</span><br><span class="line">    return dataSource.sectionModels[index].header</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">items</span><br><span class="line">    .bind(to: tableView.rx.items(dataSource: dataSource))</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="10-4-数据刷新"><a href="#10-4-数据刷新" class="headerlink" title="10.4 数据刷新"></a>10.4 数据刷新</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let refreshButton: UIBarButtonItem &#x3D; UIBarButtonItem(title: &quot;Refresh&quot;, style: .plain, target: self, action: nil)</span><br><span class="line"></span><br><span class="line">let randomResult &#x3D; refreshButton.rx.tap</span><br><span class="line">    .startWith(())&#x2F;&#x2F;一开始就能自动请求一次数据</span><br><span class="line">    .flatMapLatest(getRandomResult)&#x2F;&#x2F;多次请求取最后一次</span><br><span class="line">    .share()</span><br><span class="line"></span><br><span class="line">let dataSource &#x3D; RxTableViewSectionedReloadDataSource&lt;SectionModel&lt;String, Int&gt;&gt; &#123; dataSource, tableView, indexPath, element in</span><br><span class="line">    let cell &#x3D; tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;)!</span><br><span class="line">    cell.textLabel?.text &#x3D; &quot;\(indexPath.row): \(element)&quot;</span><br><span class="line">    return cell</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">randomResult</span><br><span class="line">    .bind(to: tableView.rx.items(dataSource: dataSource))</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">func getRandomResult() -&gt; Observable&lt;[SectionModel&lt;String, Int&gt;]&gt;&#123;</span><br><span class="line">        print(&quot;请求数据..&quot;)</span><br><span class="line">        let items &#x3D; (0..&lt;5).map &#123; _ in</span><br><span class="line">            Int(arc4random())</span><br><span class="line">        &#125;</span><br><span class="line">        let observable &#x3D; Observable.just([SectionModel(model: &quot;S&quot;, items: items)])</span><br><span class="line">        return observable.delay(RxTimeInterval.seconds(2), scheduler: MainScheduler.instance)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>也可以在源头进行限制，1秒内多次点击只取最后一次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let randomResult &#x3D; refreshButton.rx.tap</span><br><span class="line">    .throttle(RxTimeInterval.seconds(1), scheduler: MainScheduler.instance)</span><br><span class="line">    .startWith(())&#x2F;&#x2F;一开始就能自动请求一次数据</span><br><span class="line">    .share()</span><br></pre></td></tr></table></figure>

<ul>
<li> 停止数据请求</li>
</ul>
<p>使用 takeUntil，当 takeUntil 中的 Observable 发送一个值时，便会结束对应的 Observable</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let stopButton: UIBarButtonItem &#x3D; UIBarButtonItem(title: &quot;Cancel&quot;, style: .plain, target: self, action: nil)</span><br><span class="line"></span><br><span class="line">let randomResult &#x3D; refreshButton.rx.tap</span><br><span class="line">    .startWith(())&#x2F;&#x2F;一开始就能自动请求一次数据</span><br><span class="line">    .flatMapLatest &#123;</span><br><span class="line">        self.getRandomResult().takeUntil(self.stopButton.rx.tap)</span><br><span class="line">    &#125;.share()</span><br></pre></td></tr></table></figure>

<h5 id="10-5-搜索过滤"><a href="#10-5-搜索过滤" class="headerlink" title="10.5 搜索过滤"></a>10.5 搜索过滤</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var searchBar: UISearchBar!</span><br><span class="line">tableView.tableHeaderView &#x3D; searchBar</span><br><span class="line"></span><br><span class="line">let randomResult &#x3D; refreshButton.rx.tap</span><br><span class="line">    .startWith(())&#x2F;&#x2F;一开始就能自动请求一次数据</span><br><span class="line">    .flatMapLatest &#123;</span><br><span class="line">        self.getRandomResult().takeUntil(self.stopButton.rx.tap)</span><br><span class="line">    &#125;</span><br><span class="line">    .flatMapLatest(filterResult)</span><br><span class="line">    .share()</span><br><span class="line">      </span><br><span class="line">func filterResult(data: [SectionModel&lt;String, Int&gt;]) -&gt; Observable&lt;[SectionModel&lt;String, Int&gt;]&gt; &#123;</span><br><span class="line">    self.searchBar.rx.text.orEmpty.flatMapLatest &#123; query -&gt; Observable&lt;[SectionModel&lt;String, Int&gt;]&gt; in</span><br><span class="line">        print(&quot;筛选数据(条件为：\(query)&quot;)</span><br><span class="line">        if query.isEmpty &#123;</span><br><span class="line">            return Observable.just(data)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var newData: [SectionModel&lt;String, Int&gt;] &#x3D; []</span><br><span class="line">            for sectionModel in data &#123;</span><br><span class="line">                let items &#x3D; sectionModel.items.filter &#123; &quot;\($0)&quot;.contains(query) &#125;</span><br><span class="line">                newData.append(SectionModel(model: sectionModel.model, items: items))</span><br><span class="line">            &#125;</span><br><span class="line">            return Observable.just(newData)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10-6-可编辑表格"><a href="#10-6-可编辑表格" class="headerlink" title="10.6 可编辑表格"></a>10.6 可编辑表格</h5><p>定义各种操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum TableEditingCommand &#123;</span><br><span class="line">    case setItems(items: [String])</span><br><span class="line">    case addItem(item: String)</span><br><span class="line">    case moveItem(from: IndexPath, to: IndexPath)</span><br><span class="line">    case deleteItem(IndexPath)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义ViewModel，保存除了表格数据外，还包含4个操作指令的具体实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct TableViewModel &#123;</span><br><span class="line">    fileprivate var items: [String]</span><br><span class="line">    </span><br><span class="line">    init(items: [String] &#x3D; []) &#123;</span><br><span class="line">        self.items &#x3D; items</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func execute(command: TableEditingCommand) -&gt; TableViewModel &#123;</span><br><span class="line">        switch command &#123;</span><br><span class="line">        case .setItems(let items):</span><br><span class="line">            print(&quot;设置表格数据&quot;)</span><br><span class="line">            return TableViewModel(items: items)</span><br><span class="line">        case .addItem(let item):</span><br><span class="line">            print(&quot;新增数据&quot;)</span><br><span class="line">            var items &#x3D; self.items</span><br><span class="line">            items.append(item)</span><br><span class="line">            return TableViewModel(items: items)</span><br><span class="line">        case .moveItem(let from, let to):</span><br><span class="line">            print(&quot;移动数据&quot;)</span><br><span class="line">            var items &#x3D; self.items</span><br><span class="line">            items.insert(items.remove(at: from.row), at: to.row)</span><br><span class="line">            return TableViewModel(items: items)</span><br><span class="line">        case .deleteItem(let indexPath):</span><br><span class="line">            print(&quot;删除数据项&quot;)</span><br><span class="line">            var items &#x3D; self.items</span><br><span class="line">            items.remove(at: indexPath.row)</span><br><span class="line">            return TableViewModel(items: items)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ViewController</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line"></span><br><span class="line">    let disposeBag &#x3D; DisposeBag()</span><br><span class="line">    </span><br><span class="line">    var tableView: UITableView!</span><br><span class="line">    </span><br><span class="line">    let refreshButton: UIBarButtonItem &#x3D; UIBarButtonItem(title: &quot;Refresh&quot;, style: .plain, target: self, action: nil)</span><br><span class="line">    let addButton    : UIBarButtonItem &#x3D; UIBarButtonItem(title: &quot;Add&quot;, style: .plain, target: self, action: nil)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        self.tableView &#x3D; UITableView(frame: view.frame, style: .plain)</span><br><span class="line">        self.tableView.register(UITableViewCell.self, forCellReuseIdentifier: &quot;Cell&quot;)</span><br><span class="line">        self.view.addSubview(tableView)</span><br><span class="line"></span><br><span class="line">        navigationItem.leftBarButtonItem  &#x3D; addButton</span><br><span class="line">        navigationItem.rightBarButtonItem &#x3D; refreshButton</span><br><span class="line">        </span><br><span class="line">        let initialVM &#x3D; TableViewModel()</span><br><span class="line">        </span><br><span class="line">        let refreshCommand &#x3D; refreshButton.rx.tap</span><br><span class="line">            .startWith(())</span><br><span class="line">            .flatMapLatest(getRandomResult)</span><br><span class="line">            .map(TableEditingCommand.setItems)</span><br><span class="line">        </span><br><span class="line">        let addCommand &#x3D; addButton.rx.tap</span><br><span class="line">            .map &#123; &quot;\(arc4random())&quot; &#125;</span><br><span class="line">            .map(TableEditingCommand.addItem)</span><br><span class="line">        </span><br><span class="line">        let moveCommand &#x3D; tableView.rx.itemMoved</span><br><span class="line">            .map (TableEditingCommand.moveItem)</span><br><span class="line">        </span><br><span class="line">        let deleteCommand &#x3D; tableView.rx.itemDeleted</span><br><span class="line">            .map(TableEditingCommand.deleteItem)</span><br><span class="line">        </span><br><span class="line">        Observable.of(refreshCommand, addCommand, moveCommand, deleteCommand)</span><br><span class="line">            .merge()</span><br><span class="line">            .scan(initialVM) &#123; (vm: TableViewModel, command: TableEditingCommand) -&gt; TableViewModel  in</span><br><span class="line">                return vm.execute(command: command)</span><br><span class="line">            &#125;</span><br><span class="line">            .startWith(initialVM)</span><br><span class="line">            .map &#123;</span><br><span class="line">                [AnimatableSectionModel(model: &quot;&quot;, items: $0.items)]</span><br><span class="line">            &#125;</span><br><span class="line">            .share()</span><br><span class="line">            .bind(to: tableView.rx.items(dataSource: ViewController.dataSource()))</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func getRandomResult() -&gt; Observable&lt;[String]&gt; &#123;</span><br><span class="line">        print(&quot;生成随机数&quot;)</span><br><span class="line">        let items &#x3D; (0..&lt;5).map &#123; _ in</span><br><span class="line">            &quot;\(arc4random())&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        return Observable.just(items)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func viewDidAppear(_ animated: Bool) &#123;</span><br><span class="line">        super.viewDidAppear(animated)</span><br><span class="line">        tableView.setEditing(true, animated: true)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">extension ViewController &#123;</span><br><span class="line"></span><br><span class="line">    static func dataSource() -&gt; RxTableViewSectionedAnimatedDataSource&lt;AnimatableSectionModel&lt;String, String&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">        let configuration: AnimationConfiguration &#x3D;</span><br><span class="line">            AnimationConfiguration(insertAnimation: .top,</span><br><span class="line">                                   reloadAnimation: .fade,</span><br><span class="line">                                   deleteAnimation: .left)</span><br><span class="line"></span><br><span class="line">        return RxTableViewSectionedAnimatedDataSource(</span><br><span class="line">            animationConfiguration: configuration) &#123; dataSource, tv, indexPath, element in</span><br><span class="line">            let cell &#x3D; tv.dequeueReusableCell(withIdentifier: &quot;Cell&quot;)!</span><br><span class="line">            cell.textLabel?.text &#x3D; &quot;条目：\(indexPath.row) \(element)&quot;</span><br><span class="line">            return cell</span><br><span class="line">        &#125; canEditRowAtIndexPath: &#123; _, _ in</span><br><span class="line">            return true</span><br><span class="line">        &#125; canMoveRowAtIndexPath: &#123; _, _ in</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10-7-不同类型-Cell"><a href="#10-7-不同类型-Cell" class="headerlink" title="10.7 不同类型 Cell"></a>10.7 不同类型 Cell</h5>]]></content>
  </entry>
  <entry>
    <title>RxSwift（二）操作符</title>
    <url>/2021/09/03/RxSwift%EF%BC%88%E4%BA%8C%EF%BC%89%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<h4 id="1-变换操作"><a href="#1-变换操作" class="headerlink" title="1 变换操作"></a>1 变换操作</h4><p>对原始的Observable序列进行一些转换</p>
<h5 id="1-1-buffer"><a href="#1-1-buffer" class="headerlink" title="1.1 buffer"></a>1.1 buffer</h5><p>缓冲组合，参数1缓冲时间，参数2缓冲个数，参数3线程<br>缓存Observable中发出的元素，元素达到某个数量或经过特定时间，就将元素集合发送出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let subject &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;每缓存3个元素则组合一起发出来</span><br><span class="line">&#x2F;&#x2F;如果1秒内不够3个也会发出（有几个发几个，一个没有发[]）</span><br><span class="line">subject</span><br><span class="line">    .buffer(timeSpan: RxTimeInterval.seconds(1), count: 3, scheduler: MainScheduler.instance)</span><br><span class="line">    .subscribe(onNext: &#123; print($0)&#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(&quot;a&quot;)</span><br><span class="line">subject.onNext(&quot;b&quot;)</span><br><span class="line">subject.onNext(&quot;c&quot;)</span><br><span class="line"></span><br><span class="line">subject.onNext(&quot;1&quot;)</span><br><span class="line">subject.onNext(&quot;2&quot;)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">[&quot;1&quot;, &quot;2&quot;]</span><br><span class="line">[]</span><br><span class="line">[]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h5 id="1-2-window"><a href="#1-2-window" class="headerlink" title="1.2 window"></a>1.2 window</h5><p>和 buffer 类似，Buffer是周期性的将缓存的元素集合发送出来，window周期性的将元素集合以observable形态发送出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let subject &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">subject</span><br><span class="line">    .window(timeSpan: RxTimeInterval.seconds(1), count: 3, scheduler: MainScheduler.instance)</span><br><span class="line">    .subscribe(onNext: &#123;</span><br><span class="line">        print($0)</span><br><span class="line">        $0.subscribe(onNext: &#123; print($0) &#125;)</span><br><span class="line">          .disposed(by: self.disposeBag)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(&quot;a&quot;)</span><br><span class="line">subject.onNext(&quot;b&quot;)</span><br><span class="line">subject.onNext(&quot;c&quot;)</span><br><span class="line"></span><br><span class="line">subject.onNext(&quot;1&quot;)</span><br><span class="line">subject.onNext(&quot;2&quot;)</span><br><span class="line">  </span><br><span class="line">结果：</span><br><span class="line">RxSwift.AddRef&lt;Swift.String&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">RxSwift.AddRef&lt;Swift.String&gt;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">RxSwift.AddRef&lt;Swift.String&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h5 id="1-3-map"><a href="#1-3-map" class="headerlink" title="1.3 map"></a>1.3 map</h5><p>传入一个函数闭包，把原来observable序列转变为一个新的observable序列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.of(1, 2, 3)</span><br><span class="line">    .map &#123; $0 * 10 &#125;</span><br><span class="line">    .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="4-4-flatMap"><a href="#4-4-flatMap" class="headerlink" title="4.4 flatMap"></a>4.4 flatMap</h5><p><code>map </code>做转换的时候容易出现升维情况，转变后，从一个序列变为一个序列的序列<br><code>flatMap</code> 会对源observable的每个元素应用一个转换方法，转换成observables，然后将这些observables元素合并后发送出来，即又将其降维成一个observable序列</p>
<p>Observable 的元素本生拥有其他的 Observable 时，我们可以将所有子 Observables 的元素发送出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let subject1 &#x3D; BehaviorSubject(value: &quot;A&quot;)</span><br><span class="line">let subject2 &#x3D; BehaviorSubject(value: &quot;1&quot;)</span><br><span class="line"></span><br><span class="line">let replay &#x3D; BehaviorRelay(value: subject1)</span><br><span class="line">replay.asObservable()</span><br><span class="line">    .flatMap&#123; $0 &#125;</span><br><span class="line">    .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject1.onNext(&quot;B&quot;)</span><br><span class="line">replay.accept(subject2)</span><br><span class="line">subject2.onNext(&quot;2&quot;)</span><br><span class="line">subject1.onNext(&quot;C&quot;)</span><br><span class="line">      </span><br><span class="line">结果：</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">C</span><br></pre></td></tr></table></figure>

<h5 id="4-5-flatMapLatest"><a href="#4-5-flatMapLatest" class="headerlink" title="4.5 flatMapLatest"></a>4.5 flatMapLatest</h5><p>和flatMap唯一区别，只会接收最新的value事件<br>将flatMap的例子替换成flatMapLatest</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h5 id="1-6-flatMapFirst"><a href="#1-6-flatMapFirst" class="headerlink" title="1.6 flatMapFirst"></a>1.6 flatMapFirst</h5><p>和flatMapLatest相反，只接收最初value事件</p>
<p>可以防止重复请求<br>如：点击按钮发送请求，请求完成前，该按钮点击都不应该继续发送请求</p>
<p>将flatMap的例子替换成 flatMapFirst</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure>

<h5 id="4-7-concatMap"><a href="#4-7-concatMap" class="headerlink" title="4.7 concatMap"></a>4.7 concatMap</h5><p>和flatMap区别：前一个Observable元素发送完毕后，后一个Observable才可以开始发出元素。<br>等待前一个Observable产生完成事件后，才对后一个Observable进行订阅</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let subject1 &#x3D; BehaviorSubject(value: &quot;A&quot;)</span><br><span class="line">let subject2 &#x3D; BehaviorSubject(value: &quot;1&quot;)</span><br><span class="line"></span><br><span class="line">let replay &#x3D; BehaviorRelay(value: subject1)</span><br><span class="line">replay</span><br><span class="line">    .concatMap &#123; $0 &#125;</span><br><span class="line">    .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject1.onNext(&quot;B&quot;)</span><br><span class="line">replay.accept(subject2)</span><br><span class="line">subject2.onNext(&quot;2&quot;)</span><br><span class="line">subject1.onNext(&quot;C&quot;)</span><br><span class="line">subject1.onCompleted() &#x2F;&#x2F;只有前一个序列结束，才能接收下一个序列 如果没有complete 只输出 A B C</span><br><span class="line">结果：</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h5 id="4-8-scan"><a href="#4-8-scan" class="headerlink" title="4.8 scan"></a>4.8 scan</h5><p>先给一个初始化的数，然后不断拿前一个结果和最新值进行处理操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.of(1, 2, 3, 4, 6)</span><br><span class="line">    .scan(0) &#123; acum, elem in</span><br><span class="line">        acum + elem</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">结果：</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">10</span><br><span class="line">16</span><br></pre></td></tr></table></figure>

<h5 id="1-9-groupBy"><a href="#1-9-groupBy" class="headerlink" title="1.9 groupBy"></a>1.9 groupBy</h5><p>将源Observable分解为多个子Observable，然后将子Observable发送出来<br>会将元素通过某个键进行分组，然后将分组后的元素序列以Observable形态发送出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable&lt;Int&gt;.of(0, 1, 2, 3, 4, 5)</span><br><span class="line">    .groupBy &#123; element -&gt; String in</span><br><span class="line">        return element % 2 &#x3D;&#x3D; 0 ? &quot;偶数&quot;:&quot;奇数&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe &#123; event in</span><br><span class="line">        switch event &#123;</span><br><span class="line">        case .next(let group):</span><br><span class="line">            group</span><br><span class="line">                .subscribe(onNext: &#123; print(&quot;key:\(group.key) \($0)&quot;) &#125;)</span><br><span class="line">                .disposed(by: self.disposeBag)</span><br><span class="line">        default:</span><br><span class="line">            print(&quot;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.disposed(by: disposeBag)</span><br><span class="line">结果：</span><br><span class="line">key:奇数 1</span><br><span class="line">key:偶数 2</span><br><span class="line">key:奇数 3</span><br><span class="line">key:偶数 4</span><br><span class="line">key:奇数 5</span><br></pre></td></tr></table></figure>

<h4 id="2-过滤操作符"><a href="#2-过滤操作符" class="headerlink" title="2 过滤操作符"></a>2 过滤操作符</h4><p>从源Observable中选择特定的数据发送出来</p>
<h5 id="2-1-filter"><a href="#2-1-filter" class="headerlink" title="2.1 filter"></a>2.1 filter</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.of(1, 2, 10, 12)</span><br><span class="line">    .filter &#123;$0 &gt; 10&#125;</span><br><span class="line">    .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">&#x2F;&#x2F;结果：12</span><br></pre></td></tr></table></figure>

<h5 id="2-2-distinctUntilChanged"><a href="#2-2-distinctUntilChanged" class="headerlink" title="2.2 distinctUntilChanged"></a>2.2 distinctUntilChanged</h5><p>过滤掉连续重复事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.of(1, 1, 10, 1)</span><br><span class="line">    .distinctUntilChanged()</span><br><span class="line">    .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">结果</span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h5 id="2-3-single"><a href="#2-3-single" class="headerlink" title="2.3 single"></a>2.3 single</h5><p>限制只发送一次事件，或满足条件的第一个事件<br>如果存在多个事件或没有事件会发出一个error<br>如果只有一个事件，则不会发出error事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.of(1, 2, 3)</span><br><span class="line">    .single&#123;$0 &#x3D;&#x3D; 2&#125;</span><br><span class="line">    .subscribe(onNext: &#123;print($0)&#125;) &#x2F;&#x2F;结果 2</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">   </span><br><span class="line">Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class="line">            .single()</span><br><span class="line">            .subscribe(onNext: &#123;print($0)&#125;, onError: &#123; error in</span><br><span class="line">                print(error)</span><br><span class="line">            &#125;)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">结果：</span><br><span class="line">A</span><br><span class="line">Sequence contains more than one element.</span><br></pre></td></tr></table></figure>

<h5 id="2-4-elementAt"><a href="#2-4-elementAt" class="headerlink" title="2.4 elementAt"></a>2.4 elementAt</h5><p>只处理指定位置事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.of(1, 2, 3)</span><br><span class="line">    .elementAt(2)</span><br><span class="line">    .subscribe(onNext: &#123;print($0)&#125;) &#x2F;&#x2F;3</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="2-5-ignoreElements"><a href="#2-5-ignoreElements" class="headerlink" title="2.5 ignoreElements"></a>2.5 ignoreElements</h5><p>可以忽略所有元素，只发出error或complete事件<br>如果并不关心Observable任何元素，只想知道Observable在什么时候终止，可以用ignoreElements</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.of(1, 2, 3)</span><br><span class="line">    .ignoreElements()</span><br><span class="line">    .subscribe&#123;print($0)&#125; &#x2F;&#x2F;completed</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="2-6-take"><a href="#2-6-take" class="headerlink" title="2.6 take"></a>2.6 take</h5><p>实现仅发送Observable序列前n个事件，满足数量后自动.complete</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.of(1, 2, 3)</span><br><span class="line">   .take(2)</span><br><span class="line">   .subscribe&#123;print($0)&#125;</span><br><span class="line">   .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="2-7-takeLast"><a href="#2-7-takeLast" class="headerlink" title="2.7 takeLast"></a>2.7 takeLast</h5><p>仅发送Observable序列中的后n个元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.of(1, 2, 3)</span><br><span class="line">   .takeLast(1)</span><br><span class="line">   .subscribe&#123;print($0)&#125;</span><br><span class="line">   .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="2-8-skip"><a href="#2-8-skip" class="headerlink" title="2.8 skip"></a>2.8 skip</h5><p>跳过源Observable序列发出的前n个事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.of(1, 2, 3)</span><br><span class="line">   .skip(2)</span><br><span class="line">   .subscribe&#123;print($0)&#125;</span><br><span class="line">   .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="2-9-Sample"><a href="#2-9-Sample" class="headerlink" title="2.9 Sample"></a>2.9 Sample</h5><p>除了订阅源Observable外，还能监视另外一个Observable，即notifier<br>每当收到notifier事件，就会从源序列取一个最新事件发送</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let source &#x3D; PublishSubject&lt;Int&gt;()</span><br><span class="line">let notifier &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line"> </span><br><span class="line">source</span><br><span class="line">    .sample(notifier)</span><br><span class="line">    .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"> </span><br><span class="line">source.onNext(1)</span><br><span class="line">&#x2F;&#x2F;让源序列接收接收消息</span><br><span class="line">notifier.onNext(&quot;A&quot;)</span><br><span class="line">source.onNext(2)</span><br><span class="line">&#x2F;&#x2F;让源序列接收接收消息</span><br><span class="line">notifier.onNext(&quot;B&quot;)</span><br><span class="line">notifier.onNext(&quot;C&quot;)</span><br><span class="line">source.onNext(3)</span><br><span class="line">source.onNext(4)</span><br><span class="line">&#x2F;&#x2F;让源序列接收接收消息</span><br><span class="line">notifier.onNext(&quot;D&quot;)</span><br><span class="line">source.onNext(5)</span><br><span class="line">&#x2F;&#x2F;让源序列接收接收消息</span><br><span class="line">notifier.onCompleted()</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<h5 id="2-10-debounce"><a href="#2-10-debounce" class="headerlink" title="2.10 debounce"></a>2.10 debounce</h5><p>可以过滤掉高频产生的元素<br>队列中的元素如果和下一个元素的间隔小于了指定时间间隔，那这元素将被过滤掉<br>常用在输入的时候，不需要每个字母敲进去都发送一个事件，而是稍等下取最后一个事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let times &#x3D; [</span><br><span class="line">    [ &quot;value&quot;: 1, &quot;time&quot;: 100 ], &#x2F;&#x2F;0.1s</span><br><span class="line">    [ &quot;value&quot;: 2, &quot;time&quot;: 110 ],</span><br><span class="line">    [ &quot;value&quot;: 3, &quot;time&quot;: 120 ],</span><br><span class="line">    [ &quot;value&quot;: 4, &quot;time&quot;: 120 ],</span><br><span class="line">    [ &quot;value&quot;: 5, &quot;time&quot;: 140 ],</span><br><span class="line">    [ &quot;value&quot;: 6, &quot;time&quot;: 210 ]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Observable.from(times)</span><br><span class="line">    </span><br><span class="line">    .flatMap &#123; item in</span><br><span class="line">        return Observable.of(Int(item[&quot;value&quot;]!))</span><br><span class="line">            .delay(RxTimeInterval.milliseconds(Int(item[&quot;time&quot;]!)), scheduler: MainScheduler.instance)</span><br><span class="line">    &#125;</span><br><span class="line">    .debounce(RxTimeInterval.milliseconds(500), scheduler: MainScheduler.instance)</span><br><span class="line">    .subscribe(onNext: &#123; print($0) &#125;)&#x2F;&#x2F;只发出与下一个间隔超过0.5s的元素</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h4 id="3-条件与布尔操作符"><a href="#3-条件与布尔操作符" class="headerlink" title="3 条件与布尔操作符"></a>3 条件与布尔操作符</h4><h5 id="3-1-amb"><a href="#3-1-amb" class="headerlink" title="3.1 amb"></a>3.1 amb</h5><p>传入多个Observables到amb操作符，将取第一个发出元素或产生事件的Observable，然后只发出它的元素，忽略其它Observable</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let subject1 &#x3D; PublishSubject&lt;Int&gt;()</span><br><span class="line">let subject2 &#x3D; PublishSubject&lt;Int&gt;()</span><br><span class="line">let subject3 &#x3D; PublishSubject&lt;Int&gt;()</span><br><span class="line"></span><br><span class="line">subject1</span><br><span class="line">.amb(subject2)</span><br><span class="line">.amb(subject3)</span><br><span class="line">.subscribe&#123;print($0)&#125;</span><br><span class="line">.disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject2.onNext(1)&#x2F;&#x2F;最先发</span><br><span class="line">subject1.onNext(20)</span><br><span class="line">subject2.onNext(2)</span><br><span class="line">subject1.onNext(40)</span><br><span class="line">subject3.onNext(0)</span><br><span class="line">subject2.onNext(3)</span><br><span class="line">subject1.onNext(60)</span><br><span class="line">subject3.onNext(0)</span><br><span class="line">subject3.onNext(0)</span><br><span class="line">结果：</span><br><span class="line">next(1)</span><br><span class="line">next(2)</span><br><span class="line">next(3)</span><br></pre></td></tr></table></figure>

<h5 id="3-2-takeWhile"><a href="#3-2-takeWhile" class="headerlink" title="3.2 takeWhile"></a>3.2 takeWhile</h5><p>依次判断Observable序列每个值是否满足条件，第一个不满足值出现，便自动完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.of(1, 2, 3)</span><br><span class="line">    .takeWhile&#123; $0 &lt; 2&#125;</span><br><span class="line">    .subscribe&#123;print($0)&#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="3-3-takeUntil"><a href="#3-3-takeUntil" class="headerlink" title="3.3 takeUntil"></a>3.3 takeUntil</h5><p>可以监听另外一个Observable，即notifier<br>notifier发出值或complete通知，源Observable便自动完成，停止发送事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let source &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">let notifier &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line"> </span><br><span class="line">source</span><br><span class="line">    .takeUntil(notifier)</span><br><span class="line">    .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"> </span><br><span class="line">source.onNext(&quot;a&quot;)</span><br><span class="line">source.onNext(&quot;b&quot;)</span><br><span class="line">source.onNext(&quot;c&quot;)</span><br><span class="line">source.onNext(&quot;d&quot;)</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;停止接收消息</span><br><span class="line">notifier.onNext(&quot;z&quot;)</span><br><span class="line"> </span><br><span class="line">source.onNext(&quot;e&quot;)</span><br><span class="line">source.onNext(&quot;f&quot;)</span><br><span class="line">source.onNext(&quot;g&quot;)</span><br><span class="line">结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure>

<h5 id="3-4-skipWhile"><a href="#3-4-skipWhile" class="headerlink" title="3.4 skipWhile"></a>3.4 skipWhile</h5><p>跳过前面满足条件的事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.of(2, 3, 4, 5, 6)</span><br><span class="line">    .skipWhile &#123; $0 &lt; 4 &#125;</span><br><span class="line">    .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="3-5-skipUntil"><a href="#3-5-skipUntil" class="headerlink" title="3.5 skipUntil"></a>3.5 skipUntil</h5><p>类似takeUntil，还可以监听另外一个Observable<br>和takeUntil相反，默认会一直跳过，直到notifier发出值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let source &#x3D; PublishSubject&lt;Int&gt;()</span><br><span class="line">let notifier &#x3D; PublishSubject&lt;Int&gt;()</span><br><span class="line"> </span><br><span class="line">source</span><br><span class="line">    .skipUntil(notifier)</span><br><span class="line">    .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"> </span><br><span class="line">source.onNext(1)</span><br><span class="line">source.onNext(2)</span><br><span class="line">source.onNext(3)</span><br><span class="line">source.onNext(4)</span><br><span class="line">source.onNext(5)</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;开始接收消息</span><br><span class="line">notifier.onNext(0)</span><br><span class="line">source.onNext(6)</span><br><span class="line">source.onNext(7)</span><br><span class="line">source.onNext(8)</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;仍然接收消息</span><br><span class="line">notifier.onNext(0)</span><br><span class="line">source.onNext(9)</span><br><span class="line">结果：</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<h4 id="4-结合操作符"><a href="#4-结合操作符" class="headerlink" title="4 结合操作符"></a>4 结合操作符</h4><p>将多个Observable序列进行组合，拼装成一个新的Observable</p>
<h5 id="4-1-startWith"><a href="#4-1-startWith" class="headerlink" title="4.1 startWith"></a>4.1 startWith</h5><p>在Observable序列开始前插入一些事件元素，也可以多次startWith</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.of(2, 3)</span><br><span class="line">    .startWith(1)</span><br><span class="line">    .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="4-2-merge"><a href="#4-2-merge" class="headerlink" title="4.2 merge"></a>4.2 merge</h5><p>将多个Observable序列合并成一个Observable序列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let subject1 &#x3D; PublishSubject&lt;Int&gt;()</span><br><span class="line">let subject2 &#x3D; PublishSubject&lt;Int&gt;()</span><br><span class="line"></span><br><span class="line">Observable.of(subject1, subject2)</span><br><span class="line">    .merge()</span><br><span class="line">    .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject1.onNext(20)</span><br><span class="line">subject1.onNext(60)</span><br><span class="line">subject2.onNext(1)</span><br><span class="line">subject1.onNext(80)</span><br><span class="line">subject2.onNext(1)</span><br><span class="line">结果：</span><br><span class="line">20</span><br><span class="line">60</span><br><span class="line">1</span><br><span class="line">80</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h5 id="4-3-zip"><a href="#4-3-zip" class="headerlink" title="4.3 zip"></a>4.3 zip</h5><p>多个Observable序列压缩成一个Observable序列<br>会等每个Observables事件一一对应凑齐后合并</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let subject1 &#x3D; PublishSubject&lt;Int&gt;()</span><br><span class="line">let subject2 &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">Observable.zip(subject1, subject2) &#123;</span><br><span class="line">        &quot;\($0)\($1)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject1.onNext(1)</span><br><span class="line">subject2.onNext(&quot;A&quot;)</span><br><span class="line">subject1.onNext(2)</span><br><span class="line">subject2.onNext(&quot;B&quot;)</span><br><span class="line">subject2.onNext(&quot;C&quot;)</span><br><span class="line">subject2.onNext(&quot;D&quot;)</span><br><span class="line">subject1.onNext(3)</span><br><span class="line">subject1.onNext(4)</span><br><span class="line">subject1.onNext(5)</span><br><span class="line">结果：</span><br><span class="line">1A</span><br><span class="line">2B</span><br><span class="line">3C</span><br><span class="line">4D</span><br></pre></td></tr></table></figure>

<p>常用在整合网络请求上，只有当两请求成功后，再两者结果整合起来继续往下处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;第一个请求</span><br><span class="line">let userRequest: Observable&lt;User&gt; &#x3D; API.getUser(&quot;me&quot;)</span><br><span class="line">&#x2F;&#x2F;第二个请求</span><br><span class="line">let friendsRequest: Observable&lt;Friends&gt; &#x3D; API.getFriends(&quot;me&quot;)</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;将两个请求合并处理</span><br><span class="line">Observable.zip(userRequest, friendsRequest) &#123;</span><br><span class="line">        user, friends in</span><br><span class="line">        &#x2F;&#x2F;将两个信号合并成一个信号，并压缩成一个元组返回（两个信号均成功）</span><br><span class="line">        return (user, friends)</span><br><span class="line">    &#125;</span><br><span class="line">    .observeOn(MainScheduler.instance) &#x2F;&#x2F;加这个是应为请求在后台线程，下面的绑定在前台线程。</span><br><span class="line">    .subscribe(onNext: &#123; (user, friends) in</span><br><span class="line">        &#x2F;&#x2F;将数据绑定到界面上</span><br><span class="line">        &#x2F;&#x2F;.......</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="4-4-combineLatest"><a href="#4-4-combineLatest" class="headerlink" title="4.4 combineLatest"></a>4.4 combineLatest</h5><p>将多个Observable序列元素进行合并<br>和zip不同的是，任意一个Observable有新事件发出，会将每个Observable序列的最新事件元素进行合并</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let subject1 &#x3D; PublishSubject&lt;Int&gt;()</span><br><span class="line">let subject2 &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line"> </span><br><span class="line">Observable.combineLatest(subject1, subject2) &#123;</span><br><span class="line">    &quot;\($0)\($1)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"> </span><br><span class="line">subject1.onNext(1)</span><br><span class="line">subject2.onNext(&quot;A&quot;)</span><br><span class="line">subject1.onNext(2)</span><br><span class="line">subject2.onNext(&quot;B&quot;)</span><br><span class="line">subject2.onNext(&quot;C&quot;)</span><br><span class="line">subject2.onNext(&quot;D&quot;)</span><br><span class="line">subject1.onNext(3)</span><br><span class="line">subject1.onNext(4)</span><br><span class="line">subject1.onNext(5)</span><br><span class="line">结果：</span><br><span class="line">1A</span><br><span class="line">2A</span><br><span class="line">2B</span><br><span class="line">2C</span><br><span class="line">3D</span><br><span class="line">4D</span><br><span class="line">5D</span><br></pre></td></tr></table></figure>

<h5 id="4-5-withLatestFrom"><a href="#4-5-withLatestFrom" class="headerlink" title="4.5 withLatestFrom"></a>4.5 withLatestFrom</h5><p>将两个Observable序列合并为一个，self队列 发射一个元素时，就从第二个序列中取最新的一个值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let subject1 &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">let subject2 &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line"> </span><br><span class="line">subject1.withLatestFrom(subject2)</span><br><span class="line">    .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"> </span><br><span class="line">subject1.onNext(&quot;A&quot;)</span><br><span class="line">subject2.onNext(&quot;1&quot;)</span><br><span class="line">subject1.onNext(&quot;B&quot;)</span><br><span class="line">subject1.onNext(&quot;C&quot;)</span><br><span class="line">subject2.onNext(&quot;2&quot;)</span><br><span class="line">subject1.onNext(&quot;D&quot;)</span><br><span class="line">结果：</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h5 id="4-6-switchLatest"><a href="#4-6-switchLatest" class="headerlink" title="4.6 switchLatest"></a>4.6 switchLatest</h5><p>可以对事件流进行切换<br>如：本来监听Subject1，通过value更换事件源后变成监听Subject2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let subject1 &#x3D; BehaviorSubject(value: &quot;A&quot;)</span><br><span class="line">let subject2 &#x3D; BehaviorSubject(value: &quot;1&quot;)</span><br><span class="line">let replay &#x3D; BehaviorRelay(value: subject1)</span><br><span class="line">replay.asObservable()</span><br><span class="line">    .switchLatest()</span><br><span class="line">    .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">subject1.onNext(&quot;B&quot;)</span><br><span class="line">subject1.onNext(&quot;C&quot;)</span><br><span class="line">&#x2F;&#x2F;改变事件源</span><br><span class="line">&#x2F;&#x2F;切换了源 不打印D 打印1 2</span><br><span class="line">replay.accept(subject2)</span><br><span class="line">subject1.onNext(&quot;D&quot;)</span><br><span class="line">subject2.onNext(&quot;2&quot;)</span><br><span class="line">&#x2F;&#x2F;改变事件源</span><br><span class="line">&#x2F;&#x2F;切换了源 不打印3 打印 D E</span><br><span class="line">replay.accept(subject1)</span><br><span class="line">subject2.onNext(&quot;3&quot;)</span><br><span class="line">subject1.onNext(&quot;E&quot;)</span><br><span class="line">结果：</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">D</span><br><span class="line">E</span><br></pre></td></tr></table></figure>

<h4 id="5-算术、聚合操作符"><a href="#5-算术、聚合操作符" class="headerlink" title="5 算术、聚合操作符"></a>5 算术、聚合操作符</h4><h5 id="5-1-toArray"><a href="#5-1-toArray" class="headerlink" title="5.1 toArray"></a>5.1 toArray</h5><p>将序列转成一个数组，并作为一个单一的事件发送</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.of(1, 2, 3)</span><br><span class="line">    .toArray()</span><br><span class="line">    .subscribe(onSuccess: &#123; print($0) &#125;) &#x2F;&#x2F;[1, 2, 3]</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="5-2-reduce"><a href="#5-2-reduce" class="headerlink" title="5.2 reduce"></a>5.2 reduce</h5><p>接受初始值和一个操作符<br>将给定初始值，和序列中每个值进行累计运算，等到最终结果，并将其作为单个值发送</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.of(1, 2, 3, 4, 5)</span><br><span class="line">    .reduce(0, accumulator: +)</span><br><span class="line">    .subscribe(onNext: &#123; print($0) &#125;) &#x2F;&#x2F;15</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="5-3-concat"><a href="#5-3-concat" class="headerlink" title="5.3 concat"></a>5.3 concat</h5><p>把多个Observable序列合并（串联）为一个Observable序列<br>前一个Observable发出complete事件，才会开始发送下一个Observable序列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subject1 &#x3D; BehaviorSubject(value: 1)</span><br><span class="line">let subject2 &#x3D; BehaviorSubject(value: 2)</span><br><span class="line">let replay &#x3D; BehaviorRelay(value: subject1)</span><br><span class="line">replay.asObservable()</span><br><span class="line">    .concat()</span><br><span class="line">    .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">subject2.onNext(2)</span><br><span class="line">subject1.onNext(1)</span><br><span class="line">subject1.onNext(1)</span><br><span class="line">subject1.onCompleted()</span><br><span class="line">replay.accept(subject2)</span><br><span class="line">subject2.onNext(2)</span><br><span class="line">结果：</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h4 id="6-连接操作符"><a href="#6-连接操作符" class="headerlink" title="6 连接操作符"></a>6 连接操作符</h4><p>有订阅时不会立刻开始发送事件消息，只有当调用connect()之后才会开始发送消息<br>可以让所有订阅者订阅后，才开始发送事件消息，保证所有订阅者能接收到事件消息</p>
<p>对DispatchTime扩展 方便使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension DispatchTime: ExpressibleByIntegerLiteral &#123;</span><br><span class="line">    public init(integerLiteral value: Int) &#123;</span><br><span class="line">        self &#x3D; DispatchTime.now() + .seconds(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension DispatchTime: ExpressibleByFloatLiteral &#123;</span><br><span class="line">    public init(floatLiteral value: Double) &#123;</span><br><span class="line">        self &#x3D; DispatchTime.now() + .milliseconds(Int(value * 1000))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加延迟执行方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func delay(_ delay: Double, clousure: @escaping () -&gt; Void) &#123;</span><br><span class="line">    DispatchQueue.main.asyncAfter(deadline: DispatchTime(floatLiteral: delay)) &#123;</span><br><span class="line">        clousure()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-1-publish"><a href="#6-1-publish" class="headerlink" title="6.1 publish"></a>6.1 publish</h5><p>将正常序列转换成一个可连接序列，序列不会立刻发送事件，只有调用connect后才会开始</p>
<p>普通序列的样例<br>第一个订阅者订阅后每1秒接收一个值，第二个订阅者5秒后才收到第一个值0，所以两个订阅者接收到的值是不同步的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let interval &#x3D; Observable&lt;Int&gt;.interval(DispatchTimeInterval.seconds(1), scheduler: MainScheduler.instance)</span><br><span class="line">_ &#x3D; interval.subscribe(onNext: &#123; print(&quot;订阅1：\($0)&quot;) &#125;)</span><br><span class="line">delay(5) &#123;</span><br><span class="line">    _ &#x3D; interval.subscribe(onNext: &#123; print(&quot;订阅2：\($0)&quot;) &#125;)</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">订阅1：0</span><br><span class="line">订阅1：1</span><br><span class="line">订阅1：2</span><br><span class="line">订阅1：3</span><br><span class="line">订阅1：4</span><br><span class="line">订阅1：5</span><br><span class="line">订阅2：0 &#x2F;&#x2F;不同步</span><br><span class="line">订阅1：6</span><br><span class="line">订阅2：1</span><br></pre></td></tr></table></figure>

<p>使用publish</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let interval &#x3D; Observable&lt;Int&gt;.interval(DispatchTimeInterval.seconds(1), scheduler: MainScheduler.instance).publish()</span><br><span class="line">&#x2F;&#x2F;第一个订阅者（立刻开始订阅）</span><br><span class="line">_ &#x3D; interval.subscribe(onNext: &#123;print($0)&#125;)</span><br><span class="line">&#x2F;&#x2F;相当于把事件推迟2秒</span><br><span class="line">delay(2) &#123;</span><br><span class="line">    _ &#x3D; interval.connect()</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;第2个订阅者 延迟5秒开始订阅</span><br><span class="line">delay(5) &#123;</span><br><span class="line">    _ &#x3D; interval.subscribe(onNext: &#123;print(&quot;订阅2 \($0)&quot;)&#125;)</span><br><span class="line">&#125;</span><br><span class="line">结果：&#x2F;&#x2F;输出同步</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">订阅2 2</span><br><span class="line">3</span><br><span class="line">订阅2 3</span><br><span class="line">4</span><br><span class="line">订阅2 4</span><br><span class="line">5</span><br><span class="line">订阅2 5</span><br></pre></td></tr></table></figure>

<h5 id="6-2-relay"><a href="#6-2-relay" class="headerlink" title="6.2 relay"></a>6.2 relay</h5><p>和publish一样<br>不同在于，新订阅者还能收到订阅之前的事件消息，由bufferSize决定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let interval &#x3D; Observable&lt;Int&gt;.interval(DispatchTimeInterval.seconds(1), scheduler: MainScheduler.instance).replay(3)</span><br><span class="line">_ &#x3D; interval.subscribe(onNext: &#123;print(&quot;订阅1 \($0)&quot;)&#125;)</span><br><span class="line">&#x2F;&#x2F;相当于把事件推迟2秒</span><br><span class="line">delay(2) &#123;</span><br><span class="line">    _ &#x3D; interval.connect()</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;第2个订阅者 延迟5秒开始订阅</span><br><span class="line">delay(5) &#123;</span><br><span class="line">    _ &#x3D; interval.subscribe(onNext: &#123;print(&quot;订阅2 \($0)&quot;)&#125;)</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">订阅1 0</span><br><span class="line">订阅1 1</span><br><span class="line">订阅2 0</span><br><span class="line">订阅2 1</span><br><span class="line">订阅1 2</span><br><span class="line">订阅2 2</span><br><span class="line">订阅1 3</span><br><span class="line">订阅2 3</span><br><span class="line">订阅1 4</span><br><span class="line">订阅2 4</span><br></pre></td></tr></table></figure>

<h5 id="6-3-multicast"><a href="#6-3-multicast" class="headerlink" title="6.3 multicast"></a>6.3 multicast</h5><p>同样是将序列转换成一个可连接序列<br>还可以传入一个subject，每当序列发送事件都会触发这个subject的发送</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let subject &#x3D; PublishSubject&lt;Int&gt;()</span><br><span class="line">_ &#x3D; subject.subscribe(onNext: &#123;print(&quot;subject \($0)&quot;)&#125;)</span><br><span class="line"></span><br><span class="line">let interval &#x3D; Observable&lt;Int&gt;.interval(DispatchTimeInterval.seconds(1), scheduler: MainScheduler.instance).multicast(subject)</span><br><span class="line">_ &#x3D; interval.subscribe(onNext: &#123;print(&quot;订阅1 \($0)&quot;)&#125;)</span><br><span class="line">&#x2F;&#x2F;相当于把事件推迟2秒</span><br><span class="line">delay(2) &#123;</span><br><span class="line">    _ &#x3D; interval.connect()</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;第2个订阅者 延迟5秒开始订阅</span><br><span class="line">delay(5) &#123;</span><br><span class="line">    _ &#x3D; interval.subscribe(onNext: &#123;print(&quot;订阅2 \($0)&quot;)&#125;)</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">subject 0</span><br><span class="line">订阅1 0</span><br><span class="line">subject 1</span><br><span class="line">订阅1 1</span><br><span class="line">subject 2</span><br><span class="line">订阅1 2</span><br><span class="line">订阅2 2</span><br><span class="line">subject 3</span><br><span class="line">订阅1 3</span><br><span class="line">订阅2 3</span><br><span class="line">subject 4</span><br><span class="line">订阅1 4</span><br><span class="line">订阅2 4</span><br></pre></td></tr></table></figure>

<h5 id="6-4-refCount"><a href="#6-4-refCount" class="headerlink" title="6.4 refCount"></a>6.4 refCount</h5><p>可以将可被连接的observable转换为普通observable<br>可自动连接和断开可连接的observable，第一个观察者对可连接的observable订阅时，底层的observable将被自动连接，最后一个观察者离开时，底层的observable将自动断开连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let interval &#x3D; Observable&lt;Int&gt;.interval(DispatchTimeInterval.seconds(1), scheduler: MainScheduler.instance).publish().refCount()</span><br></pre></td></tr></table></figure>

<h5 id="6-5-share-relay"><a href="#6-5-share-relay" class="headerlink" title="6.5 share(relay:)"></a>6.5 share(relay:)</h5><p>使观察者共享源observable，并且缓存最新的n个元素，将这些元素直接发送给新的观察者<br>是replay和refCount组合</p>
<h4 id="7-其它操作符"><a href="#7-其它操作符" class="headerlink" title="7 其它操作符"></a>7 其它操作符</h4><h5 id="7-1-delay"><a href="#7-1-delay" class="headerlink" title="7.1 delay"></a>7.1 delay</h5><p>将observable所有元素拖延一段时间后发送出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.of(1, 2, 3)</span><br><span class="line">    .delay(DispatchTimeInterval.seconds(3), scheduler: MainScheduler.instance)</span><br><span class="line">.subscribe(onNext: &#123;print($0)&#125;)</span><br><span class="line">.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="10-2-delaySubscription"><a href="#10-2-delaySubscription" class="headerlink" title="10.2 delaySubscription"></a>10.2 delaySubscription</h5><p>进行延时订阅，经过设定时间后，才对observable订阅</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.of(1, 2, 3)</span><br><span class="line">    .delaySubscription(DispatchTimeInterval.seconds(3), scheduler: MainScheduler.instance)</span><br><span class="line">.subscribe(onNext: &#123;print($0)&#125;)</span><br><span class="line">.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="7-3-materialize"><a href="#7-3-materialize" class="headerlink" title="7.3 materialize"></a>7.3 materialize</h5><p>可将序列产生的事件，转换成元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.of(1, 2, 3)</span><br><span class="line">  .materialize()</span><br><span class="line">  .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class="line">  .disposed(by: disposeBag)</span><br><span class="line">结果：</span><br><span class="line">next(1)</span><br><span class="line">next(2)</span><br><span class="line">next(3)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure>

<h5 id="7-4-dematerialize"><a href="#7-4-dematerialize" class="headerlink" title="7.4 dematerialize"></a>7.4 dematerialize</h5><p>和materialize相反，将materialize转换后的元素还原</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.of(1, 2, 3)</span><br><span class="line">  .materialize()</span><br><span class="line">  .dematerialize()</span><br><span class="line">  .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class="line">  .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h5 id="7-5-timeout"><a href="#7-5-timeout" class="headerlink" title="7.5 timeout"></a>7.5 timeout</h5><p>设置超时时间，源observable规定时间内没发出元素，就产生一个超时的error</p>
<h5 id="7-6-using"><a href="#7-6-using" class="headerlink" title="7.6 using"></a>7.6 using</h5><p>使用using创建observable时，同时会创建一个可被清除的资源，一旦observable终止，那这资源就被清除了</p>
<p><a href="https://www.hangge.com/blog/cache/detail_1922.html">RxSwift hangge.com</a></p>
]]></content>
  </entry>
  <entry>
    <title>dyld加载流程</title>
    <url>/2020/12/07/dyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><ul>
<li>库：编译好的二进制文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">源文件 -&gt; 预编译 -&gt; 编译 -&gt; 汇编 -&gt; 链接 -&gt; 可执行文件</span><br></pre></td></tr></table></figure>

<p><code>源文件</code>：.h、 .m、 .cpp 等文件</p>
<p><code>预编译</code>：替换宏、删除注释，产生 <code>.i</code> 文件</p>
<p><code>编译</code>：编译高级语言代码成汇编底层代码，生成汇编代码文件 <code>.s</code></p>
<p><code>汇编</code>：将汇编代码转变成机器可执行的指令 <code>.o</code></p>
<p><code>链接</code>：将引用的静态库与汇编生成的目标文件 <code>.o</code> 一起打包生成可执行文件</p>
<h4 id="动态库、静态库"><a href="#动态库、静态库" class="headerlink" title="动态库、静态库"></a>动态库、静态库</h4><ul>
<li>静态库 .a、 .lib</li>
</ul>
<p>在链接阶段，将汇编生成的目标文件.o与引用的库，一起链接打包到可执行文件</p>
<p>缺点：静态库会有两份，导致目标程序体积增大（编译时会直接拷贝一份，复制到目标程序里）</p>
<p>优点：编译完后，库文件就没有用了，目标程序没有外部依赖，可以直接运行</p>
<ul>
<li>动态库 .so</li>
</ul>
<p>编译时并不会链接到目标程序，只会存储指向动态库的引用，程序运行时才被载入</p>
<p>优点：多次使用共享内存，减少打包APP的体积</p>
<h4 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a>dyld</h4><p><code>dyld</code> ：动态库链接器，负责加载程序和程序依赖的动态库，内核读取 <code>Mach-O</code> 文件后，将读取内容交给 <code>dyld</code> 加载，<code>dyld</code> 加载完毕后才会执行 <code>main</code> 函数</p>
<p><code>dyld</code> 在系统中以一个用户态的可执行文件形式存在，一般应用程序会在 <code>Mach-O</code> 文件部分指定一个 <code>LC_LOAD_DYLINKER</code> 的加载命令，此加载命令指定了 <code>dyld</code> 的路径，通常默认值是 <code>/usr/lib/dyld</code></p>
<p>新建项目，在 <code>main</code> 函数中打断点，通过 <code>bt</code> 查看调用栈，看到 <code>App</code> 启动后会执行 <code>libdyld.dylib</code> 的 <code>start</code> 操作，这边调用栈的信息比较少</p>
<p><img src="/2020/12/07/dyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/%E5%90%AF%E5%8A%A8main%E6%96%AD%E7%82%B9.jpg" alt="启动main断点"></p>
<p>继续在  <code>ViewController</code> 中重写 <code>load</code> 方法 ，<code>load</code> 方法打断点，通过 <code>bt</code> 查看调用栈，发现一个 <code>_dyld_start</code> 的调用</p>
<p><img src="/2020/12/07/dyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/%E5%90%AF%E5%8A%A8load%E6%96%AD%E7%82%B9.jpg" alt="启动load断点"></p>
<p><code>dyld</code> 源码中搜索 <code>_dyld_start</code> ，可以在 <code>dyldStartup.s</code> 文件中找到 <code>_dyld_start</code> 的汇编实现，文件中按照 <code>i386</code>、<code>x86_64</code>、<code>arm64</code>、<code>arm</code> 不同架构做了逻辑处理</p>
<p>查看 <code>arm64</code> 架构下汇编源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line">	.text</span><br><span class="line">	.align <span class="number">2</span></span><br><span class="line">	.globl __dyld_start</span><br><span class="line">__dyld_start:</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// call dyldbootstrap::start(app_mh, argc, argv, dyld_mh, &amp;startGlue)</span></span><br><span class="line">	bl	__ZN13dyldbootstrap5startEPKN5dyld311MachOLoadedEiPPKcS3_Pm</span><br><span class="line">	...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __arm64__</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>找到关键部分代码，看到 <code>bl</code> 跳转指令，看注释信息，这边会调用 <code>dyldbootstrap::start</code> </p>
<h4 id="dyldbootstrap-start"><a href="#dyldbootstrap-start" class="headerlink" title="dyldbootstrap::start"></a>dyldbootstrap::start</h4><p>【1】<code>dyldbootstrap::start</code></p>
<p>源码中搜索 <code>dyldbootstrap</code> 命名空间的 <code>start</code> 方法，这是 <code>dyld</code> 的启动函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uintptr_t</span> <span class="title">start</span><span class="params">(<span class="keyword">const</span> dyld3::MachOLoaded* appsMachHeader, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">const</span> dyld3::MachOLoaded* dyldsMachHeader, <span class="keyword">uintptr_t</span>* startGlue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Emit kdebug tracepoint to indicate dyld bootstrap has started &lt;rdar://46878536&gt;</span></span><br><span class="line">    dyld3::kdebug_trace_dyld_marker(DBG_DYLD_TIMING_BOOTSTRAP_START, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if kernel had to slide dyld, we need to fix up load sensitive locations</span></span><br><span class="line">	<span class="comment">// we have to do this before using any global variables</span></span><br><span class="line">    rebaseDyld(dyldsMachHeader);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// set up random value for stack canary</span></span><br><span class="line">	__guard_setup(apple);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// now that we are done bootstrapping dyld, call dyld&#x27;s main</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> appsSlide = appsMachHeader-&gt;getSlide();</span><br><span class="line">	<span class="keyword">return</span> dyld::_main((macho_header*)appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dyldbootstrap::start</code> 主要操作：</p>
<ol>
<li><p>调用 <code>rebaseDyld()</code> dyld 重定位</p>
</li>
<li><p><code>__guard_setup</code> 栈溢出保护</p>
</li>
<li><p><code>dyld::_main</code> 进入 <code>dyld</code> 的 <code>_main</code> 函数</p>
</li>
</ol>
<h4 id="dyld-main"><a href="#dyld-main" class="headerlink" title="dyld::_main"></a>dyld::_main</h4><p>【2】<code>dyld::_main</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Entry point for dyld.  The kernel loads dyld and jumps to __dyld_start which</span></span><br><span class="line"><span class="comment">// sets up some registers and call this function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns address of main() in target program which __dyld_start jumps to</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">		<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">		<span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="comment">//【1】初始化程序运行环境</span></span><br><span class="line">    <span class="comment">// Grab the cdHash of the main executable from the environment</span></span><br><span class="line">	<span class="keyword">uint8_t</span> mainExecutableCDHashBuffer[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">uint8_t</span>* mainExecutableCDHash = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> ( hexToBytes(_simple_getenv(apple, <span class="string">&quot;executable_cdhash&quot;</span>), <span class="number">40</span>, mainExecutableCDHashBuffer) )</span><br><span class="line">		mainExecutableCDHash = mainExecutableCDHashBuffer;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uintptr_t</span> result = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//获取主程序的macho_header结构以及主程序的slide偏移值</span></span><br><span class="line">  <span class="comment">//保存执行文件头部，后续可以根据头部访问其他信息</span></span><br><span class="line">	sMainExecutableMachHeader = mainExecutableMH;</span><br><span class="line">	sMainExecutableSlide = mainExecutableSlide;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	CRSetCrashLogMessage(<span class="string">&quot;dyld: launch started&quot;</span>);</span><br><span class="line">	<span class="comment">//设置上下文信息</span></span><br><span class="line">	setContext(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pickup the pointer to the exec path.</span></span><br><span class="line">	<span class="comment">//获取可执行文件路径</span></span><br><span class="line">	sExecPath = _simple_getenv(apple, <span class="string">&quot;executable_path&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// &lt;rdar://problem/13868260&gt; Remove interim apple[0] transition code from dyld</span></span><br><span class="line">	<span class="keyword">if</span> (!sExecPath) sExecPath = apple[<span class="number">0</span>];</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取进程名称</span></span><br><span class="line">	<span class="comment">// Remember short name of process for later logging</span></span><br><span class="line">	sExecShortName = ::<span class="built_in">strrchr</span>(sExecPath, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span> ( sExecShortName != <span class="literal">NULL</span> )</span><br><span class="line">		++sExecShortName;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		sExecShortName = sExecPath;</span><br><span class="line">	</span><br><span class="line">	  <span class="comment">//配置进程受限模式</span></span><br><span class="line">    configureProcessRestrictions(mainExecutableMH, envp);</span><br><span class="line">	...</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//检查环境变量配置</span></span><br><span class="line">		checkEnvironmentVariables(envp);</span><br><span class="line">    <span class="comment">//如果 DYLD_FALLBACK 为nil，将其设置为默认值</span></span><br><span class="line">		defaultUninitializedFallbackPaths(envp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果设置了 DYLD_PRINT_OPTS 环境变量，则打印参数</span></span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_OPTS )</span><br><span class="line">		printOptions(argv);</span><br><span class="line">  <span class="comment">//如果设置了 DYLD_PRINT_ENV 环境变量，则打印环境变量</span></span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_ENV ) </span><br><span class="line">		printEnvironmentVariables(envp);</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读取Mach-O文件的header，获取当前程序架构信息</span></span><br><span class="line">	getHostInfo(mainExecutableMH, mainExecutableSlide);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// load shared cache</span></span><br><span class="line">	<span class="comment">//【2】加载共享缓存 shared cache</span></span><br><span class="line">  <span class="comment">//检查共享缓存是否开启 iOS中必须开启</span></span><br><span class="line">	checkSharedRegionDisable((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide);</span><br><span class="line">	<span class="keyword">if</span> ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion ) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_SIMULATOR</span></span><br><span class="line">		<span class="keyword">if</span> ( sSharedCacheOverrideDir)</span><br><span class="line">      <span class="comment">//将共享缓存映射到共享区域</span></span><br><span class="line">			mapSharedCache();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		mapSharedCache();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// add dyld itself to UUID list</span></span><br><span class="line">		addDyldImageToUUIDList();</span><br><span class="line">		...</span><br><span class="line">		CRSetCrashLogMessage(sLoadingCrashMessage);</span><br><span class="line">		<span class="comment">// instantiate ImageLoader for main executable</span></span><br><span class="line">		<span class="comment">//【3】实例化主程序，并赋值给ImageLoader::LinkContext</span></span><br><span class="line">    <span class="comment">//加载可执行文件并生成一个ImageLoader实例对象</span></span><br><span class="line">		sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br><span class="line">		gLinkContext.mainExecutable = sMainExecutable;</span><br><span class="line">		gLinkContext.mainExecutableCodeSigned = hasCodeSignatureLoadCommand(mainExecutableMH);</span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">		<span class="comment">// load any inserted libraries</span></span><br><span class="line">		<span class="comment">//【4】加载插入的动态库（加载所有 DYLD_INSERT_LIBRARIES 指定的库）</span></span><br><span class="line">		<span class="keyword">if</span>	( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">      <span class="comment">//遍历 DYLD_INSERT_LIBRARIES 环境变量</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line">				loadInsertedDylib(*lib);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// record count of inserted libraries so that a flat search will look at </span></span><br><span class="line">		<span class="comment">// inserted libraries, then main, then others.</span></span><br><span class="line">		sInsertedDylibCount = sAllImages.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// link main executable</span></span><br><span class="line">		<span class="comment">//【5】链接主程序</span></span><br><span class="line">		gLinkContext.linkingMainExecutable = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ACCELERATE_TABLES</span></span><br><span class="line">		<span class="keyword">if</span> ( mainExcutableAlreadyRebased ) &#123;</span><br><span class="line">			<span class="comment">// previous link() on main executable has already adjusted its internal pointers for ASLR</span></span><br><span class="line">			<span class="comment">// work around that by rebasing by inverse amount</span></span><br><span class="line">			sMainExecutable-&gt;rebase(gLinkContext, -mainExecutableSlide);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::RPathChain(<span class="literal">NULL</span>, <span class="literal">NULL</span>), <span class="number">-1</span>);</span><br><span class="line">		sMainExecutable-&gt;setNeverUnloadRecursive();</span><br><span class="line">		<span class="keyword">if</span> ( sMainExecutable-&gt;forceFlat() ) &#123;</span><br><span class="line">			gLinkContext.bindFlat = <span class="literal">true</span>;</span><br><span class="line">			gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//【6】链接插入的动态库</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// link any inserted libraries</span></span><br><span class="line">		<span class="comment">// do this after linking main executable so that any dylibs pulled in by inserted </span></span><br><span class="line">		<span class="comment">// dylibs (e.g. libSystem) will not be in front of dylibs the program uses</span></span><br><span class="line">		<span class="keyword">if</span> ( sInsertedDylibCount &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">				ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">				link(image, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::RPathChain(<span class="literal">NULL</span>, <span class="literal">NULL</span>), <span class="number">-1</span>);</span><br><span class="line">				image-&gt;setNeverUnloadRecursive();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ( gLinkContext.allowInterposing ) &#123;</span><br><span class="line">				<span class="comment">// only INSERTED libraries can interpose</span></span><br><span class="line">				<span class="comment">// register interposing info after all inserted libraries are bound so chaining works</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">					ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">					image-&gt;registerInterposing(gLinkContext);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//【7】链接所有插入的image后，执行弱符号绑定</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// &lt;rdar://problem/12186933&gt; do weak binding only after all inserted images linked</span></span><br><span class="line">		sMainExecutable-&gt;weakBind(gLinkContext);</span><br><span class="line">		gLinkContext.linkingMainExecutable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		sMainExecutable-&gt;recursiveMakeDataReadOnly(gLinkContext);</span><br><span class="line"></span><br><span class="line">		CRSetCrashLogMessage(<span class="string">&quot;dyld: launch, running initializers&quot;</span>);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> SUPPORT_OLD_CRT_INITIALIZATION</span></span><br><span class="line">		<span class="comment">// Old way is to run initializers via a callback from crt1.o</span></span><br><span class="line">		<span class="keyword">if</span> ( ! gRunInitializersOldWay ) </span><br><span class="line">			initializeMainExecutable(); </span><br><span class="line">	<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		<span class="comment">//【8】执行所有初始化方法</span></span><br><span class="line">		<span class="comment">// run all initializers</span></span><br><span class="line">		initializeMainExecutable(); </span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		...</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//【9】查找主程序的入口并返回</span></span><br><span class="line">			<span class="comment">// find entry point for main executable</span></span><br><span class="line">			result = (<span class="keyword">uintptr_t</span>)sMainExecutable-&gt;getEntryFromLC_MAIN();</span><br><span class="line">			<span class="keyword">if</span> ( result != <span class="number">0</span> ) &#123;</span><br><span class="line">				<span class="comment">// main executable uses LC_MAIN, we need to use helper in libdyld to call into main()</span></span><br><span class="line">				<span class="keyword">if</span> ( (gLibSystemHelpers != <span class="literal">NULL</span>) &amp;&amp; (gLibSystemHelpers-&gt;version &gt;= <span class="number">9</span>) )</span><br><span class="line">					*startGlue = (<span class="keyword">uintptr_t</span>)gLibSystemHelpers-&gt;startGlueToCallExit;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					halt(<span class="string">&quot;libdyld.dylib support not present for LC_MAIN&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// main executable uses LC_UNIXTHREAD, dyld needs to let &quot;start&quot; in program set up for main()</span></span><br><span class="line">				result = (<span class="keyword">uintptr_t</span>)sMainExecutable-&gt;getEntryFromLC_UNIXTHREAD();</span><br><span class="line">				*startGlue = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="dyld-加载流程"><a href="#dyld-加载流程" class="headerlink" title="dyld 加载流程"></a><code>dyld</code> 加载流程</h4><p><code>dyld</code> 的加载流程主要包括以下 9 个步骤：</p>
<ol>
<li>主程序运行环境初始化，获取当前运行架构</li>
<li>加载共享缓存，检查共享缓存是否映射到共享区域</li>
<li>加载可执行文件，生成一个 <code>ImageLoader</code> 实例对象</li>
<li>加载插入的动态库</li>
<li>链接主程序</li>
<li>链接动态库</li>
<li>弱符号绑定</li>
<li>执行初始化方法</li>
<li>寻找程序入口 <code>LC_MAIN</code></li>
</ol>
<ul>
<li>分析第 8 步</li>
</ul>
<h4 id="initializeMainExecutable-执行初始化方法"><a href="#initializeMainExecutable-执行初始化方法" class="headerlink" title="initializeMainExecutable 执行初始化方法"></a>initializeMainExecutable 执行初始化方法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initializeMainExecutable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//循环遍历，对插入的 dylib 调用 runInitializers 方法进行初始化</span></span><br><span class="line">	<span class="comment">// run initialzers for any inserted dylibs</span></span><br><span class="line">	ImageLoader::InitializerTimingList initializerTimes[allImagesCount()];</span><br><span class="line">	initializerTimes[<span class="number">0</span>].count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">size_t</span> rootCount = sImageRoots.size();</span><br><span class="line">	<span class="keyword">if</span> ( rootCount &gt; <span class="number">1</span> ) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">1</span>; i &lt; rootCount; ++i) &#123;</span><br><span class="line">			sImageRoots[i]-&gt;runInitializers(gLinkContext, initializerTimes[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//主程序调用 runInitializers 方法初始化</span></span><br><span class="line">	<span class="comment">// run initializers for main executable and everything it brings up </span></span><br><span class="line">	sMainExecutable-&gt;runInitializers(gLinkContext, initializerTimes[<span class="number">0</span>]);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>runInitializers</code>  内部调用了 <code>processInitializers</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoader::runInitializers</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context, InitializerTimingList&amp; timingInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	processInitializers(context, thisThread, timingInfo, up);</span><br><span class="line">	context.notifyBatch(dyld_image_state_initialized, <span class="literal">false</span>);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>processInitializers</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoader::processInitializers</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">mach_port_t</span> thisThread, InitializerTimingList&amp; timingInfo, ImageLoader::UninitedUpwards&amp; images)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// Calling recursive init on all images in images list, building a new list of</span></span><br><span class="line">	<span class="comment">// uninitialized upward dependencies.</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">uintptr_t</span> i=<span class="number">0</span>; i &lt; images.count; ++i) &#123;</span><br><span class="line">		images.imagesAndPaths[i].first-&gt;recursiveInitialization(context, thisThread, images.imagesAndPaths[i].second, timingInfo, ups);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对镜像列表调用 <code>recursiveInitialization</code> 递归初始化</p>
<p><code>recursiveInitialization</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoader::recursiveInitialization</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">mach_port_t</span> this_thread, <span class="keyword">const</span> <span class="keyword">char</span>* pathToInitialize, InitializerTimingList&amp; timingInfo, UninitedUpwards&amp; uninitUps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">recursive_lock <span class="title">lock_info</span><span class="params">(this_thread)</span></span>;</span><br><span class="line">	recursiveSpinLock(lock_info); <span class="comment">//递归枷锁</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( fState &lt; dyld_image_state_dependents_initialized<span class="number">-1</span> ) &#123;</span><br><span class="line">		<span class="keyword">uint8_t</span> oldState = fState;</span><br><span class="line">		<span class="comment">// break cycles</span></span><br><span class="line">		fState = dyld_image_state_dependents_initialized<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// initialize lower level libraries first</span></span><br><span class="line">			...</span><br><span class="line"></span><br><span class="line">			<span class="comment">// let objc know we are about to initialize this image 让objc知道将要初始化镜像</span></span><br><span class="line">			<span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">			fState = dyld_image_state_dependents_initialized;</span><br><span class="line">			oldState = fState;</span><br><span class="line">			context.notifySingle(dyld_image_state_dependents_initialized, <span class="keyword">this</span>, &amp;timingInfo);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// initialize this image 初始化镜像</span></span><br><span class="line">			<span class="keyword">bool</span> hasInitializers = <span class="keyword">this</span>-&gt;doInitialization(context);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// let anyone know we finished initializing this image 镜像初始化完成</span></span><br><span class="line">			fState = dyld_image_state_initialized;</span><br><span class="line">			oldState = fState;</span><br><span class="line">			context.notifySingle(dyld_image_state_initialized, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	recursiveSpinUnLock();<span class="comment">//递归解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>initializeMainExecutable</code> -&gt; <code>runInitializers</code> -&gt; <code>processInitializers</code> -&gt; <code>recursiveInitialization</code> -&gt; <code>notifySingle</code></p>
<h5 id="doInitialization"><a href="#doInitialization" class="headerlink" title="doInitialization"></a>doInitialization</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ImageLoaderMachO::doInitialization</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CRSetCrashLogMessage2(<span class="keyword">this</span>-&gt;getPath());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// mach-o has -init and static initializers</span></span><br><span class="line">	doImageInit(context);</span><br><span class="line">	doModInitFunctions(context);<span class="comment">//加载c++构造函数</span></span><br><span class="line">	</span><br><span class="line">	CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (fHasDashInit || fHasInitializers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c++构造方法，在 <code>mach-O</code>的 <code>data段</code> 中对应 <code>__mod_init_func</code></p>
<h5 id="notifySingle"><a href="#notifySingle" class="headerlink" title="notifySingle"></a>notifySingle</h5><p>继续在 <code>dyld2.cpp</code> 中找到 <code>notifySingle</code> 实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notifySingle</span><span class="params">(dyld_image_states state, <span class="keyword">const</span> ImageLoader* image, ImageLoader::InitializerTimingList* timingInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> ( (state == dyld_image_state_dependents_initialized) &amp;&amp; (sNotifyObjCInit != <span class="literal">NULL</span>) &amp;&amp; image-&gt;notifyObjC() ) &#123;</span><br><span class="line">		<span class="keyword">uint64_t</span> t0 = mach_absolute_time();</span><br><span class="line">		<span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_OBJC_INIT, (<span class="keyword">uint64_t</span>)image-&gt;machHeader(), <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">		(*sNotifyObjCInit)(image-&gt;getRealPath(), image-&gt;machHeader());</span><br><span class="line">		<span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">		<span class="keyword">uint64_t</span> t2 = mach_absolute_time();</span><br><span class="line">		<span class="keyword">uint64_t</span> timeInObjC = t1-t0;</span><br><span class="line">		<span class="keyword">uint64_t</span> emptyTime = (t2-t1)*<span class="number">100</span>;</span><br><span class="line">		<span class="keyword">if</span> ( (timeInObjC &gt; emptyTime) &amp;&amp; (timingInfo != <span class="literal">NULL</span>) ) &#123;</span><br><span class="line">			timingInfo-&gt;addTime(image-&gt;getShortName(), timeInObjC);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键函数指针 <code>sNotifyObjCInit</code> ，当前文件搜索 <code>sNotifyObjCInit</code> 找到赋值的地方</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerObjCNotifiers</span><span class="params">(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// record functions to call</span></span><br><span class="line">	sNotifyObjCMapped	= mapped;</span><br><span class="line">	sNotifyObjCInit		= init;</span><br><span class="line">	sNotifyObjCUnmapped = unmapped;</span><br></pre></td></tr></table></figure>

<p>再全局搜索 <code>registerObjCNotifiers</code> 查找到调用的地方</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,</span><br><span class="line">                                _dyld_objc_notify_init      init,</span><br><span class="line">                                _dyld_objc_notify_unmapped  unmapped)</span><br><span class="line">&#123;</span><br><span class="line">	dyld::registerObjCNotifiers(mapped, init, unmapped);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么时候调用了 <code>_dyld_objc_notify_register</code> ?</p>
<p>通过添加 <code>_dyld_objc_notify_register</code> 符号断点，运行后发现调用者是 <code>_objc_init</code>， <code>_objc_init</code> 函数是 <code>Runtime</code> 的入口函数</p>
<p><img src="/2020/12/07/dyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/notifi_register.jpg" alt="notifi_register"></p>
<h4 id="objc-init"><a href="#objc-init" class="headerlink" title="_objc_init"></a>_objc_init</h4><p><code>_objc_init</code> 需要在 <code>libobjc</code> 源码中查看</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Called by libSystem BEFORE library initialization time</span></span><br><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    runtime_init();</span><br><span class="line">    exception_init();</span><br><span class="line">    cache_init();</span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line">    <span class="comment">//注册回调函数</span></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    didCallDyldNotifyRegister = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看函数注释意思，<code>_objc_init</code> 的调用时机是在其他动态库初始化之前，由 <code>libSystem</code> 系统库调用</p>
<p>所以 <code>dyld</code> 加载的第 8 步，在初始化所有动态库和主程序之前，就注册了 <code>load_images</code> 的回调，Runtime调用 <code>load_images</code> 加载完所有 <code>load</code> 方法之后，就回调到 <code>dyld::_main</code> 的 <code>initializeMainExecutable()</code> </p>
<p><img src="/2020/12/07/dyld%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/dyld.png" alt="dyld"></p>
<h4 id="共享缓存"><a href="#共享缓存" class="headerlink" title="共享缓存"></a>共享缓存</h4><p><code>dyld</code> 加载时，为了优化程序启动，启用了共享缓存技术。共享缓存会在进程启动时被 <code>dyld</code> 映射到内存中，之后，当任何 <code>Mach-O</code> 镜像加载时，<code>dyld</code> 首先会检查该 <code>Mach-O</code> 镜像与所需的动态库是否在共享缓存中，如果存在，则直接将它在共享内存中的内存地址映射到进程的内存地址空间。在程序依赖的系统动态库很多的情况下，这种做法对程序启动性能是有明显提升的。</p>
<p><a href="https://opensource.apple.com/tarballs/dyld/">dyld750.6下载</a></p>
<p><a href="https://www.jianshu.com/p/e383013ca846">dyld 流程分析</a></p>
<p><a href="https://www.jianshu.com/p/db765ff4e36a">dyld加载流程</a></p>
]]></content>
  </entry>
  <entry>
    <title>《Flutter实战第二版》七：功能型组件</title>
    <url>/2022/01/18/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E4%B8%83%EF%BC%9A%E5%8A%9F%E8%83%BD%E5%9E%8B%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="7-功能型组件"><a href="#7-功能型组件" class="headerlink" title="7 功能型组件"></a>7 功能型组件</h3><p>功能型组件指的是不影响UI布局及外观的组件，通常具有一定的功能，如事件监听、数据存储等</p>
<p>FocusScope（焦点控制住）、PageStorage（数据存储）、NotificationListener（事件监听）都属于功能型组件</p>
<h4 id="7-1-导航返回拦截-WillPopScope"><a href="#7-1-导航返回拦截-WillPopScope" class="headerlink" title="7.1 导航返回拦截 WillPopScope"></a>7.1 导航返回拦截 WillPopScope</h4><p>Flutter 可以通过 willPopScope 来实现返回按钮拦截</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> WillPopScope(&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">required</span> WillPopCallback onWillPop,</span><br><span class="line">  <span class="keyword">required</span> Widget child</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>onWillPop 当用户点击返回按钮时被调用，该回调需要返回一个 Future 对象</p>
<ul>
<li>示例</li>
</ul>
<p>为防止用户误触返回键退出，拦截返回事件。用户 1 秒内点击两次返回按钮时，则退出；如果间隔超过 1 秒则不退出，并重新计时</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WillPopScopeTestRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">WillPopScopeTestRoute</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">DateTime?</span> _lastPressedAt; <span class="comment">//上次点击时间</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> WillPopScope(</span><br><span class="line">      onWillPop: () <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_lastPressedAt == <span class="keyword">null</span> ||</span><br><span class="line">            <span class="built_in">DateTime</span>.now().difference(_lastPressedAt!) &gt; <span class="built_in">Duration</span>(seconds: <span class="number">1</span>)) &#123;</span><br><span class="line">          <span class="comment">//两次点击间隔超过1秒则重新计时</span></span><br><span class="line">          _lastPressedAt = <span class="built_in">DateTime</span>.now();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">      child: Container(</span><br><span class="line">        alignment: Alignment.center,</span><br><span class="line">        child: Text(<span class="string">&quot;1秒内连续按两次返回键退出&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-2-数据共享-InheritedWidget"><a href="#7-2-数据共享-InheritedWidget" class="headerlink" title="7.2 数据共享 InheritedWidget"></a>7.2 数据共享 InheritedWidget</h4><p>InheritedWidget 提供了一种在 widget 树中从上到下共享数据的方式。比如在根 widget 中通过 InheritedWidget 共享了一个数据，那么我们可以在任意子 widget 中获取共享的数据</p>
<p>Flutter SDK 中通过 InheritedWidget 来共享主题和 Locale 信息</p>
<h5 id="didChangeDependencies"><a href="#didChangeDependencies" class="headerlink" title="didChangeDependencies"></a>didChangeDependencies</h5><p>State 对象有个 didChangeDependencies 回调，它会在依赖发生变化时被 Flutter 框架调用，</p>
<p>这个依赖指的是，子 widget 是否使用了父 widget 中 InheritedWidget 的数据，</p>
<p>这种机制可以使子组件在依赖的 InheritedWidget 变化时更新自身，如主题、语言等变化时，依赖他们的子 widget 的 didChangeDependencies 会被调用</p>
<ul>
<li>示例</li>
</ul>
<p>首先通过继承 InheritedWidget，将计数器点击次数保存在 ShareDataWidget 的 data 属性中</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareDataWidget</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">  ShareDataWidget(&#123;</span><br><span class="line">    Key? key,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.data, <span class="comment">//需要在子树中共享的数据，保存点击次数</span></span><br><span class="line">    <span class="keyword">required</span> Widget child,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> data;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义一个便捷方法，方便子树中的widget获取共享数据</span></span><br><span class="line">  <span class="keyword">static</span> ShareDataWidget? of(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> context.dependOnInheritedWidgetOfExactType&lt;ShareDataWidget&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//该回调决定当data发生变化时，是否通知子树中依赖data的Widget</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(<span class="keyword">covariant</span> ShareDataWidget oldWidget) &#123;</span><br><span class="line">    <span class="keyword">return</span> oldWidget.data != data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后实现一个子组件 _TestWidget，在 build 方法中引用了 ShareDataWidget 中的数据，同时在 didChangeDependencies 回调中打印日志 </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TestWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _TestWidget(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _TestWidgetState createState() =&gt; _TestWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TestWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">_TestWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">//使用InheritedWidget中的共享数据</span></span><br><span class="line">    <span class="keyword">return</span> Text(ShareDataWidget.of(context)!.data.toString());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123;</span><br><span class="line">    <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line">    <span class="comment">//父或祖先widget中的InheritedWidget改变(updateShouldNotify返回true)时会被调用。</span></span><br><span class="line">    <span class="comment">//如果build中没有依赖InheritedWidget，则此回调不会被调用。</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Dependencies change&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后创建按钮，每点击一次就 ShareDataWidget 的值自增</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InheritedWidgetTestRoute</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _InheritedWidgetTestRouteState createState() =&gt; _InheritedWidgetTestRouteState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_InheritedWidgetTestRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">InheritedWidgetTestRoute</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">&#x27;标题&#x27;</span>)),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: ShareDataWidget(<span class="comment">//使用ShareDataWidget</span></span><br><span class="line">          data: count,</span><br><span class="line">          child: Column(</span><br><span class="line">            mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">            children: [</span><br><span class="line">              Padding(</span><br><span class="line">                padding: EdgeInsets.only(bottom: <span class="number">20.0</span>),</span><br><span class="line">                child: _TestWidget(),<span class="comment">//子widget中依赖ShareDataWidget</span></span><br><span class="line">              ),</span><br><span class="line">              ElevatedButton(</span><br><span class="line">                	<span class="comment">//每点击一次，将count自增，然后重新build,ShareDataWidget的data将被更新  </span></span><br><span class="line">                  onPressed: () =&gt; setState(() &#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                  &#125;),</span><br><span class="line">                  child: Text(<span class="string">&#x27;Increment&#x27;</span>)</span><br><span class="line">              ),</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》七：功能型组件/WeChat82decdb61c34cabc1597ca20cba3581b.png" alt="WeChat82decdb61c34cabc1597ca20cba3581b" style="zoom:80%;" />

<p>每点击一次，计数器就会自增，控制台就会打印一句日志 flutter: Dependencies change，依赖变化后，其 didChangeDependencies 会被调用</p>
<p>如果 _TestWidget 的 build 方法中没有使用 ShareDataWidget 的数据，那么它的 didChangeDependencies 将不会被调用，因为它没有依赖 ShareDataWidget，即将上面改成 </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="comment">//使用InheritedWidget中的共享数据</span></span><br><span class="line">  <span class="comment">//return Text(ShareDataWidget.of(context)!.data.toString());</span></span><br><span class="line">  retirn Text(<span class="string">&#x27;text&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>didChangeDependencies 中做什么</li>
</ul>
<p>一般子 widget 很少会重写此方法，因为依赖改变后 Flutter 也都会调用 build() 方法重新构建组件树。但是，如果需要在依赖改变后执行一些昂贵 的操作，比如网络请求，这时最好的方式是在此方法中执行，可以避免每次 build 都执行这些昂贵操作</p>
<h5 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h5><p>如果只想在 _TestWidgetState 中引用 ShareDataWidget 数据，但不希望在 ShareDataWidget 发生变化时调用 _TestWidgetState 的 didChangeDependencies</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个便捷方法，方便子树中的widget获取共享数据</span></span><br><span class="line"><span class="keyword">static</span> ShareDataWidget of(BuildContext context) &#123;</span><br><span class="line">  <span class="comment">//return context.dependOnInheritedWidgetOfExactType&lt;ShareDataWidget&gt;();</span></span><br><span class="line">  <span class="keyword">return</span> context.getElementForInheritedWidgetOfExactType&lt;ShareDataWidget&gt;().widget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dependOnInheritedWidgetOfExactType 和 getElementForInheritedWidgetOfExactType 的区别是前者会注册依赖关系，后者不会。</p>
<p>调用 dependOnInheritedWidgetOfExactType 后，InheritedWidget 和依赖它的子孙组件关系便完成了注册，之后 InheritedWidget 发生变化，就会更新依赖它的子孙组件，也就会调用子孙组件的 didChangeDependencies 方法和 build 方法</p>
<h4 id="7-3-跨组件状态共享-Provider"><a href="#7-3-跨组件状态共享-Provider" class="headerlink" title="7.3 跨组件状态共享 Provider"></a>7.3 跨组件状态共享 Provider</h4><p>登录状态同步的示例</p>
<p>定义事件：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Event&#123;</span><br><span class="line">  login,</span><br><span class="line">  ... <span class="comment">//省略其它事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>登录页代码大致如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 登录状态改变后发布状态改变事件</span></span><br><span class="line">bus.emit(Event.login);</span><br></pre></td></tr></table></figure>

<p>依赖登录状态的页面：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> onLoginChanged(e)&#123;</span><br><span class="line">  <span class="comment">//登录状态变化处理逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> initState() &#123;</span><br><span class="line">  <span class="comment">//订阅登录状态改变事件</span></span><br><span class="line">  bus.<span class="keyword">on</span>(Event.login,onLogin);</span><br><span class="line">  <span class="keyword">super</span>.initState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> dispose() &#123;</span><br><span class="line">  <span class="comment">//取消订阅</span></span><br><span class="line">  bus.off(Event.login,onLogin);</span><br><span class="line">  <span class="keyword">super</span>.dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过观察者模式来实现跨组件状态共享缺点：<br>必须显式定义各种事件，不好管理<br>订阅者必须显式注册状态改变回调，必须组件销毁时手动解绑回调以避免内存泄漏</p>
<p>InheritedWidget 的特性就是能绑定 InheritedWidget 与依赖它的子孙组件的依赖关系，且 InheritedWidget 数据发生变化时，可以自动更新依赖的子孙组件。利用这个特性，我们可以将需要跨组件共享的状态保存在 InheritedWidget 中，然后在子组件中引用 InheritedWidget 即可</p>
<h5 id="7-3-1-Provider"><a href="#7-3-1-Provider" class="headerlink" title="7.3.1 Provider"></a>7.3.1 Provider</h5><p>实现一个最小功能的 Provider</p>
<p>首先需要一个保存共享的数据 InheritedWidget，由于具体业务数据不可预期，使用泛型，定义一个通用的 InheritedProvider 类，它继承自 InheritedWidget</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InHeritedProvider</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">  InHeritedProvider(&#123;</span><br><span class="line">    Key? key,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.data,</span><br><span class="line">    <span class="keyword">required</span> Widget child,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(child: child);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> T data;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(<span class="keyword">covariant</span> InHeritedProvider&lt;T&gt; oldWidget) &#123;</span><br><span class="line">    <span class="comment">//在此简单返回true，则每次更新都会调用依赖其的子孙节点的`didChangeDependencies`。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>数据发生变化怎么通知？</li>
</ul>
<p>Flutter 提供了 ChangeNotifier 类，继承自 Listenable 定义大致如下</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangeNotifier</span> <span class="keyword">implements</span> <span class="title">Listenable</span> </span>&#123;</span><br><span class="line">  <span class="built_in">List</span> listeners=[];</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> addListener(VoidCallback listener) &#123;</span><br><span class="line">     <span class="comment">//添加监听器</span></span><br><span class="line">     listeners.add(listener);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> removeListener(VoidCallback listener) &#123;</span><br><span class="line">    <span class="comment">//移除监听器</span></span><br><span class="line">    listeners.remove(listener);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> notifyListeners() &#123;</span><br><span class="line">    <span class="comment">//通知所有监听器，触发监听器回调 </span></span><br><span class="line">    listeners.forEach((item)=&gt;item());</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  ... <span class="comment">//省略无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，将要共享的状态放到一个 Model 类中，让它继承自 ChangeNotifier，这样当共享状态发生改变时，只需调用 notifyListeners() 来通知订阅者，然后订阅者重新构建 InheritedProvider</p>
<p>//TODO：。。。。</p>
<h4 id="7-4-颜色和主题"><a href="#7-4-颜色和主题" class="headerlink" title="7.4 颜色和主题"></a>7.4 颜色和主题</h4><h5 id="7-4-1-颜色"><a href="#7-4-1-颜色" class="headerlink" title="7.4.1 颜色"></a>7.4.1 颜色</h5><ul>
<li>MaterialColor</li>
</ul>
<p>MaterialColor 包含一种颜色的10个级别的渐变色，通过 [] 运算符的索引值来代表颜色的深度，有效的索引有：50，100，200，.. 800，900 数值越大，颜色越深，默认值为索引等于500的颜色</p>
<p>可以根据 shadeXX 来获取具体索引的颜色 Color.blue.shade50 </p>
<img src="《Flutter实战第二版》七：功能型组件/7-5.6f1c5012.jpeg" alt="7-5.6f1c5012" style="zoom:80%;" />

<h5 id="7-4-2-Theme"><a href="#7-4-2-Theme" class="headerlink" title="7.4.2 Theme"></a>7.4.2 Theme</h5><ul>
<li>ThemeData</li>
</ul>
<p>ThemeData 用于保存 Material 组件库的主题数据</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ThemeData(&#123;</span><br><span class="line">  Brightness? brightness, <span class="comment">//深色还是浅色</span></span><br><span class="line">  MaterialColor? primarySwatch, <span class="comment">//主题颜色样本，见下面介绍</span></span><br><span class="line">  Color? primaryColor, <span class="comment">//主色，决定导航栏颜色</span></span><br><span class="line">  Color? cardColor, <span class="comment">//卡片颜色</span></span><br><span class="line">  Color? dividerColor, <span class="comment">//分割线颜色</span></span><br><span class="line">  ButtonThemeData buttonTheme, <span class="comment">//按钮主题</span></span><br><span class="line">  Color dialogBackgroundColor,<span class="comment">//对话框背景颜色</span></span><br><span class="line">  <span class="built_in">String</span> fontFamily, <span class="comment">//文字字体</span></span><br><span class="line">  TextTheme textTheme,<span class="comment">// 字体主题，包括标题、body等文字样式</span></span><br><span class="line">  IconThemeData iconTheme, <span class="comment">// Icon的默认样式</span></span><br><span class="line">  TargetPlatform platform, <span class="comment">//指定平台，应用特定平台控件风格</span></span><br><span class="line">  ColorScheme? colorScheme,</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>路由换肤示例</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThemeTestRoute</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ThemeTestRouteState createState() =&gt; _ThemeTestRouteState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ThemeTestRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ThemeTestRoute</span>&gt; </span>&#123;</span><br><span class="line">  MaterialColor _themeColor = Colors.teal; <span class="comment">//当前路由主题色</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    ThemeData themeData = Theme.of(context);</span><br><span class="line">    <span class="keyword">return</span> Theme(</span><br><span class="line">      data: ThemeData(</span><br><span class="line">          primarySwatch: _themeColor, <span class="comment">//用于导航栏、FloatingActionButton的背景色等</span></span><br><span class="line">          iconTheme: IconThemeData(color: _themeColor) <span class="comment">//用于Icon颜色</span></span><br><span class="line">      ),</span><br><span class="line">      child: Scaffold(</span><br><span class="line">        appBar: AppBar(title: Text(<span class="string">&quot;主题测试&quot;</span>)),</span><br><span class="line">        body: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            <span class="comment">//第一行Icon使用主题中的iconTheme</span></span><br><span class="line">            Row(</span><br><span class="line">                mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">                children: &lt;Widget&gt;[</span><br><span class="line">                  Icon(Icons.favorite),</span><br><span class="line">                  Icon(Icons.airport_shuttle),</span><br><span class="line">                  Text(<span class="string">&quot;  颜色跟随主题&quot;</span>)</span><br><span class="line">                ]</span><br><span class="line">            ),</span><br><span class="line">            <span class="comment">//为第二行Icon自定义颜色（固定为黑色)</span></span><br><span class="line">            Theme(</span><br><span class="line">              data: themeData.copyWith(</span><br><span class="line">                iconTheme: themeData.iconTheme.copyWith(</span><br><span class="line">                    color: Colors.black</span><br><span class="line">                ),</span><br><span class="line">              ),</span><br><span class="line">              child: Row(</span><br><span class="line">                  mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">                  children: &lt;Widget&gt;[</span><br><span class="line">                    Icon(Icons.favorite),</span><br><span class="line">                    Icon(Icons.airport_shuttle),</span><br><span class="line">                    Text(<span class="string">&quot;  颜色固定黑色&quot;</span>)</span><br><span class="line">                  ]</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">        floatingActionButton: FloatingActionButton(</span><br><span class="line">            onPressed: () =&gt;  <span class="comment">//切换主题</span></span><br><span class="line">                setState(() =&gt;</span><br><span class="line">                _themeColor =</span><br><span class="line">                _themeColor == Colors.teal ? Colors.blue : Colors.teal</span><br><span class="line">                ),</span><br><span class="line">            child: Icon(Icons.palette)</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》七：功能型组件/WeChat480a699489c96afae7c2834566a2792f.png" alt="WeChat480a699489c96afae7c2834566a2792f" style="zoom:80%;" />

<p>可以通过局部主题覆盖全局主题</p>
<h4 id="7-5-ValueListenableBuilder"><a href="#7-5-ValueListenableBuilder" class="headerlink" title="7.5 ValueListenableBuilder"></a>7.5 ValueListenableBuilder</h4><p>ValueListenableBuilder 功能是监听一个数据源，如果数据源发生变化，则会重新执行其 builder</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ValueListenableBuilder(&#123;</span><br><span class="line">  Key? key,</span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">this</span>.valueListenable, <span class="comment">// 数据源，类型为ValueListenable&lt;T&gt;</span></span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">this</span>.builder, <span class="comment">// builder</span></span><br><span class="line">  <span class="keyword">this</span>.child,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>valueListenable：类型为 <code>ValueListenable&lt;T&gt;</code> ，表示一个可监听的数据源</p>
<p>builder：数据源发生变化通知时，会重新调用 builder 重新 builder 子组件树</p>
<p>child：builder 中每次都会重新构建整个子组件树，如果子组件树中有一些不变的部分，可以传递给 child</p>
<p>点击器示例</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValueListenableRoute</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ValueListenableRoute(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ValueListenableRouteState createState() =&gt; _ValueListenableRouteState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ValueListenableRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ValueListenableRoute</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 定义一个ValueNotifier，当数字变化时会通知 ValueListenableBuilder</span></span><br><span class="line">  <span class="keyword">final</span> ValueNotifier&lt;<span class="built_in">int</span>&gt; _counter = ValueNotifier&lt;<span class="built_in">int</span>&gt;(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">double</span> textScaleFactor = <span class="number">1.5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;build&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">&#x27;ValueListenableBuilder 测试&#x27;</span>)),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: ValueListenableBuilder(</span><br><span class="line">            valueListenable: _counter,</span><br><span class="line">            builder: (BuildContext context, <span class="built_in">int</span> value, Widget? child) &#123;</span><br><span class="line">              <span class="comment">// builder 方法只会在 _counter 变化时被调用</span></span><br><span class="line">              <span class="keyword">return</span> Row(</span><br><span class="line">                mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">                children: [</span><br><span class="line">                  Text(<span class="string">&#x27;点击了<span class="subst">$value</span>次&#x27;</span>, textScaleFactor: textScaleFactor,)</span><br><span class="line">                ],</span><br><span class="line">              );</span><br><span class="line">            &#125;,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        <span class="comment">// 点击后值 +1，触发 ValueListenableBuilder 重新构建</span></span><br><span class="line">        onPressed: () =&gt; _counter.value += <span class="number">1</span>,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》七：功能型组件/WeChata5da268a632103c4c715f5e27552825c.png" alt="WeChata5da268a632103c4c715f5e27552825c" style="zoom:80%;" />

<p>控制台只在打开时 build 了一次，点击 + 按钮时只是 ValueListenableBuilder 重新构建了子组件树，整个页面没有重新 build；尽可能让 ValueListenableBuilder 只构建依赖数据源的 widget，这样的话可以缩小重新构建的范围</p>
<p>ValueListenableBuilder 和数据流向无关，可以实现任意数据流向的数据共享，实践中 ValueListenableBuilder 的拆分粒度应该尽可能的细</p>
<h4 id="7-6-异步-UI-更新"><a href="#7-6-异步-UI-更新" class="headerlink" title="7.6 异步 UI 更新"></a>7.6 异步 UI 更新</h4><h5 id="7-6-1-FutureBuilder"><a href="#7-6-1-FutureBuilder" class="headerlink" title="7.6.1 FutureBuilder"></a>7.6.1 FutureBuilder</h5><p>FutureBuilder 会依赖一个 Future，会根据所依赖的 Future 的状态来动态构建自身</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">FutureBuilder(&#123;</span><br><span class="line">  <span class="keyword">this</span>.future,</span><br><span class="line">  <span class="keyword">this</span>.initialData,</span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">this</span>.builder,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>future：FutureBuilder 依赖的 future，通常是一个异步耗时的任务</p>
<p>initialData：初始数据，用户设置默认数据</p>
<p>builder：widget 构建器，该构建器会在 Future 执行的不同阶段被多次调用</p>
<p>签名如下</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> AsyncWidgetBuilder&lt;T&gt; = Widget <span class="built_in">Function</span>(BuildContext context, AsyncSnapshot&lt;T&gt; snapshot);</span><br></pre></td></tr></table></figure>

<p>snapshot 会包含当前异步任务的状态信息及结果信息，<br>snapshot.connectionState 获取异步任务的状态信息<br>snapshot.hasError 判断异步任务是否有错误等</p>
<ul>
<li>示例</li>
</ul>
<p>实现一个路由从网上获取数据，获取数据时弹一个加载框；获取结束时，如果成功则显示获取到的数据，失败则显示错误</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_DemoState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">Demo</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">  Future&lt;<span class="built_in">String</span>&gt; mockNetworkData() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">2</span>), () =&gt; <span class="string">&quot;我是从互联网上获取的数据&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">&#x27;标题&#x27;</span>)),</span><br><span class="line">      body: Container(</span><br><span class="line">        child: FutureBuilder(</span><br><span class="line">          future: mockNetworkData(),</span><br><span class="line">          builder: (BuildContext context, AsyncSnapshot snapshot) &#123;</span><br><span class="line">            <span class="comment">// 请求已结束</span></span><br><span class="line">            <span class="keyword">if</span> (snapshot.connectionState == ConnectionState.done) &#123;</span><br><span class="line">              <span class="keyword">if</span> (snapshot.hasError) &#123;</span><br><span class="line">                <span class="comment">// 请求失败，显示错误</span></span><br><span class="line">                <span class="keyword">return</span> Text(<span class="string">&quot;Error: <span class="subst">$&#123;snapshot.error&#125;</span>&quot;</span>);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 请求成功，显示数据</span></span><br><span class="line">                <span class="keyword">return</span> Text(<span class="string">&quot;Contents: <span class="subst">$&#123;snapshot.data&#125;</span>&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 请求未结束，显示loading</span></span><br><span class="line">              <span class="keyword">return</span> CircularProgressIndicator();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》七：功能型组件/WeChatbfb98a9a1f4c131945af42218a1998ee.png" alt="WeChatbfb98a9a1f4c131945af42218a1998ee" style="zoom: 67%;" />

<p>connectionState 异步任务状态是个枚举</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> ConnectionState &#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">当前没有异步任务，比如[FutureBuilder]的[future]为null时</span></span></span><br><span class="line">  none,</span><br><span class="line">  <span class="comment">/// <span class="markdown">异步任务处于等待状态</span></span></span><br><span class="line">  waiting,</span><br><span class="line">  <span class="comment">/// <span class="markdown">Stream处于激活状态（流上已经有数据传递了），对于FutureBuilder没有该状态。</span></span></span><br><span class="line">  active,</span><br><span class="line">  <span class="comment">/// <span class="markdown">异步任务已经终止.</span></span></span><br><span class="line">  done,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConnectionState.active 只有在 StreamBuilder 中才会出现</p>
<h5 id="7-6-2-StreamBuilder"><a href="#7-6-2-StreamBuilder" class="headerlink" title="7.6.2 StreamBuilder"></a>7.6.2 StreamBuilder</h5><p>Dart 中 Stream 也是用于接收异步事件数据，和 Future 不同的是，它可以接收多个异步操作的结果，常用于会多次读取数据的异步任务场景，如网络内容下载，文件读写</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">StreamBuilder(&#123;</span><br><span class="line">  <span class="keyword">this</span>.initialData,</span><br><span class="line">  Stream&lt;T&gt; stream,</span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">this</span>.builder,</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>

<p>和 FutureBuilder 有一点不同，前者需要一个 future，后者需要一个 stream</p>
<ul>
<li>示例</li>
</ul>
<p>创建一个计时器，每隔1秒，计数加1，这里使用 Stream 来实现每隔一秒生成一个数字</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Stream&lt;<span class="built_in">int</span>&gt; counter() &#123;</span><br><span class="line">  <span class="keyword">return</span> Stream.periodic(<span class="built_in">Duration</span>(seconds: <span class="number">1</span>), (i) &#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">   <span class="keyword">return</span> StreamBuilder&lt;<span class="built_in">int</span>&gt;(</span><br><span class="line">     stream: counter(), <span class="comment">//</span></span><br><span class="line">     <span class="comment">//initialData: ,// a Stream&lt;int&gt; or null</span></span><br><span class="line">     builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">int</span>&gt; snapshot) &#123;</span><br><span class="line">       <span class="keyword">if</span> (snapshot.hasError)</span><br><span class="line">         <span class="keyword">return</span> Text(<span class="string">&#x27;Error: <span class="subst">$&#123;snapshot.error&#125;</span>&#x27;</span>);</span><br><span class="line">       <span class="keyword">switch</span> (snapshot.connectionState) &#123;</span><br><span class="line">         <span class="keyword">case</span> ConnectionState.none:</span><br><span class="line">           <span class="keyword">return</span> Text(<span class="string">&#x27;没有Stream&#x27;</span>);</span><br><span class="line">         <span class="keyword">case</span> ConnectionState.waiting:</span><br><span class="line">           <span class="keyword">return</span> Text(<span class="string">&#x27;等待数据...&#x27;</span>);</span><br><span class="line">         <span class="keyword">case</span> ConnectionState.active:</span><br><span class="line">           <span class="keyword">return</span> Text(<span class="string">&#x27;active: <span class="subst">$&#123;snapshot.data&#125;</span>&#x27;</span>);</span><br><span class="line">         <span class="keyword">case</span> ConnectionState.done:</span><br><span class="line">           <span class="keyword">return</span> Text(<span class="string">&#x27;Stream 已关闭&#x27;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// unreachable</span></span><br><span class="line">     &#125;,</span><br><span class="line">   );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实战中，凡是UI会依赖多个异步数据而发生变化的场景都可以使用 StreamBuilder</p>
<h4 id="7-7-对话框详解"><a href="#7-7-对话框详解" class="headerlink" title="7.7 对话框详解"></a>7.7 对话框详解</h4><h5 id="7-7-1-使用对话框"><a href="#7-7-1-使用对话框" class="headerlink" title="7.7.1 使用对话框"></a>7.7.1 使用对话框</h5><ul>
<li>AlertDialog</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AlertDialog(&#123;</span><br><span class="line">  Key? key,</span><br><span class="line">  <span class="keyword">this</span>.title, <span class="comment">//对话框标题组件</span></span><br><span class="line">  <span class="keyword">this</span>.titlePadding, <span class="comment">// 标题填充</span></span><br><span class="line">  <span class="keyword">this</span>.titleTextStyle, <span class="comment">//标题文本样式</span></span><br><span class="line">  <span class="keyword">this</span>.content, <span class="comment">// 对话框内容组件</span></span><br><span class="line">  <span class="keyword">this</span>.contentPadding = <span class="keyword">const</span> EdgeInsets.fromLTRB(<span class="number">24.0</span>, <span class="number">20.0</span>, <span class="number">24.0</span>, <span class="number">24.0</span>), <span class="comment">//内容的填充</span></span><br><span class="line">  <span class="keyword">this</span>.contentTextStyle,<span class="comment">// 内容文本样式</span></span><br><span class="line">  <span class="keyword">this</span>.actions, <span class="comment">// 对话框操作按钮组</span></span><br><span class="line">  <span class="keyword">this</span>.backgroundColor, <span class="comment">// 对话框背景色</span></span><br><span class="line">  <span class="keyword">this</span>.elevation,<span class="comment">// 对话框的阴影</span></span><br><span class="line">  <span class="keyword">this</span>.semanticLabel, <span class="comment">//对话框语义化标签(用于读屏软件)</span></span><br><span class="line">  <span class="keyword">this</span>.shape, <span class="comment">// 对话框外形</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _DemoState createState() =&gt; _DemoState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_DemoState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">Demo</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//弹出对话框</span></span><br><span class="line">  Future&lt;<span class="built_in">bool?</span>&gt; showDialog1() &#123;</span><br><span class="line">    <span class="keyword">return</span> showDialog&lt;<span class="built_in">bool</span>&gt;(</span><br><span class="line">        context: context,</span><br><span class="line">        builder: (context) &#123;</span><br><span class="line">          <span class="keyword">return</span> AlertDialog(</span><br><span class="line">            title: Text(<span class="string">&#x27;提示&#x27;</span>),</span><br><span class="line">            content: Text(<span class="string">&#x27;您确定要删除当前文件吗?&#x27;</span>),</span><br><span class="line">            actions: [</span><br><span class="line">              TextButton(</span><br><span class="line">                  onPressed: () =&gt; Navigator.of(context).pop(),<span class="comment">//关闭对话框</span></span><br><span class="line">                  child: Text(<span class="string">&#x27;取消&#x27;</span>)</span><br><span class="line">              ),</span><br><span class="line">              TextButton(</span><br><span class="line">                  onPressed: ()&#123;</span><br><span class="line">                    <span class="comment">//关闭对话框并返回true</span></span><br><span class="line">                    Navigator.of(context).pop(<span class="keyword">true</span>);</span><br><span class="line">                  &#125;,<span class="comment">// ... 执行删除操作</span></span><br><span class="line">                  child: Text(<span class="string">&#x27;删除&#x27;</span>)</span><br><span class="line">              ),</span><br><span class="line">            ],</span><br><span class="line">          );</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">&#x27;标题&#x27;</span>)),</span><br><span class="line">      body: Container(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: [</span><br><span class="line">            ElevatedButton(</span><br><span class="line">                onPressed: () <span class="keyword">async</span> &#123;</span><br><span class="line">                  <span class="comment">//弹出对话框并等待其关闭</span></span><br><span class="line">                  <span class="built_in">bool?</span> delete = <span class="keyword">await</span> showDialog1();</span><br><span class="line">                  <span class="keyword">if</span> (delete == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;取消删除&quot;</span>);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;已确认删除&quot;</span>);</span><br><span class="line">                    <span class="comment">//... 删除文件</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                child: Text(<span class="string">&#x27;对话框1&#x27;</span>),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》七：功能型组件/WeChat27864c95f0c816238363a69b4f71ff06.png" alt="WeChat27864c95f0c816238363a69b4f71ff06" style="zoom:80%;" />

<p>通过 Navigator.of(context).pop(…) 方法来关闭对话框，都可以返回一个结果数据</p>
<ul>
<li>弹出对话框 showDialog()</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;T?&gt; showDialog&lt;T&gt;(&#123;</span><br><span class="line">  <span class="keyword">required</span> BuildContext context,</span><br><span class="line">  <span class="keyword">required</span> WidgetBuilder builder, <span class="comment">// 对话框UI的builder</span></span><br><span class="line">  <span class="built_in">bool</span> barrierDismissible = <span class="keyword">true</span>, <span class="comment">//点击对话框barrier(遮罩)时是否关闭它</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>SimpleDialog</li>
</ul>
<p>会展示一个列表，用于列表选择的场景</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;<span class="keyword">void</span>&gt; changeLanguage() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="built_in">int?</span> i = <span class="keyword">await</span> showDialog(</span><br><span class="line">      context: context,</span><br><span class="line">      builder: (context) &#123;</span><br><span class="line">        <span class="keyword">return</span> SimpleDialog(</span><br><span class="line">          title: Text(<span class="string">&#x27;请选择语言&#x27;</span>),</span><br><span class="line">          children: [</span><br><span class="line">            SimpleDialogOption(</span><br><span class="line">              child: Padding(</span><br><span class="line">                  padding: EdgeInsets.symmetric(vertical: <span class="number">6</span>),</span><br><span class="line">                  child: Text(<span class="string">&#x27;中文简体&#x27;</span>),</span><br><span class="line">              ),</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                Navigator.pop(context, <span class="number">1</span>);</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">            SimpleDialogOption(</span><br><span class="line">              child: Padding(</span><br><span class="line">                padding: EdgeInsets.symmetric(vertical: <span class="number">6</span>),</span><br><span class="line">                child: Text(<span class="string">&#x27;美国英语&#x27;</span>),</span><br><span class="line">              ),</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                Navigator.pop(context, <span class="number">2</span>);</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (i != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;选择了：<span class="subst">$&#123;i == <span class="number">1</span> ? <span class="string">&quot;中文简体&quot;</span> : <span class="string">&quot;美国英语&quot;</span>&#125;</span>&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>列表项组件使用了 SimpleDialogOption 包装了，相当于一个 TextButton，只不过按钮是左对齐的，并且 padding 较小</p>
<ul>
<li>Dialog</li>
</ul>
<p>如果对话框需要嵌套一个 ListView 可以直接使用 Dialog 类</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;<span class="keyword">void</span>&gt; showListDialog() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="built_in">int?</span> index = <span class="keyword">await</span> showDialog(</span><br><span class="line">      context: context,</span><br><span class="line">      builder: (context) &#123;</span><br><span class="line">        <span class="keyword">var</span> child = Column(</span><br><span class="line">          children: [</span><br><span class="line">            ListTile(title: Text(<span class="string">&#x27;请选择&#x27;</span>)),</span><br><span class="line">            Expanded(</span><br><span class="line">                child: ListView.builder(</span><br><span class="line">                    itemCount: <span class="number">30</span>,</span><br><span class="line">                    itemBuilder: (context, index) &#123;</span><br><span class="line">                      <span class="keyword">return</span> ListTile(</span><br><span class="line">                        title: Text(<span class="string">&quot;<span class="subst">$index</span>&quot;</span>),</span><br><span class="line">                        onTap: () =&gt; Navigator.of(context).pop(index),</span><br><span class="line">                      );</span><br><span class="line">                    &#125;,</span><br><span class="line">                ),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> Dialog(child: child);</span><br><span class="line">      &#125;,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (index != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;点击了：<span class="subst">$index</span>&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》七：功能型组件/WeChatf310a19612106d0766aaec0ad0fde4d9.png" alt="WeChatf310a19612106d0766aaec0ad0fde4d9" style="zoom: 67%;" />

<h5 id="7-7-2-对话框打开动画及遮罩"><a href="#7-7-2-对话框打开动画及遮罩" class="headerlink" title="7.7.2 对话框打开动画及遮罩"></a>7.7.2 对话框打开动画及遮罩</h5><p>如何打开一个普通风格的对话框（非 Material风格）？Flutter 提供了一个 showGeneralDialog 方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;T?&gt; showGeneralDialog&lt;T&gt;(&#123;</span><br><span class="line">  <span class="keyword">required</span> BuildContext context,</span><br><span class="line">  <span class="keyword">required</span> RoutePageBuilder pageBuilder, <span class="comment">//构建对话框内部UI</span></span><br><span class="line">  <span class="built_in">bool</span> barrierDismissible = <span class="keyword">false</span>, <span class="comment">//点击遮罩是否关闭对话框</span></span><br><span class="line">  <span class="built_in">String?</span> barrierLabel, <span class="comment">// 语义化标签(用于读屏软件)</span></span><br><span class="line">  Color barrierColor = <span class="keyword">const</span> Color(<span class="number">0x80000000</span>), <span class="comment">// 遮罩颜色</span></span><br><span class="line">  <span class="built_in">Duration</span> transitionDuration = <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">200</span>), <span class="comment">// 对话框打开/关闭的动画时长</span></span><br><span class="line">  RouteTransitionsBuilder? transitionBuilder, <span class="comment">// 对话框打开/关闭的动画</span></span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>showDialog 方法正是 showGeneralDialog 的一个封装，定制了 Material 风格对话框的遮罩颜色和动画</p>
<ul>
<li>封装一个 showCustomDialog 方法</li>
</ul>
<h5 id="7-7-3-对话框实现原理"><a href="#7-7-3-对话框实现原理" class="headerlink" title="7.7.3 对话框实现原理"></a>7.7.3 对话框实现原理</h5><p>直接调用 Navigatio 的 push 方法打开了一个新的对话框路由 RawDialogRoute，然后返回了 push 的返回值，对话框实际上正是通过路由的形式打开的</p>
<h5 id="7-7-4-对话框状态管理"><a href="#7-7-4-对话框状态管理" class="headerlink" title="7.7.4 对话框状态管理"></a>7.7.4 对话框状态管理</h5><h5 id="7-7-5-其它类型的对话框"><a href="#7-7-5-其它类型的对话框" class="headerlink" title="7.7.5 其它类型的对话框"></a>7.7.5 其它类型的对话框</h5><ul>
<li>Loading 框</li>
<li>日历选择</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>《Flutter实战第二版》三：基础组件</title>
    <url>/2022/01/18/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E4%B8%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="3-基础组件"><a href="#3-基础组件" class="headerlink" title="3 基础组件"></a>3 基础组件</h3><h4 id="3-1-文本及样式"><a href="#3-1-文本及样式" class="headerlink" title="3.1 文本及样式"></a>3.1 文本及样式</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MaterialApp(home: TextDemo()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextDemo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&#x27;标题&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          children: [</span><br><span class="line">            Text(<span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">              style: TextStyle(</span><br><span class="line">                color: Colors.blue,</span><br><span class="line">                fontSize: <span class="number">30</span>,</span><br><span class="line">                height: <span class="number">1.2</span>,</span><br><span class="line">                fontFamily: <span class="string">&#x27;Courier&#x27;</span>,</span><br><span class="line">                background: Paint()..color=Colors.yellow,</span><br><span class="line">                decoration: TextDecoration.underline,</span><br><span class="line">                decorationStyle: TextDecorationStyle.dashed,</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            Text.rich(</span><br><span class="line">                TextSpan(children: [</span><br><span class="line">                  TextSpan(text: <span class="string">&#x27;Home: &#x27;</span>,</span><br><span class="line">                      style: TextStyle(fontSize: <span class="number">30</span>)</span><br><span class="line">                  ),</span><br><span class="line">                  TextSpan(text: <span class="string">&#x27;//flutterchina.club&#x27;</span>,</span><br><span class="line">                      style: TextStyle(</span><br><span class="line">                          color: Colors.blue, fontSize: <span class="number">30</span>),</span><br><span class="line">                  ),</span><br><span class="line">                ])</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E4%B8%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/WeChat312b40c64293529cd163ce4550ee7471.png?lastModify=1642479994" alt="WeChat312b40c64293529cd163ce4550ee7471"></p>
<h5 id="3-1-1-Text"><a href="#3-1-1-Text" class="headerlink" title="3.1.1 Text"></a>3.1.1 Text</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">body: Container(</span><br><span class="line">  child: Column(</span><br><span class="line">    children: [</span><br><span class="line">      Text(<span class="string">&#x27;Hello world&#x27;</span>, textAlign: TextAlign.left),</span><br><span class="line">      Text(<span class="string">&#x27;Hello world I`m Jack&#x27;</span>*<span class="number">4</span>, maxLines: <span class="number">1</span>, overflow: TextOverflow.ellipsis),</span><br><span class="line">      Text(<span class="string">&#x27;Hello world&#x27;</span>, textScaleFactor: <span class="number">2</span>),</span><br><span class="line">    ],</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<ul>
<li>Text 的构造方法</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Text(<span class="keyword">this</span>.data, &#123;  <span class="comment">//Text显示的内容</span></span><br><span class="line">Key key,</span><br><span class="line"><span class="keyword">this</span>.style, <span class="comment">//Text显示的样式</span></span><br><span class="line"><span class="keyword">this</span>.textAlign,<span class="comment">//文本应该如何水平对齐,TextAlign.start,end 或者center</span></span><br><span class="line"><span class="keyword">this</span>.textDirection, <span class="comment">//文本方向,TextDirection.ltr\TextDirection.rtl</span></span><br><span class="line"><span class="keyword">this</span>.locale,</span><br><span class="line"><span class="keyword">this</span>.softWrap,  <span class="comment">//是否自动换行，若为false，文字将不考虑容器大小，单行显示，超出屏幕部分将默认截断处理</span></span><br><span class="line"><span class="keyword">this</span>.overflow, <span class="comment">//当文字超出屏幕的时候，如何处理,TextOverflow.clip(裁剪)\TextOverflow.fade(渐隐)\TextOverflow.ellipsis(省略号)</span></span><br><span class="line"><span class="keyword">this</span>.textScaleFactor, <span class="comment">//字体大小缩放因子，将字体设置成10.0，然后倍率为2，使用字体大小就是20</span></span><br><span class="line"><span class="keyword">this</span>.maxLines, <span class="comment">//最大行数设置</span></span><br><span class="line"><span class="keyword">this</span>.semanticsLabel,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="3-1-2-TextStyle"><a href="#3-1-2-TextStyle" class="headerlink" title="3.1.2 TextStyle"></a>3.1.2 TextStyle</h5><ul>
<li>TextStyle 构造方法</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TextStyle(&#123;</span><br><span class="line">    <span class="keyword">this</span>.inherit: <span class="keyword">true</span>,      <span class="comment">// 为false的时候不继承默认样式</span></span><br><span class="line">    <span class="keyword">this</span>.color,              <span class="comment">// 颜色 </span></span><br><span class="line">    <span class="keyword">this</span>.fontSize,           <span class="comment">// 字号</span></span><br><span class="line">    <span class="keyword">this</span>.fontWeight,         <span class="comment">// 字重，加粗也用这个字段  FontWeight.w700</span></span><br><span class="line">    <span class="keyword">this</span>.fontStyle,          <span class="comment">// FontStyle.normal  FontStyle.italic斜体</span></span><br><span class="line">    <span class="keyword">this</span>.letterSpacing,      <span class="comment">// 字符间距  就是单个字母或者汉字之间的间隔，可以是负数</span></span><br><span class="line">    <span class="keyword">this</span>.wordSpacing,        <span class="comment">// 字间距 句字之间的间距</span></span><br><span class="line">    <span class="keyword">this</span>.textBaseline,       <span class="comment">// 基线，两个值，字面意思是一个用来排字母的，一人用来排表意字的（类似中文）</span></span><br><span class="line">    <span class="keyword">this</span>.height,            <span class="comment">// 当用来Text控件上时，行高（会乘以fontSize,所以不以设置过大）</span></span><br><span class="line">    <span class="keyword">this</span>.decoration,        <span class="comment">// 添加上划线，下划线，删除线 </span></span><br><span class="line">    <span class="keyword">this</span>.decorationColor,   <span class="comment">// 划线的颜色</span></span><br><span class="line">    <span class="keyword">this</span>.decorationStyle,   <span class="comment">// 这个style可能控制画实线，虚线，两条线，点, 波浪线等</span></span><br><span class="line">    <span class="keyword">this</span>.debugLabel,</span><br><span class="line">    <span class="built_in">String</span> fontFamily,    <span class="comment">// 字体</span></span><br><span class="line">    <span class="built_in">String</span> package,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>



<h5 id="3-1-3-TextSpan"><a href="#3-1-3-TextSpan" class="headerlink" title="3.1.3 TextSpan"></a>3.1.3 TextSpan</h5><p>TextSpan 将 Text 内容的不同部分按照不同的样式显示</p>
<ul>
<li>TextSpan 的定义:</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TextSpan(&#123;</span><br><span class="line">   TextStyle style, </span><br><span class="line">   Sting text,</span><br><span class="line">   <span class="built_in">List</span>&lt;TextSpan&gt; children,</span><br><span class="line">   GestureRecognizer recognizer,</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<p>style 和 text 属性代表该文本的样式和内容，children 是 TextSpan 数组，也就是 TextSpan 可以包括其它 TextSpan，recognizer 用于文本片段上手势识别处理</p>
<h5 id="3-1-4-DefaultTextStyle"><a href="#3-1-4-DefaultTextStyle" class="headerlink" title="3.1.4 DefaultTextStyle"></a>3.1.4 DefaultTextStyle</h5><p>文本样式可以被默认继承（子类文本组件未指定具体样式可以使用 Widget 树中父级的默认样式）</p>
<p>DefaultTextStyle 用于设置默认文本样式</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextDemo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&#x27;标题&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: DefaultTextStyle(</span><br><span class="line">          style: TextStyle(</span><br><span class="line">            color: Colors.red,</span><br><span class="line">            fontSize: <span class="number">20</span>,</span><br><span class="line">          ),</span><br><span class="line">          child: Column(</span><br><span class="line">            children: [</span><br><span class="line">              Text(<span class="string">&#x27;123&#x27;</span>),</span><br><span class="line">              Text(<span class="string">&#x27;456&#x27;</span>),</span><br><span class="line">              Text(<span class="string">&#x27;789&#x27;</span>, style: TextStyle(</span><br><span class="line">                  inherit: <span class="keyword">false</span>,</span><br><span class="line">                  color: Colors.grey)</span><br><span class="line">              ),</span><br><span class="line">            ],</span><br><span class="line">          )</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E4%B8%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/WeChatd910839e3ff49d0f3f1548df3adf920f.png?lastModify=1642479994" alt="WeChatd910839e3ff49d0f3f1548df3adf920f"></p>
<h5 id="3-1-5-字体"><a href="#3-1-5-字体" class="headerlink" title="3.1.5 字体"></a>3.1.5 字体</h5><p>pubspec.yaml 中声明</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">flutter:</span><br><span class="line">  fonts:</span><br><span class="line">    - family: Raleway</span><br><span class="line">      fonts:</span><br><span class="line">        - asset: assets/fonts/Raleway-Regular.ttf</span><br><span class="line">        - asset: assets/fonts/Raleway-Medium.ttf</span><br><span class="line">          weight: <span class="number">500</span></span><br><span class="line">        - asset: assets/fonts/Raleway-SemiBold.ttf</span><br><span class="line">          weight: <span class="number">600</span></span><br><span class="line">    - family: AbrilFatface</span><br><span class="line">      fonts:</span><br><span class="line">        - asset: assets/fonts/abrilfatface/AbrilFatface-Regular.ttf</span><br></pre></td></tr></table></figure>

<p>使用字体</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明文本样式</span></span><br><span class="line"><span class="keyword">const</span> textStyle = <span class="keyword">const</span> TextStyle(</span><br><span class="line">  fontFamily: <span class="string">&#x27;Raleway&#x27;</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用文本样式</span></span><br><span class="line"><span class="keyword">var</span> buttonText = <span class="keyword">const</span> Text(</span><br><span class="line">  <span class="string">&quot;Use the font for this text&quot;</span>,</span><br><span class="line">  style: textStyle,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="3-2-按钮"><a href="#3-2-按钮" class="headerlink" title="3.2 按钮"></a>3.2 按钮</h4><p>Material 库中的按钮，按下时都还有水波纹动画，就是点击按钮上会出现水波纹扩展动画</p>
<p>有一个 onPressed 属性来设置点击回调</p>
<p><img src="/../../../../../../%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E4%B8%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/WeChata1d3c6be4375dfacab4bffe55cf60aa5.png" alt="WeChata1d3c6be4375dfacab4bffe55cf60aa5"></p>
<ul>
<li>ElevatedButton</li>
</ul>
<p>漂浮按钮，默认带阴影和灰色背景，按下后阴影会变大</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ElevatedButton(</span><br><span class="line">    onPressed: ()&#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;onPressed&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    child: Text(<span class="string">&#x27;normal&#x27;</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>TextButton</li>
</ul>
<p>文本按钮，默认背景透明不带阴影，按下后会有背景色</p>
<ul>
<li>OutlineButton</li>
</ul>
<p>默认有一个灰色边框，不带阴影背景透明，按下后边框颜色变亮，同时出现背景和阴影</p>
<p>构造方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">const</span> OutlineButton(&#123;</span><br><span class="line">   Key key,</span><br><span class="line">   <span class="meta">@required</span> VoidCallback onPressed,</span><br><span class="line">   ButtonTextTheme textTheme,  <span class="comment">//按钮上字体主题</span></span><br><span class="line">   Color textColor,  <span class="comment">//字体颜色</span></span><br><span class="line">   Color disabledTextColor, <span class="comment">//按钮禁用时候文字的颜色</span></span><br><span class="line">   Color color,  <span class="comment">//按钮背景颜色</span></span><br><span class="line">   Color highlightColor,<span class="comment">//点击或者toch控件高亮的时候显示在控件上面，水波纹下面的颜色</span></span><br><span class="line">   Color splashColor, <span class="comment">//水波纹的颜色</span></span><br><span class="line">   <span class="built_in">double</span> highlightElevation,<span class="comment">//高亮时候的阴影</span></span><br><span class="line">   <span class="keyword">this</span>.borderSide,<span class="comment">//按钮边框</span></span><br><span class="line">   <span class="keyword">this</span>.disabledBorderColor, <span class="comment">//按钮禁用时边框的颜色</span></span><br><span class="line">   <span class="keyword">this</span>.highlightedBorderColor,<span class="comment">//高亮时边框的颜色</span></span><br><span class="line">   EdgeInsetsGeometry padding,<span class="comment">//边距</span></span><br><span class="line">   ShapeBorder shape, <span class="comment">//设置shape</span></span><br><span class="line">   Clip clipBehavior = Clip.none,</span><br><span class="line">   Widget child,</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>

<p>设置圆角和边框颜色</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">OutlineButton(</span><br><span class="line"> borderSide: BorderSide(color: Colors.red),</span><br><span class="line"> shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(<span class="number">20</span>)),</span><br><span class="line"> child: Text(<span class="string">&#x27;normal&#x27;</span>),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<ul>
<li>IconButton</li>
</ul>
<p>可点击 Icon，默认没有背景点击后出现背景</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">IconButton(</span><br><span class="line">     onPressed: ()&#123;</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;onPressed&#x27;</span>);</span><br><span class="line">     &#125;,</span><br><span class="line">     icon: Icon(Icons.thumb_up),</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>

<ul>
<li>带图标按钮</li>
</ul>
<p>ElevatedButton、OutlineButton、IconButton 都有一个 icon 构造函数，通过 icon 创建带图标按钮</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ElevatedButton.icon(</span><br><span class="line">   icon: Icon(Icons.send),</span><br><span class="line">   label: Text(<span class="string">&quot;发送&quot;</span>),</span><br><span class="line">   onPressed: _onPressed,</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>

<h4 id="3-3-图片及ICON"><a href="#3-3-图片及ICON" class="headerlink" title="3.3 图片及ICON"></a>3.3 图片及ICON</h4><h5 id="3-3-1-图片"><a href="#3-3-1-图片" class="headerlink" title="3.3.1 图片"></a>3.3.1 图片</h5><ul>
<li>asset 中加载图片</li>
</ul>
<p>根目录创建一个 images 目录，avata.png 拷贝到目录</p>
<p>pubspec.yaml 中的 flutter 部分添加内容</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">assets:</span><br><span class="line">	- images/avatar.png</span><br><span class="line">也可以</span><br><span class="line">	- images/</span><br></pre></td></tr></table></figure>

<p>加载图片</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Image(image: AssetImage(<span class="string">&#x27;images/avatar.png&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>也提供了快捷构造函数 Image.asset</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Image.asset(<span class="string">&#x27;images/avatar.png&#x27;</span>, width: <span class="number">100</span>,)</span><br></pre></td></tr></table></figure>

<ul>
<li>网络加载图片</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Image(image: NetworkImage(<span class="string">&#x27;https://xxxx&#x27;</span>), width: <span class="number">100</span>,)</span><br><span class="line">Image.network(<span class="string">&#x27;https://xxxx&#x27;</span>, width: <span class="number">100.0</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>Image 参数</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Image(&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">this</span>.width, <span class="comment">//图片的宽</span></span><br><span class="line">  <span class="keyword">this</span>.height, <span class="comment">//图片高度</span></span><br><span class="line">  <span class="keyword">this</span>.color, <span class="comment">//图片的混合色值</span></span><br><span class="line">  <span class="keyword">this</span>.colorBlendMode, <span class="comment">//混合模式</span></span><br><span class="line">  <span class="keyword">this</span>.fit,<span class="comment">//缩放模式</span></span><br><span class="line">  <span class="keyword">this</span>.alignment = Alignment.center, <span class="comment">//对齐方式</span></span><br><span class="line">  <span class="keyword">this</span>.repeat = ImageRepeat.noRepeat, <span class="comment">//重复方式</span></span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>width、height 设置图片宽高，不指定宽高时，图片会根据父容器的限制，尽可能显示原始大小，如果只设置一个，另一个属性会按比例缩放</p>
<p>fit：图片显示空间和图片大小不同时指定图片适应模式</p>
<p>fill 拉伸填充满显示空间，长宽比发生变化，图片会变形</p>
<p>cover 按图片长宽比放大后居中填充显示空间，图片不会变形，超出显示被裁剪</p>
<p>fit width 图片宽度缩放到显示空间宽度，高度按比例缩放，居中显示，图片不变形，超出显示被裁剪</p>
<p>fit height</p>
<p>none 没有适应策略，图片比显示空间达，则显示图片中间部分</p>
<p>repeat：图片大小小于显示空间时，指定图片重复规则</p>
<img src="《Flutter实战第二版》三：基础组件/WeChatfd803adaf46878bf208e18fb3907acc4.png" alt="WeChatfd803adaf46878bf208e18fb3907acc4" style="zoom:80%;" />

<h5 id="3-3-2-iconfont"><a href="#3-3-2-iconfont" class="headerlink" title="3.3.2 iconfont"></a>3.3.2 iconfont</h5><p>Flutter 默认包含了一套 Material Design 的字体图标，是将图标做成字体文件，通过指定不同字符显示不同图片</p>
<p>在 pubspec.yaml 中配置</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">flutter:</span><br><span class="line">  users-material-design: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>Material Design 所有图标可以在官网查看 <a href="https://material.io/tools/icons/">https://material.io/tools/icons/</a></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> icons = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">// accessible: 0xe03e</span></span><br><span class="line">icons += <span class="string">&quot;\uE03e&quot;</span>;</span><br><span class="line"><span class="comment">// error:  0xe237</span></span><br><span class="line">icons += <span class="string">&quot; \uE237&quot;</span>;</span><br><span class="line"><span class="comment">// fingerprint: 0xe287</span></span><br><span class="line">icons += <span class="string">&quot; \uE287&quot;</span>;</span><br><span class="line"></span><br><span class="line">Text(</span><br><span class="line">  icons,</span><br><span class="line">  style: TextStyle(</span><br><span class="line">    fontFamily: <span class="string">&quot;MaterialIcons&quot;</span>,</span><br><span class="line">    fontSize: <span class="number">24.0</span>,</span><br><span class="line">    color: Colors.green,</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Flutter 封装了 IconData 和 Icon 来专门显示字体图标</p>
<p>icons 类中包含了所有 Material Design 图标的 IconData 静态变量定义</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Row(</span><br><span class="line">   mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">   children: &lt;Widget&gt;[</span><br><span class="line">     Icon(MyIcons.book,color: Colors.purple),</span><br><span class="line">     Icon(MyIcons.wechat,color: Colors.green),</span><br><span class="line">   ],</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>



<ul>
<li>使用自定义字体图标 </li>
</ul>
<p>导入字体图标文件</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">fonts:</span><br><span class="line">  - family: myIcon  #指定一个字体名</span><br><span class="line">    fonts:</span><br><span class="line">      - asset: fonts/iconfont.ttf</span><br></pre></td></tr></table></figure>

<p>为了使用方便，定义 MyIcons 类，将字体文件中的所有图标都定义成静态变量</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIcons</span></span>&#123;</span><br><span class="line">  <span class="comment">// book 图标</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> IconData book = <span class="keyword">const</span> IconData(</span><br><span class="line">      <span class="number">0xe614</span>, </span><br><span class="line">      fontFamily: <span class="string">&#x27;myIcon&#x27;</span>, </span><br><span class="line">      matchTextDirection: <span class="keyword">true</span></span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 微信图标</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> IconData wechat = <span class="keyword">const</span> IconData(</span><br><span class="line">      <span class="number">0xec7d</span>,  </span><br><span class="line">      fontFamily: <span class="string">&#x27;myIcon&#x27;</span>, </span><br><span class="line">      matchTextDirection: <span class="keyword">true</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-单选开关和复选框"><a href="#3-4-单选开关和复选框" class="headerlink" title="3.4 单选开关和复选框"></a>3.4 单选开关和复选框</h4><p>它们本身不会保存当前选中状态</p>
<p><img src="/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E4%B8%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/WeChate24ea09c0c08061e88779c644b095b75.png?lastModify=1642479994" alt="WeChate24ea09c0c08061e88779c644b095b75"></p>
<p>都有个 activeColor 属性设置激活态颜色</p>
<p>Checkbox 大小固定，无法自定义</p>
<p>Switch 只能自定宽度，高度固定</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">bool</span> _switchSelected=<span class="keyword">true</span>; <span class="comment">//维护单选开关状态</span></span><br><span class="line"> <span class="built_in">bool</span> _checkboxSelected=<span class="keyword">true</span>;<span class="comment">//维护复选框状态</span></span><br><span class="line"> Switch(</span><br><span class="line"> value: _switchSelected,</span><br><span class="line"> onChanged: (value)&#123;</span><br><span class="line">   setState(() &#123;</span><br><span class="line">     _switchSelected = value;</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;),</span><br><span class="line">Checkbox(</span><br><span class="line"> value: _checkboxSelected,</span><br><span class="line"> onChanged: (value)&#123;</span><br><span class="line">   setState(() &#123;</span><br><span class="line">     _checkboxSelected = value ?? <span class="keyword">false</span>;</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;),</span><br></pre></td></tr></table></figure>

<h4 id="3-5-输入框及表单"><a href="#3-5-输入框及表单" class="headerlink" title="3.5 输入框及表单"></a>3.5 输入框及表单</h4><h5 id="3-5-1-输入框-TextField"><a href="#3-5-1-输入框-TextField" class="headerlink" title="3.5.1 输入框 TextField"></a>3.5.1 输入框 TextField</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TextField(&#123;</span><br><span class="line">   Key key,</span><br><span class="line">   <span class="keyword">this</span>.controller,           <span class="comment">//控制器，控制TextField文字</span></span><br><span class="line">   <span class="keyword">this</span>.focusNode, <span class="comment">//控制textField是否占有当前键盘的输入焦点</span></span><br><span class="line">   <span class="keyword">this</span>.decoration = <span class="keyword">const</span> InputDecoration(),    <span class="comment">//输入器装饰</span></span><br><span class="line">   TextInputType keyboardType,   <span class="comment">//输入的类型</span></span><br><span class="line">   <span class="keyword">this</span>.textInputAction,  <span class="comment">//键盘回车键图标</span></span><br><span class="line">   <span class="keyword">this</span>.textCapitalization = TextCapitalization.none,</span><br><span class="line">   <span class="keyword">this</span>.style,</span><br><span class="line">   <span class="keyword">this</span>.textAlign = TextAlign.start,   <span class="comment">//文字显示位置</span></span><br><span class="line">   <span class="keyword">this</span>.autofocus = <span class="keyword">false</span>, <span class="comment">//是否自动获取焦点</span></span><br><span class="line">   <span class="keyword">this</span>.obscureText = <span class="keyword">false</span>, <span class="comment">//是否*号显示</span></span><br><span class="line">   <span class="keyword">this</span>.autocorrect = <span class="keyword">true</span>,</span><br><span class="line">   <span class="keyword">this</span>.maxLines = <span class="number">1</span>,</span><br><span class="line">   <span class="keyword">this</span>.maxLength, <span class="comment">//文本框最大长度，设置后输入框右下角会显示输入的文本计数</span></span><br><span class="line">   <span class="keyword">this</span>.maxLengthEnforced = <span class="keyword">true</span>,</span><br><span class="line">   <span class="keyword">this</span>.onChanged,                <span class="comment">//文字改变触发</span></span><br><span class="line">   <span class="keyword">this</span>.onEditingComplete,   <span class="comment">//当用户提交可编辑内容时调用</span></span><br><span class="line">   <span class="keyword">this</span>.onSubmitted,   <span class="comment">////<span class="markdown">文字提交触发（键盘按键）</span></span></span><br><span class="line">   <span class="keyword">this</span>.inputFormatters, <span class="comment">//指定输入格式，输入内容改变时，会根据指定格式校验</span></span><br><span class="line">   <span class="keyword">this</span>.enabled,</span><br><span class="line">   <span class="keyword">this</span>.cursorWidth = <span class="number">2.0</span>, <span class="comment">//输入光标宽度</span></span><br><span class="line">   <span class="keyword">this</span>.cursorRadius,    <span class="comment">//输入光标圆角  </span></span><br><span class="line">   <span class="keyword">this</span>.cursorColor,   <span class="comment">//输入光标颜色</span></span><br><span class="line">   <span class="keyword">this</span>.keyboardAppearance,</span><br><span class="line">   <span class="keyword">this</span>.scrollPadding = <span class="keyword">const</span> EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<p>controller 编辑框的控制器，通过它可以设置/获取编辑框的内容、选择编辑内容、监听文本改变事件。</p>
<p>focusNode 用于控制 TextField 是否占有当前键盘的输入焦点</p>
<p>decoration 用于控制 TextField 的外观显示，如提示文本、背景颜色、边框</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">FocusNode focusNode1 = FocusNode();</span><br><span class="line">FocusNode focusNode2 = FocusNode();</span><br><span class="line">FocusScopeNode? focusScopeNode;</span><br><span class="line"></span><br><span class="line">body: Center(</span><br><span class="line">  child: Column(</span><br><span class="line">    children: [</span><br><span class="line">      TextField(</span><br><span class="line">        autofocus: <span class="keyword">true</span>,</span><br><span class="line">        focusNode: focusNode1,</span><br><span class="line">        controller: _unameController,</span><br><span class="line">        decoration: InputDecoration(</span><br><span class="line">          labelText: <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">          hintText: <span class="string">&#x27;用户名或邮箱&#x27;</span>,</span><br><span class="line">          prefixIcon: Icon(Icons.person),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      TextField(</span><br><span class="line">        focusNode: focusNode2,</span><br><span class="line">        decoration: InputDecoration(</span><br><span class="line">          labelText: <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">          hintText: <span class="string">&#x27;登录密码&#x27;</span>,</span><br><span class="line">          prefixIcon: Icon(Icons.lock),</span><br><span class="line">        ),</span><br><span class="line">        obscureText: <span class="keyword">true</span>,</span><br><span class="line">      ),</span><br><span class="line">      ElevatedButton(</span><br><span class="line">        onPressed: ()&#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">null</span> == focusScopeNode) &#123;</span><br><span class="line">            focusScopeNode = FocusScope.of(context);</span><br><span class="line">          &#125;</span><br><span class="line">          focusScopeNode!.requestFocus(focusNode2);</span><br><span class="line">        &#125;,</span><br><span class="line">        child: Text(<span class="string">&#x27;移动焦点&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line">      ElevatedButton(</span><br><span class="line">        onPressed: ()&#123;</span><br><span class="line">          focusNode1.unfocus();</span><br><span class="line">          focusNode2.unfocus();</span><br><span class="line">        &#125;,</span><br><span class="line">        child: Text(<span class="string">&#x27;隐藏键盘&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line">    ],</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>



<p><img src="/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E4%B8%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/WeChatce892753a9d9210783f5c2d69dadd941.png?lastModify=1642479994" alt="WeChatce892753a9d9210783f5c2d69dadd941"></p>
<ul>
<li>获取输入内容</li>
</ul>
<p>定义一个 controller</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextEditingController _unameController = TextEditingController();</span><br></pre></td></tr></table></figure>

<p>设置输入 controller</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextField(</span><br><span class="line">    autofocus: <span class="keyword">true</span>,</span><br><span class="line">    controller: _unameController,</span><br></pre></td></tr></table></figure>

<p>通过 onChange 回调获取输入内容</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextField(</span><br><span class="line">    autofocus: <span class="keyword">true</span>,</span><br><span class="line">    onChanged: (v) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;onChange: <span class="subst">$v</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>通过 controller 监听获取输入的内容</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> initState() &#123;</span><br><span class="line">  <span class="keyword">super</span>.initState();</span><br><span class="line">  _unameController.addListener(() &#123;</span><br><span class="line">    <span class="built_in">print</span>(_unameController.text);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onChange 是专门用于监听文本变化</p>
<p>controller 还可以设置默认值、选择文本</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_selectionController.text=<span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">_selectionController.selection=TextSelection(</span><br><span class="line">    baseOffset: <span class="number">2</span>,</span><br><span class="line">    extentOffset: _selectionController.text.length</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>控制焦点</li>
</ul>
<p>通过 FocusScopeNode 在输入框之间移动焦点、设置默认焦点</p>
<p>通过 FocusScope.of(context) 获取 Widget 树中默认的 FocusScopeNode</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">FocusScopeNode? focusScopeNode;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == focusScopeNode) &#123;</span><br><span class="line">  focusScopeNode = FocusScope.of(context);</span><br><span class="line">&#125;</span><br><span class="line">focusScopeNode!.requestFocus(focusNode2); <span class="comment">//移动焦点</span></span><br></pre></td></tr></table></figure>

<ul>
<li>监听焦点改变事件</li>
</ul>
<p>获取到焦点时 focusNode.hasFocus 为 true 失去焦点时为 false</p>
<p>FocusNode 继承自 ChangeNotifier，通过 FocusNode 可以监听焦点的改变</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//隐藏键盘</span></span><br><span class="line">focusNode1.unfocus();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 创建 focusNode   </span></span><br><span class="line">FocusNode focusNode = FocusNode();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// focusNode绑定输入框   </span></span><br><span class="line">TextField(focusNode: focusNode);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 监听焦点变化    </span></span><br><span class="line">focusNode.addListener(()&#123;</span><br><span class="line">   <span class="built_in">print</span>(focusNode.hasFocus);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义样式</li>
</ul>
<p>分别设置输入框未获得和获得焦点下划线颜色</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">decoration: InputDecoration(</span><br><span class="line">  labelText: <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  hintText: <span class="string">&#x27;用户名或邮箱&#x27;</span>,</span><br><span class="line">  prefixIcon: Icon(Icons.person),</span><br><span class="line">  enabledBorder: UnderlineInputBorder( <span class="comment">//未获得焦点下划线颜色</span></span><br><span class="line">    borderSide: BorderSide(color: Colors.red),</span><br><span class="line">  ),</span><br><span class="line">  focusedBorder: UnderlineInputBorder( <span class="comment">//获得焦点下划线颜色</span></span><br><span class="line">    borderSide: BorderSide(color: Colors.yellow),</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<p>通过主题自定义输入框样式</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Theme(</span><br><span class="line">  data: Theme.of(context).copyWith(</span><br><span class="line">      hintColor: Colors.grey[<span class="number">200</span>], <span class="comment">//定义下划线颜色</span></span><br><span class="line">      inputDecorationTheme: InputDecorationTheme(</span><br><span class="line">          labelStyle: TextStyle(color: Colors.grey),<span class="comment">//定义label字体样式</span></span><br><span class="line">          hintStyle: TextStyle(color: Colors.grey, fontSize: <span class="number">14.0</span>)<span class="comment">//定义提示文本样式</span></span><br><span class="line">      )</span><br><span class="line">  ),</span><br></pre></td></tr></table></figure>

<p>另一种灵活的方式是直接隐藏 TextField 本身的下划线，通过 Container 去嵌套定义样式</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Container(</span><br><span class="line">  child: TextField(</span><br><span class="line">    keyboardType: TextInputType.emailAddress,</span><br><span class="line">    decoration: InputDecoration(</span><br><span class="line">        labelText: <span class="string">&quot;Email&quot;</span>,</span><br><span class="line">        hintText: <span class="string">&quot;电子邮件地址&quot;</span>,</span><br><span class="line">        prefixIcon: Icon(Icons.email),</span><br><span class="line">        border: InputBorder.none <span class="comment">//隐藏下划线</span></span><br><span class="line">    )</span><br><span class="line">  ),</span><br><span class="line">  decoration: BoxDecoration(</span><br><span class="line">      <span class="comment">// 下滑线浅灰色，宽度1像素</span></span><br><span class="line">      border: Border(bottom: BorderSide(color: Colors.grey[<span class="number">200</span>], width: <span class="number">1.0</span>))</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="3-5-2-表单-Form"><a href="#3-5-2-表单-Form" class="headerlink" title="3.5.2 表单 Form"></a>3.5.2 表单 Form</h5><ul>
<li>Form</li>
</ul>
<p>可以对输入框进行分组，然后进行统一操作</p>
<p>Form 类的定义 </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Form(&#123;</span><br><span class="line">  <span class="keyword">required</span> Widget child,</span><br><span class="line">  <span class="built_in">bool</span> autovalidate = <span class="keyword">false</span>,</span><br><span class="line">  WillPopCallback onWillPop,</span><br><span class="line">  VoidCallback onChanged,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>autovalidate 是否自动校验输入内容，为 true 时，每个 FormField 内容变化时自动校验合法性，显示错误信息，否则需要通过调用 FormState.validate() 来手动校验</p>
<p>onWillPop 决定 Form 所在路由是否可以直接返回，通常用于拦截返回按钮</p>
<p>onChanged： Form 任意一个子 FormField 内容发生改变时触发回调</p>
<ul>
<li>FormField</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FormField(&#123;</span><br><span class="line">   ...</span><br><span class="line">   FormFieldSetter&lt;T&gt; onSaved, <span class="comment">//保存回调</span></span><br><span class="line">   FormFieldValidator&lt;T&gt;  validator, <span class="comment">//验证回调</span></span><br><span class="line">   T initialValue, <span class="comment">//初始值</span></span><br><span class="line">   <span class="built_in">bool</span> autovalidate = <span class="keyword">false</span>, <span class="comment">//是否自动校验。</span></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<p>Form 的子孙元素必须是 FormField 类型</p>
<p>为了使用方便，Flutter 提供了一个 TextFormField</p>
<ul>
<li>FormState</li>
</ul>
<p>FormState 为 Form 的State 类，可以通过 Form.of(context) 或 GlobalKey 获得，可以通过它来对 Form 的子孙 FormField 进行统一操作</p>
<p>FormState.validate()：调用后，会调用 Form 子孙 FormField 的 validate 回调，有一个校验失败返回 false</p>
<p>FormState.save()：会调用 Form 子孙 FormField 的 save 回调，用于保存表单内容</p>
<p>FormState.reset()：会将子孙 FormField 的内容清空</p>
<ul>
<li>示例</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">void</span> main() &#123;</span><br><span class="line">   runApp(MaterialApp(home: FormTestRoute()));</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">FormTestRoute</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line">   _FormTestRouteState createState() =&gt; _FormTestRouteState();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">_FormTestRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">FormTestRoute</span>&gt; </span>&#123;</span><br><span class="line">   TextEditingController _unameController = TextEditingController();</span><br><span class="line">   TextEditingController _pwdController   = TextEditingController();</span><br><span class="line">   GlobalKey _formKey = GlobalKey&lt;FormState&gt;();</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line">   <span class="keyword">void</span> initState() &#123;</span><br><span class="line">     <span class="keyword">super</span>.initState();</span><br><span class="line"> </span><br><span class="line">     _unameController.addListener(() &#123;</span><br><span class="line">       <span class="built_in">print</span>(_unameController.text);</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line">   Widget build(BuildContext context) &#123;</span><br><span class="line">     <span class="keyword">return</span> Scaffold(</span><br><span class="line">       appBar: AppBar(</span><br><span class="line">         title: Text(<span class="string">&#x27;标题&#x27;</span>),</span><br><span class="line">       ),</span><br><span class="line">       body: Form(</span><br><span class="line">         key: _formKey,<span class="comment">//设置 globalkey</span></span><br><span class="line">         child: Column(</span><br><span class="line">           children: [</span><br><span class="line">             TextFormField(</span><br><span class="line">               autofocus: <span class="keyword">true</span>,</span><br><span class="line">               controller: _unameController,</span><br><span class="line">               decoration: InputDecoration(</span><br><span class="line">                 labelText: <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">                 hintText: <span class="string">&#x27;用户名或邮箱&#x27;</span>,</span><br><span class="line">                 prefixIcon: Icon(Icons.person),</span><br><span class="line">               ),</span><br><span class="line">               <span class="comment">//校验用户名</span></span><br><span class="line">               validator: (v)&#123;</span><br><span class="line">                 <span class="keyword">return</span> v!.trim().length &gt; <span class="number">0</span> ? <span class="keyword">null</span> : <span class="string">&#x27;用户名不能为空&#x27;</span>;</span><br><span class="line">               &#125;,</span><br><span class="line">             ),</span><br><span class="line">             TextFormField(</span><br><span class="line">               decoration: InputDecoration(</span><br><span class="line">                 labelText: <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">                 hintText: <span class="string">&#x27;登录密码&#x27;</span>,</span><br><span class="line">                 prefixIcon: Icon(Icons.lock),</span><br><span class="line">               ),</span><br><span class="line">               obscureText: <span class="keyword">true</span>,</span><br><span class="line">               <span class="comment">//校验密码</span></span><br><span class="line">               validator: (v)&#123;</span><br><span class="line">                 <span class="keyword">return</span> v!.trim().length &gt; <span class="number">0</span> ? <span class="keyword">null</span> : <span class="string">&#x27;密码不能为空&#x27;</span>;</span><br><span class="line">               &#125;,</span><br><span class="line">             ),</span><br><span class="line">             Padding(</span><br><span class="line">                 padding: EdgeInsets.only(top: <span class="number">20</span>),</span><br><span class="line">                 child: Row(</span><br><span class="line">                   children: [</span><br><span class="line">                     Expanded(</span><br><span class="line">                         child: ElevatedButton(</span><br><span class="line">                           child: Padding(</span><br><span class="line">                             padding: EdgeInsets.all(<span class="number">16</span>),</span><br><span class="line">                             child: Text(<span class="string">&#x27;登录&#x27;</span>),</span><br><span class="line">                           ),</span><br><span class="line">                           onPressed: ()&#123;</span><br><span class="line">                             <span class="comment">// 通过_formKey.currentState 获取FormState后，</span></span><br><span class="line">                             <span class="comment">// 调用validate()方法校验用户名密码是否合法，校验</span></span><br><span class="line">                             <span class="comment">// 通过后再提交数据。</span></span><br><span class="line">                             <span class="keyword">if</span> ((_formKey.currentState <span class="keyword">as</span> FormState).validate()) &#123;</span><br><span class="line">                               <span class="built_in">print</span>(<span class="string">&#x27;通过校验&#x27;</span>);</span><br><span class="line">                             &#125;</span><br><span class="line">                           &#125;,</span><br><span class="line">                         ),</span><br><span class="line">                     ),</span><br><span class="line">                   ],</span><br><span class="line">                 ),</span><br><span class="line">             ),</span><br><span class="line">           ],</span><br><span class="line">         ),</span><br><span class="line">       ),</span><br><span class="line">     );</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E4%B8%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/WeChat803de70354088ea04b9983c0a122d48b.png?lastModify=1642479994" alt="WeChat803de70354088ea04b9983c0a122d48b"></p>
<p>此处登录按钮的 onPressed 方法不能通过 Form.of(context) 来获取，这边的context是 FormTestRoute 的context</p>
<p>Form.of(context) 是根据所指定的 context 向根去查找，FormState 是在FormTestRoute的子树中所以不行 </p>
<p>可以通过 Builder 来构建登录按钮，Builder 会将 Widget 节点的context 作为回调参数</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Expanded(</span><br><span class="line"> <span class="comment">// 通过Builder来获取ElevatedButton所在widget树的真正context(Element) </span></span><br><span class="line">  child:Builder(builder: (context)&#123;</span><br><span class="line">    <span class="keyword">return</span> ElevatedButton(</span><br><span class="line">      ...</span><br><span class="line">      onPressed: () &#123;</span><br><span class="line">        <span class="comment">//由于本widget也是Form的子代widget，所以可以通过下面方式获取FormState  </span></span><br><span class="line">        <span class="keyword">if</span>(Form.of(context).validate())&#123;</span><br><span class="line">          <span class="comment">//验证通过提交数据</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="3-6-进度指示器"><a href="#3-6-进度指示器" class="headerlink" title="3.6 进度指示器"></a>3.6 进度指示器</h4><ul>
<li>LinearProgressIndicator</li>
</ul>
<p>线性条状进度条</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">LinearProgressIndicator(&#123;</span><br><span class="line">  <span class="built_in">double</span> value,</span><br><span class="line">  Color backgroundColor,</span><br><span class="line">  Animation&lt;Color&gt; valueColor,</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>value：当前进度，取值 [0,1]，value 为 null 会执行一个循环动画，不为 null 时为一个具体进度的进度条</p>
<p>valueColor：进度条颜色，类型 <code>Animation&lt;Color&gt;</code>，允许对进度条颜色指定动画，如果使用固定颜色使用 AlwaysStoppedAnimation 来指定</p>
<ul>
<li>CircularProgressIndicator</li>
</ul>
<p>圆形进度条</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"> CircularProgressIndicator(&#123;</span><br><span class="line">  <span class="built_in">double</span> value,</span><br><span class="line">  Color backgroundColor,</span><br><span class="line">  Animation&lt;Color&gt; valueColor,</span><br><span class="line">  <span class="keyword">this</span>.strokeWidth = <span class="number">4.0</span>,</span><br><span class="line">  ...   </span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>

<p>strokeWidth 圆形进度条的粗细</p>
<ul>
<li>示例</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">LinearProgressIndicator(</span><br><span class="line">  backgroundColor: Colors.grey[<span class="number">200</span>],</span><br><span class="line">  valueColor: AlwaysStoppedAnimation(Colors.blue),</span><br><span class="line">  value: <span class="number">.5</span>,</span><br><span class="line">),</span><br><span class="line">CircularProgressIndicator(</span><br><span class="line">  backgroundColor: Colors.grey[<span class="number">200</span>],</span><br><span class="line">  valueColor: AlwaysStoppedAnimation(Colors.blue),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义尺寸</li>
</ul>
<p>CircularProgressIndicator 和 LinearProgressIndicator 都是取父容器的尺寸作为绘制边界的，可以通过尺寸限制 Widget，如 ConstrainedBox、SizedBox</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线性进度条高度指定为3</span></span><br><span class="line">SizedBox(</span><br><span class="line">  height: <span class="number">3</span>,</span><br><span class="line">  child: LinearProgressIndicator(</span><br><span class="line">    backgroundColor: Colors.grey[<span class="number">200</span>],</span><br><span class="line">    valueColor: AlwaysStoppedAnimation(Colors.blue),</span><br><span class="line">    value: <span class="number">.5</span>,</span><br><span class="line">  ),</span><br><span class="line">),</span><br><span class="line"><span class="comment">// 圆形进度条直径指定为100</span></span><br><span class="line">SizedBox(</span><br><span class="line">  height: <span class="number">100</span>,</span><br><span class="line">  width: <span class="number">100</span>,</span><br><span class="line">  child: CircularProgressIndicator(</span><br><span class="line">    backgroundColor: Colors.grey[<span class="number">200</span>],</span><br><span class="line">    valueColor: AlwaysStoppedAnimation(Colors.blue),</span><br><span class="line">    value: <span class="number">.7</span>,</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<ul>
<li><p>进度色动画</p>
</li>
<li><p>自定义进度指示器样式</p>
</li>
</ul>
<p>可以通过 CustomPainter Widge 来自定义绘制逻辑</p>
]]></content>
  </entry>
  <entry>
    <title>《Flutter实战第二版》二：第一个Flutter应用</title>
    <url>/2022/01/18/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E4%BA%8C%EF%BC%9A%E7%AC%AC%E4%B8%80%E4%B8%AAFlutter%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h3 id="2-第一个-Flutter-应用"><a href="#2-第一个-Flutter-应用" class="headerlink" title="2 第一个 Flutter 应用"></a>2 第一个 Flutter 应用</h3><h4 id="2-1-计数器应用"><a href="#2-1-计数器应用" class="headerlink" title="2.1 计数器应用"></a>2.1 计数器应用</h4><h5 id="2-1-1-创建-Flutter-应用模板"><a href="#2-1-1-创建-Flutter-应用模板" class="headerlink" title="2.1.1 创建 Flutter 应用模板"></a>2.1.1 创建 Flutter 应用模板</h5><p>Android Studio 创建新的 Flutter 工程得到一个计数器应用 Demo</p>
<img src="《Flutter实战第二版》二：第一个Flutter应用/WeChatb18a46cb6a1321d33b71401d68d6e8ba.png" alt="WeChatb18a46cb6a1321d33b71401d68d6e8ba" style="zoom:50%;" />

<p>示例主要 Dart 代码在 lib/main.dart 文件中，源码</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123; runApp(<span class="keyword">const</span> MyApp()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MyApp(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      home: <span class="keyword">const</span> MyHomePage(title: <span class="string">&#x27;Flutter Demo Home Page&#x27;</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MyHomePage(&#123;Key? key, <span class="keyword">required</span> <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;MyHomePage&gt; createState() =&gt; _MyHomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">void</span> _incrementCounter() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _counter++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            <span class="keyword">const</span> Text(</span><br><span class="line">              <span class="string">&#x27;You have pushed the button this many times:&#x27;</span>,</span><br><span class="line">            ),</span><br><span class="line">            Text(</span><br><span class="line">              <span class="string">&#x27;<span class="subst">$_counter</span>&#x27;</span>,</span><br><span class="line">              style: Theme.of(context).textTheme.headline4,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: _incrementCounter,</span><br><span class="line">        tooltip: <span class="string">&#x27;Increment&#x27;</span>,</span><br><span class="line">        child: <span class="keyword">const</span> Icon(Icons.add),</span><br><span class="line">      ), <span class="comment">// This trailing comma makes auto-formatting nicer for build methods.</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>分析</li>
</ul>
<ol>
<li>导入包</li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>导入了 Material UI 组件库，Material 是一种标准的移动端和web端视觉设计语言，Flutter 默认提供了一套丰富的 Material 风格的 UI 组件</p>
<ol start="2">
<li>应用的入口</li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123; runApp(<span class="keyword">const</span> MyApp()); &#125;</span><br></pre></td></tr></table></figure>

<p>man 函数为应用程序入口，main 函数调用了 runApp 方法，它的功能是启动 Flutter 应用，runApp 接受一个 Widget 参数，本示例中它是一个 MyApp 对象， MyApp() 是 Flutter 应用的根组件</p>
<ol start="3">
<li>应用结构</li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MyApp(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primarySwatch: Colors.blue,<span class="comment">//蓝色主题</span></span><br><span class="line">      ),</span><br><span class="line">      home: <span class="keyword">const</span> MyHomePage(title: <span class="string">&#x27;Flutter Demo Home Page&#x27;</span>),<span class="comment">//应用首页路由</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyApp 类代表 Flutter 应用，继承了 StatelessWidget 类，意味着应用本身也是一个 widget</p>
<p>Flutter 中大多数东西都是 widget，包括对齐(Align)、填充(Padding)、手势处理(GestureDetector)等，都是以 widget 的形式提供</p>
<p>Flutter 构建页面时，会调用组件 build 方法，widget 的主要工作是提供一个 build() 方法来描述如何构建 UI 界面(通常是组合、拼装其它基础 widget)</p>
<p>MaterialAPP 是 Material 库中提供的 Flutter APP 框架，通过它可以设置应用的名称、主题、首页及路由列表，MaterialAPP 也是一个 widget</p>
<p>home 为 Flutter 应用首页，也是一个 widget</p>
<h5 id="2-1-2-首页"><a href="#2-1-2-首页" class="headerlink" title="2.1.2 首页"></a>2.1.2 首页</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MyHomePage(&#123;Key? key, <span class="keyword">required</span> <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;MyHomePage&gt; createState() =&gt; _MyHomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyHomePage 应用首页 继承自 StatefulWidget 类，表示它是一个有状态的组件</p>
<p>StatefulWidget 至少由两个类组成：</p>
<p>一个 StatefulWidget 类；一个 State 类；StatefulWidget 类本身是不变的，State 类持有的状态在 widget 生命周期中可能发生变化</p>
<ul>
<li>State 类</li>
</ul>
<p>_MyHomePageState 类包含</p>
<ol>
<li>该组件的状态，这里只需要维护一个点击次数的计数器，所以定义一个 _counter</li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> _counter = <span class="number">0</span>;<span class="comment">//记录按钮点击次数</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置状态的自增函数</li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _incrementCounter() &#123;</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    _counter++;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按钮点击时会调用此函数，该函数作用是先自增 _counter，然后调用 setState 方法，setState 方法作用是通知 Flutter 框架，有状态发生了改变，Flutter 框架收到通知后，会执行 build 方法来跟进新的状态重新构建界面</p>
<ol start="3">
<li>构建 UI 界面</li>
</ol>
<p>构建 UI 界面在 build 方法中，MyHomePage 第一次创建时，_MyHomePageState 类会被创建，Flutter 框架会调用 widget 的 build 方法来构建 widget 树</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> Scaffold(</span><br><span class="line">    appBar: AppBar(</span><br><span class="line">      title: Text(widget.title),</span><br><span class="line">    ),</span><br><span class="line">    body: Center(</span><br><span class="line">      child: Column(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          <span class="keyword">const</span> Text(</span><br><span class="line">            <span class="string">&#x27;You have pushed the button this many times:&#x27;</span>,</span><br><span class="line">          ),</span><br><span class="line">          Text(</span><br><span class="line">            <span class="string">&#x27;<span class="subst">$_counter</span>&#x27;</span>,</span><br><span class="line">            style: Theme.of(context).textTheme.headline4,</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">    floatingActionButton: FloatingActionButton(</span><br><span class="line">      onPressed: _incrementCounter,</span><br><span class="line">      tooltip: <span class="string">&#x27;Increment&#x27;</span>,</span><br><span class="line">      child: <span class="keyword">const</span> Icon(Icons.add),</span><br><span class="line">    ), <span class="comment">// This trailing comma makes auto-formatting nicer for build methods.</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Scaffold 是 Material 库中提供的页面脚手架，提供了默认的导航栏、标题、和包含主屏幕 widget 树的body 属性，路由默认都是通过 Scaffold 创建</p>
<p>body 组件中包含了一个 Center 组件，Center 组件可以将子组件对齐到屏幕中心</p>
<p>Center 的子组件是一个 Column 组件，Column 作用是将其所有子组件沿屏幕垂直方向依次排列</p>
<p>floatingActionButton 页面右下角带+号的悬浮按钮，它的 onPressed 属性接受一个回调函数</p>
<h4 id="2-2-Widget"><a href="#2-2-Widget" class="headerlink" title="2.2 Widget"></a>2.2 Widget</h4><h5 id="2-2-1-Widget-概念"><a href="#2-2-1-Widget-概念" class="headerlink" title="2.2.1 Widget 概念"></a>2.2.1 Widget 概念</h5><p>Flutter 中是通过 Widget 嵌套 Widget 的方式来构建 UI 和进行实践处理的，Flutter中万物皆为 Widget</p>
<h5 id="2-2-2-StatelessWidget"><a href="#2-2-2-StatelessWidget" class="headerlink" title="2.2.2 StatelessWidget"></a>2.2.2 StatelessWidget</h5><p>StatelessWidget 用于不需要维护状态的场景，通常在 build 方法中通过嵌套其它 widget 来构建UI</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Echo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Echo(&#123;</span><br><span class="line">    Key? key,  </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.text,</span><br><span class="line">    <span class="keyword">this</span>.backgroundColor = Colors.grey, <span class="comment">//默认为灰色</span></span><br><span class="line">  &#125;):<span class="keyword">super</span>(key:key);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> text;</span><br><span class="line">  <span class="keyword">final</span> Color backgroundColor;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: Container(</span><br><span class="line">        color: backgroundColor,</span><br><span class="line">        child: Text(text),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在继承 widget 时，第一个参数通常应该是 key，按照惯例，widget 的属性应尽可能的被声明为 final</p>
<p>使用</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> Echo(text: <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Context</li>
</ul>
<p>build 方法中有一个 context 参数，是BuildContext 类的一个实例，表示当前 widget 在 widget 树中的上下文，每个 widget 都会对应一个 context 对象</p>
<p>提供了从当前 widget 开始向上遍历 widget 树以及按照 widget 类型查找父级 widget 的方法</p>
<p>从子树中获取父级 widget 的示例</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span>  </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&quot;Context测试&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Container(</span><br><span class="line">        child: Builder(builder: (context) &#123;</span><br><span class="line">          <span class="comment">// 在 widget 树中向上查找最近的父级`Scaffold`  widget </span></span><br><span class="line">          Scaffold scaffold = context.findAncestorWidgetOfExactType&lt;Scaffold&gt;();</span><br><span class="line">          <span class="comment">// 直接返回 AppBar的title， 此处实际上是Text(&quot;Context测试&quot;)</span></span><br><span class="line">          <span class="keyword">return</span> (scaffold.appBar <span class="keyword">as</span> AppBar).title;</span><br><span class="line">        &#125;),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-3-StatefulWidget"><a href="#2-2-3-StatefulWidget" class="headerlink" title="2.2.3 StatefulWidget"></a>2.2.3 StatefulWidget</h5><p>继承自 widget 类，重写了 createElement() 方法，添加了一个新的接口 createState()</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StatefulWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> StatefulWidget(&#123; Key key &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  StatefulElement createElement() =&gt; StatefulElement(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  State createState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-4-State"><a href="#2-2-4-State" class="headerlink" title="2.2.4 State"></a>2.2.4 State</h5><p>一个 StatefulWidget 类会对应一个 State 类，State表示与其对应的 StatefulWidget 要维护的状态</p>
<p>当State被改变时，可以手动调用其 setState() 方法通知Flutter 框架状态发生改变，Flutter 框架在收到消息后，会重新调用其 build 方法重新构建 widget 树，从而达到更新UI的目的</p>
<p>State 中有两个常用属性 widget、context</p>
<h5 id="2-2-5-从-widget-树中获取-State-对象"><a href="#2-2-5-从-widget-树中获取-State-对象" class="headerlink" title="2.2.5 从 widget 树中获取 State 对象"></a>2.2.5 从 widget 树中获取 State 对象</h5><p>context 对象有一个 findAncestorStateOfType() 方法，该方法可以从当前节点沿着 widget 树向上查找指定类型的 StatefulWidget 对应的 state 对象</p>
<p>通过context获取</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找父级最近的Scaffold对应的ScaffoldState对象</span></span><br><span class="line">ScaffoldState _state = context.findAncestorStateOfType&lt;ScaffoldState&gt;()!;</span><br><span class="line"><span class="comment">// 打开抽屉菜单</span></span><br><span class="line">_state.openDrawer();</span><br></pre></td></tr></table></figure>

<p>Scaffold 也提供了一个 of 方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接通过of静态方法来获取ScaffoldState</span></span><br><span class="line">ScaffoldState _state=Scaffold.of(context);</span><br><span class="line"><span class="comment">// 打开抽屉菜单</span></span><br><span class="line">_state.openDrawer();</span><br></pre></td></tr></table></figure>

<p>通过 GlobalKey</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个globalKey, 由于GlobalKey要保持全局唯一性，我们使用静态变量存储</span></span><br><span class="line"><span class="keyword">static</span> GlobalKey&lt;ScaffoldState&gt; _globalKey= GlobalKey();</span><br><span class="line">...</span><br><span class="line">Scaffold(</span><br><span class="line">    key: _globalKey , <span class="comment">//设置key</span></span><br><span class="line">    ...  </span><br><span class="line">)</span><br><span class="line">  </span><br><span class="line"><span class="comment">//通过GlobalKey来获取State对象</span></span><br><span class="line">_globalKey.currentState.openDrawer()</span><br></pre></td></tr></table></figure>



<h4 id="2-3-状态管理"><a href="#2-3-状态管理" class="headerlink" title="2.3 状态管理"></a>2.3 状态管理</h4><h5 id="2-3-1-Widget-管理自身状态"><a href="#2-3-1-Widget-管理自身状态" class="headerlink" title="2.3.1 Widget 管理自身状态"></a>2.3.1 Widget 管理自身状态</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MaterialApp(home: FormTestRoute()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormTestRoute</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _FormTestRouteState createState() =&gt; _FormTestRouteState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_FormTestRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">FormTestRoute</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&#x27;标题&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: TapboxA(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_TapboxAState 类：</p>
<p>管理 TapboxA 的状态，定义 _active：确定盒子的当前颜色的布尔值</p>
<p>定义 _handleTap() 函数，在点击盒子时更新 _active 并调用 setState() 更新UI</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TapboxA</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> TapboxA(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _TapboxAState createState() =&gt; _TapboxAState();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TapboxAState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TapboxA</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> _active = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleTap() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _active = !_active;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> GestureDetector(</span><br><span class="line">      onTap: _handleTap,</span><br><span class="line">      child: Container(</span><br><span class="line">        child: Text(</span><br><span class="line">          _active ? <span class="string">&quot;Active&quot;</span> : <span class="string">&quot;Inactive&quot;</span>,</span><br><span class="line">          style: TextStyle(fontSize: <span class="number">32.0</span>, color: Colors.red),</span><br><span class="line">        ),</span><br><span class="line">        width: <span class="number">200</span>,</span><br><span class="line">        height: <span class="number">200</span>,</span><br><span class="line">        decoration: BoxDecoration(</span><br><span class="line">          color: _active ? Colors.lightGreen[<span class="number">700</span>] : Colors.grey[<span class="number">600</span>],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-2-父-Widget-管理子-Widget-状态"><a href="#2-3-2-父-Widget-管理子-Widget-状态" class="headerlink" title="2.3.2 父 Widget 管理子 Widget 状态"></a>2.3.2 父 Widget 管理子 Widget 状态</h5><p>对于父 Widget 来说，管理状态并告诉其子 Widget 何时更新通常是比较好的方式，例如，IconButton 是一个图标按钮，但它是个无状态 Widget，因为我们认为父Widget需要知道该按钮是否被点击来采取相应处理</p>
<p>TapboxB通过回调将其状态导出到其父组件，状态由父组件管理，因此父组件未 StatefulWidget，TapboxB不管理任何状态，为 StatelessWidget</p>
<p>ParentWidget</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ParentWidget(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ParentWidgetState createState() =&gt; _ParentWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ParentWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ParentWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">bool</span> _active = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">void</span> _handleTapboxChanged(<span class="built_in">bool</span> newValue) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _active = newValue;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: TapBoxB(</span><br><span class="line">          active: _active,</span><br><span class="line">          onChanged: _handleTapboxChanged,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TapBoxB</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TapBoxB</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> TapBoxB(&#123;</span><br><span class="line">    Key? key,</span><br><span class="line">    <span class="keyword">this</span>.active: <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.onChanged</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> active;</span><br><span class="line">  <span class="keyword">final</span> ValueChanged&lt;<span class="built_in">bool</span>&gt; onChanged;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleTap() &#123;</span><br><span class="line">    onChanged(!active);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> GestureDetector(</span><br><span class="line">      onTap: _handleTap,</span><br><span class="line">      child: Container(</span><br><span class="line">        child: Center(</span><br><span class="line">          child: Text(</span><br><span class="line">              active ? <span class="string">&quot;Active&quot;</span> : <span class="string">&quot;Inactive&quot;</span>,</span><br><span class="line">              style: TextStyle(fontSize: <span class="number">32</span>, color: Colors.red),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        width: <span class="number">200</span>,</span><br><span class="line">        height: <span class="number">200</span>,</span><br><span class="line">        decoration: BoxDecoration(</span><br><span class="line">          color: active ? Colors.lightGreen[<span class="number">700</span>] : Colors.grey[<span class="number">600</span>],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-3-混合状态管理"><a href="#2-3-3-混合状态管理" class="headerlink" title="2.3.3 混合状态管理"></a>2.3.3 混合状态管理</h5><p>组件自身管理一些内部状态，父组件管理一些其它外部状态</p>
<h4 id="2-4-路由管理"><a href="#2-4-路由管理" class="headerlink" title="2.4 路由管理"></a>2.4 路由管理</h4><h5 id="2-4-1-示例"><a href="#2-4-1-示例" class="headerlink" title="2.4.1 示例"></a>2.4.1 示例</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> TestRoute(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&#x27;标题&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Container(</span><br><span class="line">        child: TextButton(</span><br><span class="line">            onPressed: ()&#123;</span><br><span class="line">              Navigator.push(</span><br><span class="line">                context,</span><br><span class="line">                MaterialPageRoute(builder: (context)&#123;</span><br><span class="line">                  <span class="keyword">return</span> NewRoute();</span><br><span class="line">                &#125;),</span><br><span class="line">              );</span><br><span class="line">            &#125;,</span><br><span class="line">            child: Text(<span class="string">&quot;open new router&quot;</span>)</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> NewRoute(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&#x27;New route&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Text(<span class="string">&#x27;This is new route&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-4-2-MaterialPageRoute"><a href="#2-4-2-MaterialPageRoute" class="headerlink" title="2.4.2 MaterialPageRoute"></a>2.4.2 MaterialPageRoute</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"> MaterialPageRoute(&#123;</span><br><span class="line">  WidgetBuilder builder,</span><br><span class="line">  RouteSettings settings,</span><br><span class="line">  <span class="built_in">bool</span> maintainState = <span class="keyword">true</span>,</span><br><span class="line">  <span class="built_in">bool</span> fullscreenDialog = <span class="keyword">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>builder：是一个 WidgetBuilder 类型的回调函数，作用是构建路由页面的具体内容，返回一个 widget。通常要实现此回调，返回新路由的实例</p>
<p>settings：路由配置信息，如路由名称、是否初始路由（首页）</p>
<p>maintainState：默认情况下，当入栈一个新路由时，原来的路由仍然会被保存在内存中，如果想在路由没用的时候释放其所占用的所有资源，可以设置 maintainState 为 false</p>
<p>fullscreenDialog：新路由页面是否是一个全屏的模态对话框，iOS中为true，则新页面将会从屏幕底部滑入</p>
<h5 id="2-4-3-Navigtior"><a href="#2-4-3-Navigtior" class="headerlink" title="2.4.3 Navigtior"></a>2.4.3 Navigtior</h5><p>路由管理组件，提供打开和退出路由页面方法，通过一个栈来管理活动路由集合，当前页面就是栈顶的路由，常用两个方法 push、pop</p>
<h5 id="2-4-4-路由器传值"><a href="#2-4-4-路由器传值" class="headerlink" title="2.4.4 路由器传值"></a>2.4.4 路由器传值</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> TestRoute(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&#x27;标题&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Container(</span><br><span class="line">        child: TextButton(</span><br><span class="line">            onPressed: () <span class="keyword">async</span> &#123;<span class="comment">//打开下一个页面，并等待返回结果</span></span><br><span class="line">              <span class="keyword">var</span> result = <span class="keyword">await</span> Navigator.push(</span><br><span class="line">                context,</span><br><span class="line">                MaterialPageRoute(</span><br><span class="line">                    builder: (context) &#123;</span><br><span class="line">                      <span class="keyword">return</span> NewRoute(</span><br><span class="line">                          text: <span class="string">&#x27;提示123&#x27;</span>,</span><br><span class="line">                      );</span><br><span class="line">                    &#125;</span><br><span class="line">                ),</span><br><span class="line">              );</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&#x27;路由返回值：<span class="subst">$result</span>&#x27;</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            child: Text(<span class="string">&quot;open new router&quot;</span>)</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> NewRoute(&#123;</span><br><span class="line">    Key? key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.text, <span class="comment">//接收一个 text 参数</span></span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String?</span> text;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&#x27;New route&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Padding(</span><br><span class="line">          padding: EdgeInsets.all(<span class="number">18</span>),</span><br><span class="line">          child: Center(</span><br><span class="line">            child: Column(</span><br><span class="line">              children: [</span><br><span class="line">                Text(text!),</span><br><span class="line">                ElevatedButton(</span><br><span class="line">                    onPressed: ()&#123;</span><br><span class="line">                      Navigator.pop(context, <span class="string">&#x27;我是返回值1&#x27;</span>);<span class="comment">//传递返回值</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    child: Text(<span class="string">&#x27;返回&#x27;</span>)</span><br><span class="line">                ),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-4-5-命名路由"><a href="#2-4-5-命名路由" class="headerlink" title="2.4.5 命名路由"></a>2.4.5 命名路由</h5><ul>
<li>路由表</li>
</ul>
<p>先注册一个路由表，key 是路由名字，value 是个 builder 回调函数</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, WidgetBuilder&gt; routes;</span><br></pre></td></tr></table></figure>

<p>打开一个新路由时，根据路由名字在路由表中查找对应的 WidgetBuilder</p>
<ul>
<li>注册路由表</li>
</ul>
<p>找到 MaterialApp，添加 routes 属性</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">runApp(MaterialApp(</span><br><span class="line">    home: TestRoute(),</span><br><span class="line">    routes: &#123;</span><br><span class="line">      <span class="string">&#x27;new_page&#x27;</span>: (context) =&gt; NewRoute(text: <span class="string">&#x27;提示123&#x27;</span>),</span><br><span class="line">      <span class="string">&#x27;/&#x27;</span>: (context) =&gt; TestRoute(),</span><br><span class="line">      <span class="comment">//其它路由注册信息</span></span><br><span class="line">    &#125;,</span><br><span class="line">));</span><br></pre></td></tr></table></figure>

<ul>
<li>通过路由名打开新路由</li>
</ul>
<p>使用 Navigator 的 pushNamed 方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">onPressed: () &#123;</span><br><span class="line">  Navigator.pushNamed(context, <span class="string">&quot;new_page&quot;</span>); </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>命名路由参数传递</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MaterialApp(</span><br><span class="line">      home: TestRoute(),</span><br><span class="line">      routes: &#123;</span><br><span class="line">        <span class="string">&#x27;new_page&#x27;</span>: (context) &#123;</span><br><span class="line">          <span class="keyword">return</span> NewRoute(text: ModalRoute.of(context)?.settings.arguments <span class="keyword">as</span> <span class="built_in">String</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//其它路由注册信息</span></span><br><span class="line">      &#125;,</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> TestRoute(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&#x27;标题&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Container(</span><br><span class="line">        child: TextButton(</span><br><span class="line">            onPressed: () <span class="keyword">async</span> &#123;</span><br><span class="line">              <span class="comment">//带参数跳转</span></span><br><span class="line">              <span class="keyword">var</span> result = <span class="keyword">await</span> Navigator.of(context).pushNamed(<span class="string">&#x27;new_page&#x27;</span>, arguments: <span class="string">&#x27;提示123&#x27;</span>);</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&#x27;路由返回值：<span class="subst">$result</span>&#x27;</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            child: Text(<span class="string">&quot;open new router&quot;</span>)</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> NewRoute(&#123;</span><br><span class="line">    Key? key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.text, <span class="comment">//接收一个 text 参数</span></span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String?</span> text;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">//获取路由参数</span></span><br><span class="line">    <span class="keyword">var</span> args = ModalRoute.of(context)?.settings.arguments <span class="keyword">as</span> <span class="built_in">String</span>;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&#x27;New route&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Padding(</span><br><span class="line">          padding: EdgeInsets.all(<span class="number">18</span>),</span><br><span class="line">          child: Center(</span><br><span class="line">            child: Column(</span><br><span class="line">              children: [</span><br><span class="line">                Text(args),</span><br><span class="line">                ElevatedButton(</span><br><span class="line">                    onPressed: ()&#123;</span><br><span class="line">                      Navigator.pop(context, <span class="string">&#x27;我是返回值1&#x27;</span>);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    child: Text(<span class="string">&#x27;返回&#x27;</span>)</span><br><span class="line">                ),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-4-6-路由生成钩子"><a href="#2-4-6-路由生成钩子" class="headerlink" title="2.4.6 路由生成钩子"></a>2.4.6 路由生成钩子</h5><p>MaterialApp 有一个 onGenerateRoute 属性，打开命名路由时可能被调用</p>
<p>如果指定的路由名在路由表中已注册，则会调用路由表中的 builder 函数生成路由组件</p>
<p>如果没注册，调用 onGenerateRoute 来生成路由</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">	onGenerateRoute: (RouteSettings settings) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialPageRoute(builder: (context)&#123;</span><br><span class="line">      <span class="built_in">String</span> routeName = settings.name <span class="keyword">as</span> <span class="built_in">String</span>;</span><br><span class="line">      <span class="comment">// 如果访问的路由页需要登录，但当前未登录，则直接返回登录页路由，</span></span><br><span class="line">      <span class="comment">// 引导用户登录；其它情况则正常打开路由。</span></span><br><span class="line">      <span class="keyword">return</span> NewRoute(text: ModalRoute.of(context)?.settings.arguments <span class="keyword">as</span> <span class="built_in">String</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>有了 onGenerateRoute 回调，实现控制权限功能就可以放弃使用路由表，提供一个 onGenerateRoute 回调，在回调中进行统一的权限控制</p>
<h4 id="2-5-包管理"><a href="#2-5-包管理" class="headerlink" title="2.5 包管理"></a>2.5 包管理</h4><p>使用配置文件 pubspec.yaml 来管理第三方依赖包</p>
<p>dependencies：应用或包依赖的其它包或插件</p>
<p>dev_dependencies：开发环境依赖的工具包</p>
<p>区别：</p>
<p>前者的依赖包将作为APP的源码的一部分参与编译，生成最终安装包</p>
<p>后者的依赖包只作为开发阶段的一些工具包，主要用于帮助提高开发、测试效率，如flutter的自动化测试包</p>
<ul>
<li>Pub 仓库</li>
</ul>
<p>Pub（<a href="https://pub.dev/%EF%BC%89%E6%98%AF">https://pub.dev/）是</a> Google 官方 Dart packages 仓库，查找需要的包和插件</p>
<ul>
<li>示例</li>
</ul>
<p>搜索 english_words，添加 english_words 到依赖项列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  flutter:</span><br><span class="line">    sdk: flutter</span><br><span class="line">  english_words: ^4.0.0</span><br></pre></td></tr></table></figure>

<p>单击 pubspec.yami 右上角 Pub get，或者控制台定位到当前工程目录 <code>flutter packages get</code> 命令下载依赖包</p>
<ul>
<li>依赖本地包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">	pkg1:</span><br><span class="line">        path: ..&#x2F;..&#x2F;code&#x2F;pkg1</span><br></pre></td></tr></table></figure>

<ul>
<li>依赖 Git</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  pkg1:</span><br><span class="line">    git:</span><br><span class="line">      url: git:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;pkg1.git</span><br></pre></td></tr></table></figure>

<p>上面是包位于 Git 存储库的根目录中，如果不是可以使用 path 参数指定相对位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  package1:</span><br><span class="line">    git:</span><br><span class="line">      url: git:&#x2F;&#x2F;github.com&#x2F;flutter&#x2F;packages.git</span><br><span class="line">      path: packages&#x2F;package1        </span><br></pre></td></tr></table></figure>

<h4 id="2-6-资源管理"><a href="#2-6-资源管理" class="headerlink" title="2.6 资源管理"></a>2.6 资源管理</h4><ul>
<li>指定 assets</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter:</span><br><span class="line">  assets:</span><br><span class="line">    - assets&#x2F;my_icon.png</span><br><span class="line">    - assets&#x2F;background.png</span><br></pre></td></tr></table></figure>

<ul>
<li>加载图片</li>
</ul>
<p>Flutter 也可以为当前设备加载适合其分辨率的图像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">…&#x2F;image.png</span><br><span class="line">…&#x2F;Mx&#x2F;image.png</span><br><span class="line">…&#x2F;Nx&#x2F;image.png  &#x2F;&#x2F;M N 是数字标识</span><br><span class="line"></span><br><span class="line">…&#x2F;my_icon.png</span><br><span class="line">…&#x2F;2.0x&#x2F;my_icon.png</span><br><span class="line">…&#x2F;3.0x&#x2F;my_icon.png</span><br></pre></td></tr></table></figure>

<p>主资源默认使用1.0倍的分辨率图片，设备像素比率为1.8的设备上 …/2.0x/my_icon.png 将被选择。对于2.7的设备像素比率 …/3.0x/my_icon.png 将被选择</p>
<p>加载图片，可以使用 AssetImage </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AssetImage(<span class="string">&#x27;graphics/background.png&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>依赖包中的资源图片</li>
</ul>
<p>要加载依赖包中的图像，必须给 AssetImage 提供 package 参数</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AssetImage(<span class="string">&#x27;icons/heart.png&#x27;</span>, package: <span class="string">&#x27;my_icons&#x27;</span>)</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">Image.asset(<span class="string">&#x27;icons/heart.png&#x27;</span>, package: <span class="string">&#x27;my_icons&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-7-调试-Flutter-应用"><a href="#2-7-调试-Flutter-应用" class="headerlink" title="2.7 调试 Flutter 应用"></a>2.7 调试 Flutter 应用</h4><h4 id="2-8-Flutter-异常捕获"><a href="#2-8-Flutter-异常捕获" class="headerlink" title="2.8 Flutter 异常捕获"></a>2.8 Flutter 异常捕获</h4><p><a href="https://book.flutterchina.club/preface.html">Flutter实战 第二版</a></p>
<p><a href="https://flutterchina.club/widgets/material/">Flutter 中文网</a></p>
<p><a href="https://flutter.cn/docs/cookbook">Flutter.cn</a></p>
]]></content>
  </entry>
  <entry>
    <title>《Flutter实战第二版》五：容器类组件</title>
    <url>/2022/01/18/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E4%BA%94%EF%BC%9A%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="5-容器类组件"><a href="#5-容器类组件" class="headerlink" title="5 容器类组件"></a>5 容器类组件</h3><p>布局类组件一般都需要接收一个 widget 数组（children），容器类组件一般只需要接收一个子 widget（child）</p>
<p>布局类 widget 是按照一定的排列方式来对其子 widget 进行排列；容器类widget一般只是包装其子 widget，对其添加一些修饰（补白或背景色等）、变换（旋转裁剪等）、或限制（大小等）</p>
<h4 id="5-1-Padding"><a href="#5-1-Padding" class="headerlink" title="5.1 Padding"></a>5.1 Padding</h4><p>可以给子节点添加填充（留白），和间距效果类似</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Padding(&#123;</span><br><span class="line">  ...</span><br><span class="line">  EdgeInsetsGeometry padding,</span><br><span class="line">  Widget child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>EdgeInsetsGeometry 是一个抽象类，开发中一般使用 EdgeInsets 类，它是 EdgeInsetsGeometry 的一个子类，定义了一些设置填充的便捷方法</p>
<ul>
<li>EdgeInsets</li>
</ul>
<p>EdgeInsets 的便捷方法：</p>
<p><code>fromLTRB(double left, double top, double right, double bottom)</code> 分别指定四个方向的填充</p>
<p><code>all(double value)</code> 所有方向均使用相同数值填充</p>
<p><code>only(&#123;left, top, right ,bottom &#125;)</code> 设置某个方向的填充（可以同时指多个方向）</p>
<p><code>symmetric(&#123; vertical, horizontal &#125;)</code> 用于设置对称方向的填充，vertical 指 top 和bottom，horizontal 指 left 和 right</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaddingTestRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Padding(</span><br><span class="line">      <span class="comment">//上下左右各添加16像素补白</span></span><br><span class="line">      padding: EdgeInsets.all(<span class="number">16.0</span>),</span><br><span class="line">      child: Column(</span><br><span class="line">        <span class="comment">//显式指定对齐方式为左对齐，排除对齐干扰</span></span><br><span class="line">        crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Padding(</span><br><span class="line">            <span class="comment">//左边添加8像素补白</span></span><br><span class="line">            padding: <span class="keyword">const</span> EdgeInsets.only(left: <span class="number">8.0</span>),</span><br><span class="line">            child: Text(<span class="string">&quot;Hello world&quot;</span>),</span><br><span class="line">          ),</span><br><span class="line">          Padding(</span><br><span class="line">            <span class="comment">//上下各添加8像素补白</span></span><br><span class="line">            padding: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">8.0</span>),</span><br><span class="line">            child: Text(<span class="string">&quot;I am Jack&quot;</span>),</span><br><span class="line">          ),</span><br><span class="line">          Padding(</span><br><span class="line">            <span class="comment">// 分别指定四个方向的补白</span></span><br><span class="line">            padding: <span class="keyword">const</span> EdgeInsets.fromLTRB(<span class="number">20.0</span>,<span class="number">.0</span>,<span class="number">20.0</span>,<span class="number">20.0</span>),</span><br><span class="line">            child: Text(<span class="string">&quot;Your friend&quot;</span>),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》五：容器类组件/WeChat6661e3955fcbc5012a3fbf2acb8b2009.png" alt="WeChat6661e3955fcbc5012a3fbf2acb8b2009" style="zoom:80%;" />

<h4 id="5-2-尺寸限制类容器"><a href="#5-2-尺寸限制类容器" class="headerlink" title="5.2 尺寸限制类容器"></a>5.2 尺寸限制类容器</h4><p>尺寸限制类容器用于限制容器大小，ConstrainedBox<code>、</code>SizedBox<code>、</code>UnconstrainedBox<code>、</code>AspectRatio 等</p>
<p>尺寸限制类容器涉及到Flutter 布局流程 ，确定子组件大小的步骤为：<br>上层组件向下层组件传递约束条件<br>下层组件确定自己的大小，然后告诉上层组件，注意下层组件的大小必须符合父组件的约束</p>
<h5 id="5-2-1-ConstrainedBox"><a href="#5-2-1-ConstrainedBox" class="headerlink" title="5.2.1 ConstrainedBox"></a>5.2.1 ConstrainedBox</h5><p>ConstrainedBox 用于对子组件添加额外约束</p>
<p>。。看 四：布局类组件 4.2 布局原理与约束</p>
<h4 id="5-3-装饰容器-DecoratedBox"><a href="#5-3-装饰容器-DecoratedBox" class="headerlink" title="5.3 装饰容器 DecoratedBox"></a>5.3 装饰容器 DecoratedBox</h4><p>DecoratedBox 可以在其子组件绘制前或后绘制一些装饰，如背景、边框、渐变等</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DecoratedBox(&#123;</span><br><span class="line">  Decoration decoration,</span><br><span class="line">  DecorationPosition position = DecorationPosition.background,</span><br><span class="line">  Widget? child</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>decoration 代表将要绘制的装饰</p>
<p>position 决定哪里绘制，接收 DecorationPositon 的枚举，background 在子组件之后绘制，即背景，foreground 在子组件之上绘制，即前景</p>
<ul>
<li>BoxDecoration</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">BoxDecoration(&#123;</span><br><span class="line">  Color color, <span class="comment">//颜色</span></span><br><span class="line">  DecorationImage image,<span class="comment">//图片</span></span><br><span class="line">  BoxBorder border, <span class="comment">//边框</span></span><br><span class="line">  BorderRadiusGeometry borderRadius, <span class="comment">//圆角</span></span><br><span class="line">  <span class="built_in">List</span>&lt;BoxShadow&gt; boxShadow, <span class="comment">//阴影,可以指定多个</span></span><br><span class="line">  Gradient gradient, <span class="comment">//渐变</span></span><br><span class="line">  BlendMode backgroundBlendMode, <span class="comment">//背景混合模式</span></span><br><span class="line">  BoxShape shape = BoxShape.rectangle, <span class="comment">//形状</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>绘制一个带阴影的背景色渐变的按钮</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">DecoratedBox(</span><br><span class="line">   decoration: BoxDecoration(</span><br><span class="line">     gradient: LinearGradient(colors:[Colors.red,Colors.orange.shade700]), <span class="comment">//背景渐变</span></span><br><span class="line">     borderRadius: BorderRadius.circular(<span class="number">3.0</span>), <span class="comment">//3像素圆角</span></span><br><span class="line">     boxShadow: [ <span class="comment">//阴影</span></span><br><span class="line">       BoxShadow(</span><br><span class="line">         color:Colors.black54,</span><br><span class="line">         offset: Offset(<span class="number">2.0</span>,<span class="number">2.0</span>),</span><br><span class="line">         blurRadius: <span class="number">4.0</span></span><br><span class="line">       )</span><br><span class="line">     ]</span><br><span class="line">   ),</span><br><span class="line">  child: Padding(</span><br><span class="line">    padding: EdgeInsets.symmetric(horizontal: <span class="number">80.0</span>, vertical: <span class="number">18.0</span>),</span><br><span class="line">    child: Text(<span class="string">&quot;Login&quot;</span>, style: TextStyle(color: Colors.white),),</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E4%BA%94%EF%BC%9A%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%BB%84%E4%BB%B6/WeChatb229d2ef3c49cb4ea45184fc4edabea2.png" alt="WeChatb229d2ef3c49cb4ea45184fc4edabea2"></p>
<p>上面用到 LinearGradient 类，是用于定义线性渐变的类，Flutter 还提供了其它渐变配置 RadialGradient、SweepGradient</p>
<h4 id="5-4-变换"><a href="#5-4-变换" class="headerlink" title="5.4 变换"></a>5.4 变换</h4><p>Matrix4 是一个 4D 矩阵</p>
<ul>
<li>平移</li>
</ul>
<p>Transform.translate  接收一个 offset 参数，可以在绘制是沿 x y 轴对子组件平移指定距离</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">DecoratedBox(</span><br><span class="line">  decoration:BoxDecoration(color: Colors.red),</span><br><span class="line">  <span class="comment">//默认原点为左上角，左移20像素，向上平移5像素  </span></span><br><span class="line">  child: Transform.translate(</span><br><span class="line">    offset: Offset(<span class="number">-20.0</span>, <span class="number">-5.0</span>),</span><br><span class="line">    child: Text(<span class="string">&quot;Hello world&quot;</span>),</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E4%BA%94%EF%BC%9A%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%BB%84%E4%BB%B6/WeChat1771bb23256be799e6f11bbc2a98325a.png" alt="WeChat1771bb23256be799e6f11bbc2a98325a"></p>
<ul>
<li>旋转</li>
</ul>
<p>Transform.rotate </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span> <span class="keyword">as</span> math;</span><br><span class="line">DecoratedBox(</span><br><span class="line">  decoration:BoxDecoration(color: Colors.red),</span><br><span class="line">  child: Transform.rotate(</span><br><span class="line">    <span class="comment">//旋转90度</span></span><br><span class="line">    angle:math.pi/<span class="number">2</span> ,</span><br><span class="line">    child: Text(<span class="string">&quot;Hello world&quot;</span>),</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>缩放</li>
</ul>
<p>Transform.scale</p>
<ul>
<li>RotatedBox</li>
</ul>
<p>Transform 的变换是应用在绘制阶段，不是应用在布局（layout）阶段，无论对子组件应用何种变换，其占用空间大小和在屏幕上的位置都是固定不变的</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Row(</span><br><span class="line">  mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    DecoratedBox(</span><br><span class="line">      decoration:BoxDecoration(color: Colors.red),</span><br><span class="line">      child: Transform.scale(scale: <span class="number">1.5</span>,</span><br><span class="line">          child: Text(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">      )</span><br><span class="line">    ),</span><br><span class="line">    Text(<span class="string">&quot;你好&quot;</span>, style: TextStyle(color: Colors.green, fontSize: <span class="number">18.0</span>),)</span><br><span class="line">  ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E4%BA%94%EF%BC%9A%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%BB%84%E4%BB%B6/WeChat7c79d01b2fac91e32fdb2602d6be1ee1.png" alt="WeChat7c79d01b2fac91e32fdb2602d6be1ee1"></p>
<p>第一个 Text 放大后，绘制时会放大，但占用空间还是红色部分</p>
<p>RotatedBox 的变换是在 layout 阶段，会影响子组件位置和大小</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Row(</span><br><span class="line">  mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    DecoratedBox(</span><br><span class="line">      decoration: BoxDecoration(color: Colors.red),</span><br><span class="line">      <span class="comment">//将Transform.rotate换成RotatedBox  </span></span><br><span class="line">      child: RotatedBox(</span><br><span class="line">        quarterTurns: <span class="number">1</span>, <span class="comment">//旋转90度(1/4圈)</span></span><br><span class="line">        child: Text(<span class="string">&quot;Hello world&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">    Text(<span class="string">&quot;你好&quot;</span>, style: TextStyle(color: Colors.green, fontSize: <span class="number">18.0</span>),)</span><br><span class="line">  ],</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E4%BA%94%EF%BC%9A%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%BB%84%E4%BB%B6/WeChatf5d0a9a9d12548219cbe16cae734cd85.png" alt="WeChatf5d0a9a9d12548219cbe16cae734cd85"></p>
<h4 id="5-5-Container"><a href="#5-5-Container" class="headerlink" title="5.5 Container"></a>5.5 Container</h4><p>Container 是一个组合类容器，<code>DecoratedBox</code>、<code>ConstrainedBox、Transform</code>、<code>Padding</code>、<code>Align</code> 等组件组合的一个多功能容器</p>
<p>只需要通过一个 Container 组件可以实现同时需要装饰、变换、限制的场景</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Container(&#123;</span><br><span class="line">  <span class="keyword">this</span>.alignment,</span><br><span class="line">  <span class="keyword">this</span>.padding, <span class="comment">//容器内补白，属于decoration的装饰范围</span></span><br><span class="line">  Color color, <span class="comment">// 背景色</span></span><br><span class="line">  Decoration decoration, <span class="comment">// 背景装饰</span></span><br><span class="line">  Decoration foregroundDecoration, <span class="comment">//前景装饰</span></span><br><span class="line">  <span class="built_in">double</span> width,<span class="comment">//容器的宽度</span></span><br><span class="line">  <span class="built_in">double</span> height, <span class="comment">//容器的高度</span></span><br><span class="line">  BoxConstraints constraints, <span class="comment">//容器大小的限制条件</span></span><br><span class="line">  <span class="keyword">this</span>.margin,<span class="comment">//容器外补白，不属于decoration的装饰范围</span></span><br><span class="line">  <span class="keyword">this</span>.transform, <span class="comment">//变换</span></span><br><span class="line">  <span class="keyword">this</span>.child,</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>容器大小可以通过 width、height 属性来指定，也可以通过 constraints 来指定，如果同时存在，width、height 优先</p>
<p>color 和 decoration 是互斥的</p>
<p>例子</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Container(</span><br><span class="line">  margin: EdgeInsets.only(top: <span class="number">50.0</span>, left: <span class="number">120.0</span>),</span><br><span class="line">  constraints: BoxConstraints.tightFor(width: <span class="number">200.0</span>, height: <span class="number">150.0</span>),<span class="comment">//卡片大小</span></span><br><span class="line">  decoration: BoxDecoration(  <span class="comment">//背景装饰</span></span><br><span class="line">    gradient: RadialGradient( <span class="comment">//背景径向渐变</span></span><br><span class="line">      colors: [Colors.red, Colors.orange],</span><br><span class="line">      center: Alignment.topLeft,</span><br><span class="line">      radius: <span class="number">.98</span>,</span><br><span class="line">    ),</span><br><span class="line">    boxShadow: [</span><br><span class="line">      <span class="comment">//卡片阴影</span></span><br><span class="line">      BoxShadow(</span><br><span class="line">        color: Colors.black54,</span><br><span class="line">        offset: Offset(<span class="number">2.0</span>, <span class="number">2.0</span>),</span><br><span class="line">        blurRadius: <span class="number">4.0</span>,</span><br><span class="line">      )</span><br><span class="line">    ],</span><br><span class="line">  ),</span><br><span class="line">  transform: Matrix4.rotationZ(<span class="number">.2</span>),<span class="comment">//卡片倾斜变换</span></span><br><span class="line">  alignment: Alignment.center, <span class="comment">//卡片内文字居中</span></span><br><span class="line">  child: Text(</span><br><span class="line">    <span class="comment">//卡片文字</span></span><br><span class="line">    <span class="string">&quot;5.20&quot;</span>, style: TextStyle(color: Colors.white, fontSize: <span class="number">40.0</span>),</span><br><span class="line">  ),</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》五：容器类组件/WeChat351cd0ae2781d4d6e03e8d598ef69023.png" alt="WeChat351cd0ae2781d4d6e03e8d598ef69023" style="zoom:80%;" />

<ul>
<li>Padding 和 Margin</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Container(</span><br><span class="line">  margin: EdgeInsets.all(<span class="number">20.0</span>), <span class="comment">//容器外补白</span></span><br><span class="line">  color: Colors.orange,</span><br><span class="line">  child: Text(<span class="string">&quot;Hello world!&quot;</span>),</span><br><span class="line">),</span><br><span class="line">Container(</span><br><span class="line">  padding: EdgeInsets.all(<span class="number">20.0</span>), <span class="comment">//容器内补白</span></span><br><span class="line">  color: Colors.orange,</span><br><span class="line">  child: Text(<span class="string">&quot;Hello world!&quot;</span>),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E4%BA%94%EF%BC%9A%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%BB%84%E4%BB%B6/WeChat48a70d601784f808caac89583b0d4d09.png" alt="WeChat48a70d601784f808caac89583b0d4d09"></p>
<p>margin 的留白在容器外部，padding 的留白在容器内部</p>
<h4 id="5-6-裁剪"><a href="#5-6-裁剪" class="headerlink" title="5.6 裁剪"></a>5.6 裁剪</h4><table>
<thead>
<tr>
<th>剪裁Widget</th>
<th>默认行为</th>
</tr>
</thead>
<tbody><tr>
<td>ClipOval</td>
<td>子组件为正方形时剪裁成内贴圆形；为矩形时，剪裁成内贴椭圆</td>
</tr>
<tr>
<td>ClipRRect</td>
<td>将子组件剪裁为圆角矩形</td>
</tr>
<tr>
<td>ClipRect</td>
<td>默认剪裁掉子组件布局空间之外的绘制内容（溢出部分剪裁）</td>
</tr>
<tr>
<td>ClipPath</td>
<td>按照自定义的路径剪裁</td>
</tr>
</tbody></table>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClipTestRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 头像  </span></span><br><span class="line">    Widget avatar = Image.asset(<span class="string">&quot;imgs/avatar.png&quot;</span>, width: <span class="number">60.0</span>);</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          avatar, <span class="comment">//不剪裁</span></span><br><span class="line">          ClipOval(child: avatar), <span class="comment">//剪裁为圆形</span></span><br><span class="line">          ClipRRect( <span class="comment">//剪裁为圆角矩形</span></span><br><span class="line">            borderRadius: BorderRadius.circular(<span class="number">5.0</span>),</span><br><span class="line">            child: avatar,</span><br><span class="line">          ), </span><br><span class="line">          Row(</span><br><span class="line">            mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              Align(</span><br><span class="line">                alignment: Alignment.topLeft,</span><br><span class="line">                widthFactor: <span class="number">.5</span>,<span class="comment">//宽度设为原来宽度一半，另一半会溢出</span></span><br><span class="line">                child: avatar,</span><br><span class="line">              ),</span><br><span class="line">              Text(<span class="string">&quot;你好世界&quot;</span>, style: TextStyle(color: Colors.green),)</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">          Row(</span><br><span class="line">            mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              ClipRect(<span class="comment">//将溢出部分剪裁</span></span><br><span class="line">                child: Align(</span><br><span class="line">                  alignment: Alignment.topLeft,</span><br><span class="line">                  widthFactor: <span class="number">.5</span>,<span class="comment">//宽度设为原来宽度一半</span></span><br><span class="line">                  child: avatar,</span><br><span class="line">                ),</span><br><span class="line">              ),</span><br><span class="line">              Text(<span class="string">&quot;你好世界&quot;</span>,style: TextStyle(color: Colors.green))</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E4%BA%94%EF%BC%9A%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%BB%84%E4%BB%B6/WeChatedd5eb5c6aef971412aded090c9a4d5d.png" alt="WeChatedd5eb5c6aef971412aded090c9a4d5d"></p>
<ul>
<li>CustomClipper</li>
</ul>
<p>自定义裁剪区域</p>
<p>自定义一个 CustomClipper</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClipper</span> <span class="keyword">extends</span> <span class="title">CustomClipper</span>&lt;<span class="title">Rect</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Rect getClip(Size size) &#123;</span><br><span class="line">    <span class="keyword">return</span> Rect.fromLTWH(<span class="number">10.0</span>, <span class="number">15.0</span>, <span class="number">40.0</span>, <span class="number">30.0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> shouldReclip(<span class="keyword">covariant</span> CustomClipper&lt;Rect&gt; oldClipper) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getClip 用于获取裁剪区域的接口，返回的裁剪区域为 Rect.fromLTWH(10.0, 15.0, 40.0, 30.0)</p>
<p>shouldReclip 接口决定是否重新裁剪，如果应用中裁剪区域不会发生变化时应该返回false，就不会触发重新裁剪，避免不必要的性能开销，如果裁剪区域会发生变化，那么变化后应该返回 true 来重新执行裁剪</p>
<p>然后通过 ClipRect 来执行裁剪 </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">DecoratedBox(</span><br><span class="line">  decoration: BoxDecoration(</span><br><span class="line">    color: Colors.red</span><br><span class="line">  ),</span><br><span class="line">  child: ClipRect(</span><br><span class="line">    clipper: MyClipper(), <span class="comment">//使用自定义的clipper</span></span><br><span class="line">    child: avatar</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>ClipPath 可以按照自定义的路径实现裁剪，需要自定义一个 <code>CustomClipper&lt;Path&gt;</code> 类型的Clipper，定义方式和 MyClipper 类似，getClip 返回一个 Path</p>
<h4 id="5-7-空间适配-FittedBox"><a href="#5-7-空间适配-FittedBox" class="headerlink" title="5.7 空间适配 FittedBox"></a>5.7 空间适配 FittedBox</h4><h5 id="5-7-1-FittedBox"><a href="#5-7-1-FittedBox" class="headerlink" title="5.7.1 FittedBox"></a>5.7.1 FittedBox</h5><p>子组件大小超出父组件大小时，如果不经过处理的话 Flutter 中就会显示一个溢出警告</p>
<p>为了方便开发者自定义适配规则，Flutter 提供了 FittedBox 组件</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> FittedBox(&#123;</span><br><span class="line">  Key? key,</span><br><span class="line">  <span class="keyword">this</span>.fit = BoxFit.contain, <span class="comment">// 适配方式</span></span><br><span class="line">  <span class="keyword">this</span>.alignment = Alignment.center, <span class="comment">//对齐方式</span></span><br><span class="line">  <span class="keyword">this</span>.clipBehavior = Clip.none, <span class="comment">//是否剪裁</span></span><br><span class="line">  Widget? child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> Center(</span><br><span class="line">    child: Column(</span><br><span class="line">      children: [</span><br><span class="line">        wContainer(BoxFit.none),</span><br><span class="line">        Text(<span class="string">&#x27;Wendux&#x27;</span>),</span><br><span class="line">        wContainer(BoxFit.contain),</span><br><span class="line">        Text(<span class="string">&#x27;Flutter中国&#x27;</span>),</span><br><span class="line">      ],</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget wContainer(BoxFit boxFit) &#123;</span><br><span class="line">  <span class="keyword">return</span> Container(</span><br><span class="line">    width: <span class="number">50</span>,</span><br><span class="line">    height: <span class="number">50</span>,</span><br><span class="line">    color: Colors.red,</span><br><span class="line">    child: FittedBox(</span><br><span class="line">      fit: boxFit,</span><br><span class="line">      <span class="comment">// 子容器超过父容器大小</span></span><br><span class="line">      child: Container(width: <span class="number">60</span>, height: <span class="number">70</span>, color: Colors.blue),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E4%BA%94%EF%BC%9A%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%BB%84%E4%BB%B6/WeChat2c36ee6dff4f283649d2ef335b96036f.png" alt="WeChat2c36ee6dff4f283649d2ef335b96036f"></p>
<p>父 Container 要比子 Container 小，没置顶任何适配方式时，子组件按照真实大小绘制，蓝色区域超出父组件空间，因而看不到红色区域</p>
<p>第二个适配方式 BoxFit.contain，含义是按子组件的比例缩放，尽可能多的占据父组件的空间，子组件的长宽不相同，按照比例适配父组件后，父组件能显示一部分</p>
<p>未指定适配方式时，子组件的大小超出了父组件，但 FittedBox 自身还是要遵守父组件传递的约束，所以 FittedBox 本身大小是 50x50，所以蓝色下面文本重叠了</p>
<p>如果不想让蓝色超出父组件布局范围，可以使用 ClipRec 对超出部分裁剪掉</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ClipRect( <span class="comment">// 将超出子组件布局范围的绘制内容剪裁掉</span></span><br><span class="line">  child: Container(</span><br><span class="line">    width: <span class="number">50</span>,</span><br><span class="line">    height: <span class="number">50</span>,</span><br><span class="line">    color: Colors.red,</span><br><span class="line">    child: FittedBox(</span><br><span class="line">      fit: boxFit,</span><br><span class="line">      child: Container(width: <span class="number">60</span>, height: <span class="number">70</span>, color: Colors.blue),</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="5-7-2-单行缩放布局"><a href="#5-7-2-单行缩放布局" class="headerlink" title="5.7.2 单行缩放布局"></a>5.7.2 单行缩放布局</h5><p>三个数据指标，需要一行显示，我们希望当无法一行显示时能够对组件进行适当的缩放确保一行显示</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"> Widget build(BuildContext context) &#123;</span><br><span class="line">   <span class="keyword">return</span> Center(</span><br><span class="line">     child: Column(</span><br><span class="line">       children:  [</span><br><span class="line">         wRow(<span class="string">&#x27; 90000000000000000 &#x27;</span>),</span><br><span class="line">         FittedBox(child: wRow(<span class="string">&#x27; 90000000000000000 &#x27;</span>)),</span><br><span class="line">         wRow(<span class="string">&#x27; 800 &#x27;</span>),</span><br><span class="line">         FittedBox(child: wRow1(<span class="string">&#x27; 800 &#x27;</span>)),</span><br><span class="line">   		]</span><br><span class="line">       .map((e) =&gt; Padding(</span><br><span class="line">             padding: EdgeInsets.symmetric(vertical: <span class="number">20</span>),</span><br><span class="line">             child: e,</span><br><span class="line">           ))</span><br><span class="line">       .toList();,</span><br><span class="line">     ),</span><br><span class="line">   );</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接使用Row</span></span><br><span class="line"> Widget wRow(<span class="built_in">String</span> text) &#123;</span><br><span class="line">   Widget child = Text(text);</span><br><span class="line">   child = Row(</span><br><span class="line">     mainAxisAlignment: MainAxisAlignment.spaceEvenly,</span><br><span class="line">     children: [child, child, child],</span><br><span class="line">   );</span><br><span class="line">   <span class="keyword">return</span> child;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》五：容器类组件/WeChatc17b2a1e3c1f5eddd9695a65c7bf9423.png" alt="WeChatc17b2a1e3c1f5eddd9695a65c7bf9423" style="zoom:80%;" />

<p>Row 在主轴的对齐方式为 MainAxisAlignment.spaceEvenly，会将水平方向的剩余显示空间均分成多份穿插在每个 child 之间</p>
<p>第一行超出屏幕宽度，直接使用 Row 会溢出</p>
<p>第二行加上 FittedBox 就可以按比例缩放至一行显示</p>
<p>Row 没被 FittedBox 包裹时，父组件传给 Row 的约束的 maxWidth 为屏幕宽度，Row的宽度也就是屏幕宽度</p>
<p>当被 FittedBox 包裹时，FittedBox 传给 Row的约束的 maxWidth 为无限大，因此 Row的最终宽度就是子组件的宽度之和</p>
<p>所以只需要让 FittedBox 子元素接收到的约束的 maxWidth 为屏幕宽度即可</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLineFittedBox</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> SingleLineFittedBox(&#123;Key? key,<span class="keyword">this</span>.child&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"> <span class="keyword">final</span> Widget? child;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> LayoutBuilder(</span><br><span class="line">      builder: (_, constraints) &#123;</span><br><span class="line">        <span class="keyword">return</span> FittedBox(</span><br><span class="line">          child: ConstrainedBox(</span><br><span class="line">            constraints: constraints.copyWith(</span><br><span class="line">              minWidth: constraints.maxWidth,</span><br><span class="line">              maxWidth: <span class="built_in">double</span>.infinity,</span><br><span class="line">              <span class="comment">//maxWidth: constraints.maxWidth</span></span><br><span class="line">            ),</span><br><span class="line">            child: child,</span><br><span class="line">          ),</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》五：容器类组件/WeChatf8d080b6a4934b277d35eae7dee059d2.png" alt="WeChatf8d080b6a4934b277d35eae7dee059d2" style="zoom:80%;" />

<h4 id="5-8-Scaffold"><a href="#5-8-Scaffold" class="headerlink" title="5.8 Scaffold"></a>5.8 Scaffold</h4><h5 id="5-8-1-Scaffold"><a href="#5-8-1-Scaffold" class="headerlink" title="5.8.1 Scaffold"></a>5.8.1 Scaffold</h5><p>Scaffold 是一个路由页的骨架</p>
<p>实现一个页面：<br>1.一个导航栏<br>2.导航栏右边分享按钮<br>3.一个抽屉菜单<br>4.有一个底部导航<br>5.右下角悬浮动作按钮</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScaffoldRoute</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ScaffoldRouteState createState() =&gt; _ScaffoldRouteState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ScaffoldRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ScaffoldRoute</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _selectedIndex = <span class="number">1</span>;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&#x27;标题&#x27;</span>),</span><br><span class="line">        actions: [</span><br><span class="line">          IconButton(onPressed: ()&#123;&#125;, icon: Icon(Icons.share))</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">      bottomNavigationBar: BottomNavigationBar(</span><br><span class="line">          items: [</span><br><span class="line">            BottomNavigationBarItem(icon: Icon(Icons.home), title: Text(<span class="string">&#x27;Home&#x27;</span>)),</span><br><span class="line">            BottomNavigationBarItem(icon: Icon(Icons.business), title:Text(<span class="string">&#x27;Business&#x27;</span>)),</span><br><span class="line">            BottomNavigationBarItem(icon: Icon(Icons.school), title: Text(<span class="string">&#x27;School&#x27;</span>)),</span><br><span class="line">          ],</span><br><span class="line">          currentIndex: _selectedIndex,</span><br><span class="line">          fixedColor: Colors.blue, <span class="comment">//选中index图标颜色</span></span><br><span class="line">          onTap: _onItemTapped,</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">          child: Icon(Icons.add),</span><br><span class="line">          onPressed: _onAdd,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> _onItemTapped(<span class="built_in">int</span> index) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _selectedIndex = index;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> _onAdd() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》五：容器类组件/WeChataf1f187dc2c0ab4fa149ec5e1962aaf7.png" alt="WeChataf1f187dc2c0ab4fa149ec5e1962aaf7" style="zoom:80%;" />

<p>AppBar 导航栏骨架</p>
<p>BottomNavigationBar 底部导航栏</p>
<p>FloatingActionButton 悬浮按钮</p>
<h5 id="5-8-2-AppBar"><a href="#5-8-2-AppBar" class="headerlink" title="5.8.2 AppBar"></a>5.8.2 AppBar</h5><p>APPBar 是一个 Material 风格的导航栏，通过它可以设置导航栏标题、导航栏菜单、导航栏底部Tab标题等</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AppBar(&#123;</span><br><span class="line">  Key? key,</span><br><span class="line">  <span class="keyword">this</span>.leading, <span class="comment">//导航栏最左侧Widget，常见为抽屉菜单按钮或返回按钮。</span></span><br><span class="line">  <span class="keyword">this</span>.automaticallyImplyLeading = <span class="keyword">true</span>, <span class="comment">//如果leading为null，是否自动实现默认的leading按钮</span></span><br><span class="line">  <span class="keyword">this</span>.title,<span class="comment">// 页面标题</span></span><br><span class="line">  <span class="keyword">this</span>.actions, <span class="comment">// 导航栏右侧菜单</span></span><br><span class="line">  <span class="keyword">this</span>.bottom, <span class="comment">// 导航栏底部菜单，通常为Tab按钮组</span></span><br><span class="line">  <span class="keyword">this</span>.elevation = <span class="number">4.0</span>, <span class="comment">// 导航栏阴影</span></span><br><span class="line">  <span class="keyword">this</span>.centerTitle, <span class="comment">//标题是否居中 </span></span><br><span class="line">  <span class="keyword">this</span>.backgroundColor,</span><br><span class="line">  ...   <span class="comment">//其它属性见源码注释</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果给 Scaffold 添加了菜单，默认情况下 Scaffold 会自动将 leading 设置为菜单按钮，点击它就可以打开抽屉菜单，也可以自定义图标</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Scaffold(</span><br><span class="line">  appBar: AppBar(</span><br><span class="line">    title: Text(<span class="string">&quot;App Name&quot;</span>),</span><br><span class="line">    leading: Builder(builder: (context) &#123;</span><br><span class="line">      <span class="keyword">return</span> IconButton(</span><br><span class="line">        icon: Icon(Icons.dashboard, color: Colors.white), <span class="comment">//自定义图标</span></span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          <span class="comment">// 打开抽屉菜单  </span></span><br><span class="line">          Scaffold.of(context).openDrawer(); </span><br><span class="line">        &#125;,</span><br><span class="line">      );</span><br><span class="line">    &#125;),</span><br><span class="line">    ...  </span><br><span class="line">  )  </span><br></pre></td></tr></table></figure>

<h5 id="5-8-3-抽屉菜单-Drawer"><a href="#5-8-3-抽屉菜单-Drawer" class="headerlink" title="5.8.3 抽屉菜单 Drawer"></a>5.8.3 抽屉菜单 Drawer</h5><p>Scaffold 的 drawer 和 endDrawer 属性可以分别接受一个 widget 来作为左、右抽屉菜单</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDrawer</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MyDrawer(&#123;</span><br><span class="line">    Key? key,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Drawer(</span><br><span class="line">      child: MediaQuery.removePadding(</span><br><span class="line">        context: context,</span><br><span class="line">        <span class="comment">//移除抽屉菜单顶部默认留白</span></span><br><span class="line">        removeTop: <span class="keyword">true</span>,</span><br><span class="line">        child: Column(</span><br><span class="line">          crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Padding(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">38.0</span>),</span><br><span class="line">              child: Row(</span><br><span class="line">                children: &lt;Widget&gt;[</span><br><span class="line">                  Padding(</span><br><span class="line">                    padding: <span class="keyword">const</span> EdgeInsets.symmetric(horizontal: <span class="number">16.0</span>),</span><br><span class="line">                    child: ClipOval(</span><br><span class="line">                      child: Image.asset(</span><br><span class="line">                        <span class="string">&quot;img/avatar.png&quot;</span>,</span><br><span class="line">                        width: <span class="number">80</span>,</span><br><span class="line">                      ),</span><br><span class="line">                    ),</span><br><span class="line">                  ),</span><br><span class="line">                  Text(</span><br><span class="line">                    <span class="string">&quot;Wendux&quot;</span>,</span><br><span class="line">                    style: TextStyle(fontWeight: FontWeight.bold),</span><br><span class="line">                  )</span><br><span class="line">                ],</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            Expanded(</span><br><span class="line">              child: ListView(</span><br><span class="line">                children: &lt;Widget&gt;[</span><br><span class="line">                  ListTile(</span><br><span class="line">                    leading: <span class="keyword">const</span> Icon(Icons.add),</span><br><span class="line">                    title: <span class="keyword">const</span> Text(<span class="string">&#x27;Add account&#x27;</span>),</span><br><span class="line">                  ),</span><br><span class="line">                  ListTile(</span><br><span class="line">                    leading: <span class="keyword">const</span> Icon(Icons.settings),</span><br><span class="line">                    title: <span class="keyword">const</span> Text(<span class="string">&#x27;Manage accounts&#x27;</span>),</span><br><span class="line">                  ),</span><br><span class="line">                ],</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽屉菜单通常将 Drawer 组件作为根节点，MediaQuery.removePadding 可以移除 Drawer 默认的一些留白（比如Drawer默认顶部会留手机状态栏等高的留白）</p>
<h5 id="5-8-4-FloatingActionButton"><a href="#5-8-4-FloatingActionButton" class="headerlink" title="5.8.4 FloatingActionButton"></a>5.8.4 FloatingActionButton</h5><p>可以通过 floatingActionButtonLocation 属性指定其在页面中悬浮的位置</p>
<h5 id="5-8-5-底部-Tab-导航栏"><a href="#5-8-5-底部-Tab-导航栏" class="headerlink" title="5.8.5 底部 Tab 导航栏"></a>5.8.5 底部 Tab 导航栏</h5><p>Material 组件库中提供了一个 BottomAPPBar 组件，可以和 FloatingActionButton 配合实现打洞效果</p>
<img src="《Flutter实战第二版》五：容器类组件/WeChat32ad216f5189993f92ba6d3d40aae74c.png" alt="WeChat32ad216f5189993f92ba6d3d40aae74c" style="zoom:80%;" />

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">bottomNavigationBar: BottomAppBar(</span><br><span class="line">  color: Colors.white,</span><br><span class="line">  shape: CircularNotchedRectangle(), <span class="comment">// 底部导航栏打一个圆形的洞</span></span><br><span class="line">  child: Row(</span><br><span class="line">    children: [</span><br><span class="line">      IconButton(icon: Icon(Icons.home)),</span><br><span class="line">      SizedBox(), <span class="comment">//中间位置空出</span></span><br><span class="line">      IconButton(icon: Icon(Icons.business)),</span><br><span class="line">    ],</span><br><span class="line">    mainAxisAlignment: MainAxisAlignment.spaceAround, <span class="comment">//均分底部导航栏横向空间</span></span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面代码没有控制打洞位置的属性，实际上打洞位置取决于 FloatingActionButton 的位置</p>
<p>上面 FloatingActionButton 的位置为</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,</span><br></pre></td></tr></table></figure>

<p>打洞位置在导航栏正中间</p>
<p>shape 属性决定洞的外形，也可以自定义外形</p>
]]></content>
  </entry>
  <entry>
    <title>《Flutter实战第二版》十一：文件操作与网络请求</title>
    <url>/2022/01/26/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E5%8D%81%E4%B8%80%EF%BC%9A%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h3 id="11-文件操作与网络请求"><a href="#11-文件操作与网络请求" class="headerlink" title="11 文件操作与网络请求"></a>11 文件操作与网络请求</h3><h4 id="11-1-文件操作"><a href="#11-1-文件操作" class="headerlink" title="11.1 文件操作"></a>11.1 文件操作</h4><ul>
<li>临时目录</li>
</ul>
<p>getTemporaryDirectory() 获取，系统可随时清除的临时目录。iOS 上对应 NSTemporaryDirectory()，Android 上是 getCacheDir()</p>
<ul>
<li>文档目录</li>
</ul>
<p>getApplicationDocumentsDirectory() 获取应用程序的文档目录。iOS 上对应 NSDocumentDirectory，Android 上是 APPData 目录</p>
<ul>
<li>外部存储目录</li>
</ul>
<p>getExternalStorageDirectory() 获取外部存储目录，如 SD 卡，iOS 不支持外部目录，iOS 下调用会抛出 UnsupportedError 异常，Android 中是 getExternalStorageDirectory 的返回值</p>
<p>一旦你的 Flutter 应用程序有一个文件位置的引用，可以使用 dart:io API来执行对文件系统的读/写操作</p>
<ul>
<li>示例</li>
</ul>
<p>计数器示例，退出重启后可以恢复点击次数，用文件来保存数据</p>
<p>引入 PathProvider 插件，pubspec.yaml 中添加</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">path_provider: ^<span class="number">2.0</span><span class="number">.8</span></span><br></pre></td></tr></table></figure>

<p>实现 </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:io&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:async&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:path_provider/path_provider.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileOperationRoute</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  FileOperationRoute(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _FileOperationRouteState createState() =&gt; _FileOperationRouteState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_FileOperationRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">FileOperationRoute</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">//从文件读取点击次数</span></span><br><span class="line">    _readCounter().then((<span class="built_in">int</span> value) &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        _counter = value;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;File&gt; _getLocalFile() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// 获取应用目录</span></span><br><span class="line">    <span class="built_in">String</span> dir = (<span class="keyword">await</span> getApplicationDocumentsDirectory()).path;</span><br><span class="line">    <span class="keyword">return</span> File(<span class="string">&#x27;<span class="subst">$dir</span>/counter.txt&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="built_in">int</span>&gt; _readCounter() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      File file = <span class="keyword">await</span> _getLocalFile();</span><br><span class="line">      <span class="comment">// 读取点击次数（以字符串）</span></span><br><span class="line">      <span class="built_in">String</span> contents = <span class="keyword">await</span> file.readAsString();</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">int</span>.parse(contents);</span><br><span class="line">    &#125; <span class="keyword">on</span> FileSystemException &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _incrementCounter() <span class="keyword">async</span> &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _counter++;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 将点击次数以字符串类型写到文件中</span></span><br><span class="line">    <span class="keyword">await</span> (<span class="keyword">await</span> _getLocalFile()).writeAsString(<span class="string">&#x27;<span class="subst">$_counter</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">&#x27;文件操作&#x27;</span>)),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Text(<span class="string">&#x27;点击了 <span class="subst">$_counter</span> 次&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: _incrementCounter,</span><br><span class="line">        tooltip: <span class="string">&#x27;Increment&#x27;</span>,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》十一：文件操作与网络请求/WeChat090c4738bd95a6d28745c73778204758.png" alt="WeChat090c4738bd95a6d28745c73778204758" style="zoom:80%;" />

<p>实际开发中如果要存储一些简单数据，使用 shared_preferences 插件</p>
<h4 id="11-2-通过-HttpClient-发起-HTTP-请求"><a href="#11-2-通过-HttpClient-发起-HTTP-请求" class="headerlink" title="11.2 通过 HttpClient 发起 HTTP 请求"></a>11.2 通过 HttpClient 发起 HTTP 请求</h4><p>使用 HttpClient 发起请求分为五步</p>
<ol>
<li>创建 HttpClient</li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">HttpClient httpClient = HttpClient();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>打开HTTP连接，设置请求头</li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">HttpClientRequest request = <span class="keyword">await</span> httpClient.getUrl(uri);</span><br></pre></td></tr></table></figure>

<p>这一步可以使用任意Http Method，如<code>httpClient.post(...)</code>、<code>httpClient.delete(...)</code>等。如果包含Query参数，可以在构建uri时添加</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Uri</span> uri = <span class="built_in">Uri</span>(scheme: <span class="string">&quot;https&quot;</span>, host: <span class="string">&quot;flutterchina.club&quot;</span>, queryParameters: &#123;</span><br><span class="line">    <span class="string">&quot;xx&quot;</span>:<span class="string">&quot;xx&quot;</span>,</span><br><span class="line">    <span class="string">&quot;yy&quot;</span>:<span class="string">&quot;dd&quot;</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>通过 HttpClientRequest 可以设置请求 header</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">request.headers.add(<span class="string">&quot;user-agent&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果是post或put等可以携带请求体方法，可以通过HttpClientRequest对象发送request body</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> payload=<span class="string">&quot;...&quot;</span>;</span><br><span class="line">request.add(utf8.encode(payload)); </span><br><span class="line"><span class="comment">//request.addStream(_inputStream); //可以直接添加输入流</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>等待连接服务器</li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">HttpClientResponse response = <span class="keyword">await</span> request.close();</span><br></pre></td></tr></table></figure>

<p>这一步完成后，请求信息就已经发送给服务器了，返回一个<code>HttpClientResponse</code>对象，它包含响应头（header）和响应流(响应体的Stream)，接下来就可以通过读取响应流来获取响应内容</p>
<ol start="4">
<li>读取响应内容</li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> responseBody = <span class="keyword">await</span> response.transform(utf8.decoder).join();</span><br></pre></td></tr></table></figure>

<p>我们通过读取响应流来获取服务器返回的数据，在读取时我们可以设置编码格式，这里是utf8</p>
<ol start="5">
<li>请求结束，关闭<code>HttpClient</code></li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">httpClient.close();</span><br></pre></td></tr></table></figure>

<p>关闭client后，通过该client发起的所有请求都会中止</p>
<ul>
<li>示例</li>
</ul>
<p>获取百度首页 html</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:convert&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:io&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpTestRoute</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _HttpTestRouteState createState() =&gt; _HttpTestRouteState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_HttpTestRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">HttpTestRoute</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">bool</span> _loading = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">String</span> _text = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> SingleChildScrollView(</span><br><span class="line">      child: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          ElevatedButton(</span><br><span class="line">            child: Text(<span class="string">&quot;获取百度首页&quot;</span>),</span><br><span class="line">            onPressed: _loading ? <span class="keyword">null</span> : request,</span><br><span class="line">          ),</span><br><span class="line">          Container(</span><br><span class="line">            width: MediaQuery.of(context).size.width - <span class="number">50.0</span>,</span><br><span class="line">            child: Text(_text.replaceAll(<span class="built_in">RegExp</span>(<span class="string">r&quot;\s&quot;</span>), <span class="string">&quot;&quot;</span>)),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  request() <span class="keyword">async</span> &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _loading = <span class="keyword">true</span>;</span><br><span class="line">      _text = <span class="string">&quot;正在请求...&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//创建一个HttpClient</span></span><br><span class="line">      HttpClient httpClient = HttpClient();</span><br><span class="line">      <span class="comment">//打开Http连接</span></span><br><span class="line">      HttpClientRequest request =</span><br><span class="line">          <span class="keyword">await</span> httpClient.getUrl(<span class="built_in">Uri</span>.parse(<span class="string">&quot;https://www.baidu.com&quot;</span>));</span><br><span class="line">      <span class="comment">//使用iPhone的UA</span></span><br><span class="line">      request.headers.add(</span><br><span class="line">        <span class="string">&quot;user-agent&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1&quot;</span>,</span><br><span class="line">      );</span><br><span class="line">      <span class="comment">//等待连接服务器（会将请求信息发送给服务器）</span></span><br><span class="line">      HttpClientResponse response = <span class="keyword">await</span> request.close();</span><br><span class="line">      <span class="comment">//读取响应内容</span></span><br><span class="line">      _text = <span class="keyword">await</span> response.transform(utf8.decoder).join();</span><br><span class="line">      <span class="comment">//输出响应头</span></span><br><span class="line">      <span class="built_in">print</span>(response.headers);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//关闭client后，通过该client发起的所有请求都会中止。</span></span><br><span class="line">      httpClient.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      _text = <span class="string">&quot;请求失败：<span class="subst">$e</span>&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        _loading = <span class="keyword">false</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》十一：文件操作与网络请求/WeChat268e06a2ed985dfb1a6c39fd00b96c2e.png" alt="WeChat268e06a2ed985dfb1a6c39fd00b96c2e" style="zoom:80%;" />

<ul>
<li>HttpClient </li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>idleTimeout</td>
<td>对应请求头中的keep-alive字段值，为了避免频繁建立连接，httpClient在请求结束后会保持连接一段时间，超过这个阈值后才会关闭连接。</td>
</tr>
<tr>
<td>connectionTimeout</td>
<td>和服务器建立连接的超时，如果超过这个值则会抛出SocketException异常。</td>
</tr>
<tr>
<td>maxConnectionsPerHost</td>
<td>同一个host，同时允许建立连接的最大数量。</td>
</tr>
<tr>
<td>autoUncompress</td>
<td>对应请求头中的Content-Encoding，如果设置为true，则请求头中Content-Encoding的值为当前HttpClient支持的压缩算法列表，目前只有”gzip”</td>
</tr>
<tr>
<td>userAgent</td>
<td>对应请求头中的User-Agent字段。</td>
</tr>
</tbody></table>
<p>这些属性也可通过 HttpClientRequest 直接设置 header，只对当前请求生效；HttpClient 设置的对整个 HttpClient 都生效</p>
<ul>
<li>HTTP 请求认证</li>
<li>代理</li>
<li>证书校验</li>
</ul>
<p>Https 中为了防止通过伪造证书而发起的中间人攻击，客户端应该对自签名或非CA颁发的证书进行校验</p>
<h4 id="11-3-HTTP请求-Dio-http-库"><a href="#11-3-HTTP请求-Dio-http-库" class="headerlink" title="11.3 HTTP请求-Dio http 库"></a>11.3 HTTP请求-Dio http 库</h4><p>引入 dio</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">dio: ^<span class="number">4.0</span><span class="number">.3</span></span><br></pre></td></tr></table></figure>

<p>导入并创建 dio 实例</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:dio/dio.dart&#x27;</span>;</span><br><span class="line">Dio dio =  Dio();</span><br></pre></td></tr></table></figure>

<p>GET 请求</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Response response;</span><br><span class="line">response=<span class="keyword">await</span> dio.<span class="keyword">get</span>(<span class="string">&quot;/test?id=12&amp;name=wendu&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.data.toString());</span><br></pre></td></tr></table></figure>

<p>可以将 query 参数通过对象来传递</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">response=<span class="keyword">await</span> dio.<span class="keyword">get</span>(<span class="string">&quot;/test&quot;</span>,queryParameters:&#123;<span class="string">&quot;id&quot;</span>:<span class="number">12</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;wendu&quot;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(response);</span><br></pre></td></tr></table></figure>

<p>POST 请求</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">response=<span class="keyword">await</span> dio.post(<span class="string">&quot;/test&quot;</span>,data:&#123;<span class="string">&quot;id&quot;</span>:<span class="number">12</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;wendu&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>发起多个并发请求</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">response= <span class="keyword">await</span> Future.wait([dio.post(<span class="string">&quot;/info&quot;</span>),dio.<span class="keyword">get</span>(<span class="string">&quot;/token&quot;</span>)]);</span><br></pre></td></tr></table></figure>

<p>下载文件</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">response=<span class="keyword">await</span> dio.download(<span class="string">&quot;https://www.google.com/&quot;</span>,_savePath);</span><br></pre></td></tr></table></figure>

<p>发送 FormData</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">FormData formData = FormData.from(&#123;</span><br><span class="line">   <span class="string">&quot;name&quot;</span>: <span class="string">&quot;wendux&quot;</span>,</span><br><span class="line">   <span class="string">&quot;age&quot;</span>: <span class="number">25</span>,</span><br><span class="line">&#125;);</span><br><span class="line">response = <span class="keyword">await</span> dio.post(<span class="string">&quot;/info&quot;</span>, data: formData)</span><br></pre></td></tr></table></figure>

<p>如果发送的数据是FormData，则dio会将请求header的<code>contentType</code>设为“multipart/form-data”</p>
<p>通过FormData上传多个文件</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">FormData formData = FormData.from(&#123;</span><br><span class="line">   <span class="string">&quot;name&quot;</span>: <span class="string">&quot;wendux&quot;</span>,</span><br><span class="line">   <span class="string">&quot;age&quot;</span>: <span class="number">25</span>,</span><br><span class="line">   <span class="string">&quot;file1&quot;</span>: UploadFileInfo(File(<span class="string">&quot;./upload.txt&quot;</span>), <span class="string">&quot;upload1.txt&quot;</span>),</span><br><span class="line">   <span class="string">&quot;file2&quot;</span>: UploadFileInfo(File(<span class="string">&quot;./upload.txt&quot;</span>), <span class="string">&quot;upload2.txt&quot;</span>),</span><br><span class="line">     <span class="comment">// 支持文件数组上传</span></span><br><span class="line">   <span class="string">&quot;files&quot;</span>: [</span><br><span class="line">      UploadFileInfo(File(<span class="string">&quot;./example/upload.txt&quot;</span>), <span class="string">&quot;upload.txt&quot;</span>),</span><br><span class="line">      UploadFileInfo(File(<span class="string">&quot;./example/upload.txt&quot;</span>), <span class="string">&quot;upload.txt&quot;</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br><span class="line">response = <span class="keyword">await</span> dio.post(<span class="string">&quot;/info&quot;</span>, data: formData)</span><br></pre></td></tr></table></figure>

<p>dio 内部仍然使用 HttpClient 发起请求，所以代理、请求认证、证书校验等和 HttpClient 是相同的，可以在 onHttpClientCreate 回调中设置</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">(dio.httpClientAdapter <span class="keyword">as</span> DefaultHttpClientAdapter).onHttpClientCreate = (client) &#123;</span><br><span class="line">    <span class="comment">//设置代理 </span></span><br><span class="line">    client.findProxy = (uri) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;PROXY 192.168.1.2:8888&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//校验证书</span></span><br><span class="line">    httpClient.badCertificateCallback=(X509Certificate cert, <span class="built_in">String</span> host, <span class="built_in">int</span> port)&#123;</span><br><span class="line">      <span class="keyword">if</span>(cert.pem==PEM)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//证书一致，则允许发送数据</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;;   </span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p><code>onHttpClientCreate</code> 会在当前dio实例内部需要创建HttpClient时调用，所以通过此回调配置HttpClient会对整个dio实例生效</p>
<ul>
<li>示例</li>
</ul>
<p>通过 Github 开放 API 请求 flutterchina 组织下所有公开的项目</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_FutureBuilderRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">FutureBuilderRoute</span>&gt; </span>&#123;</span><br><span class="line">  Dio _dio = Dio();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      alignment: Alignment.center,</span><br><span class="line">      child: FutureBuilder(</span><br><span class="line">          future: _dio.<span class="keyword">get</span>(<span class="string">&quot;https://api.github.com/orgs/flutterchina/repos&quot;</span>),</span><br><span class="line">          builder: (BuildContext context, AsyncSnapshot snapshot) &#123;</span><br><span class="line">            <span class="comment">//请求完成</span></span><br><span class="line">            <span class="keyword">if</span> (snapshot.connectionState == ConnectionState.done) &#123;</span><br><span class="line">              Response response = snapshot.data;</span><br><span class="line">              <span class="comment">//发生错误</span></span><br><span class="line">              <span class="keyword">if</span> (snapshot.hasError) &#123;</span><br><span class="line">                <span class="keyword">return</span> Text(snapshot.error.toString());</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//请求成功，通过项目信息构建用于显示项目名称的ListView</span></span><br><span class="line">              <span class="keyword">return</span> ListView(</span><br><span class="line">                children: response.data.map&lt;Widget&gt;((e) =&gt;</span><br><span class="line">                    ListTile(title: Text(e[<span class="string">&quot;full_name&quot;</span>]))</span><br><span class="line">                ).toList(),</span><br><span class="line">              );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//请求未完成时弹出loading</span></span><br><span class="line">            <span class="keyword">return</span> CircularProgressIndicator();</span><br><span class="line">          &#125;</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-4-实例：HTTP分块下载"><a href="#11-4-实例：HTTP分块下载" class="headerlink" title="11.4 实例：HTTP分块下载"></a>11.4 实例：HTTP分块下载</h4><p>Http 协议定义了分块传输的响应 header 字段，具体是否支持取决于 Server 的实现，可以指定 range 字段验证服务器是否支持分块传输，例如，可以利用 curl 命令来验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xxx:~ duwen$ curl -H &quot;Range: bytes=0-10&quot; http://download.dcloud.net.cn/HBuilder.9.0.2.macosx_64.dmg -v</span><br><span class="line"><span class="meta">#</span><span class="bash"> 请求头</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GET /HBuilder.9.0.2.macosx_64.dmg HTTP/1.1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Host: download.dcloud.net.cn</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> User-Agent: curl/7.54.0</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Accept: */*</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Range: bytes=0-10</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 响应头</span></span><br><span class="line">&lt; HTTP/1.1 206 Partial Content</span><br><span class="line">&lt; Content-Type: application/octet-stream</span><br><span class="line">&lt; Content-Length: 11</span><br><span class="line">&lt; Connection: keep-alive</span><br><span class="line">&lt; Date: Thu, 21 Feb 2019 06:25:15 GMT</span><br><span class="line">&lt; Content-Range: bytes 0-10/233295878</span><br></pre></td></tr></table></figure>

<p>请求头中添加 <code>Range: bytes=0-10</code> 告诉服务器本次请求只想获取 0-10（包括10共11个字节）这块内容，如果服务器支持分块传输，则响应状态码为206，表示部分内容，响应头中包含  Content-Range 字段</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Content-Range: bytes 0-10/233295878 //单位byte</span><br></pre></td></tr></table></figure>

<ul>
<li>示例</li>
</ul>
<p>分块下载</p>
<h4 id="11-5-WebSockets"><a href="#11-5-WebSockets" class="headerlink" title="11.5 WebSockets"></a>11.5 WebSockets</h4><p>WebSocket 协议正是为了解决客户端与服务端实时通信而产生的技术</p>
<p>Http 协议中虽然可以通过  keep-alive 机制使服务器在响应结束后链接会保持一段时间，但还是会断开。keep-alive 机制主要是用于避免在同一台服务器请求多个资源时频繁创建链接，它本质上是支持链接复用的技术，并非用于实时通信</p>
<ul>
<li>步骤</li>
</ul>
<ol>
<li>连接到 WebSocket 服务器</li>
<li>监听来自服务器的消息</li>
<li>将数据发送到服务器</li>
<li>关闭 WebSocket 连接</li>
</ol>
<h4 id="11-6-使用-Socket-API"><a href="#11-6-使用-Socket-API" class="headerlink" title="11.6 使用 Socket API"></a>11.6 使用 Socket API</h4><h4 id="11-7-Json-转-Dart-Model-类"><a href="#11-7-Json-转-Dart-Model-类" class="headerlink" title="11.7 Json 转 Dart Model 类"></a>11.7 Json 转 Dart Model 类</h4><h5 id="11-7-1-Json-转-Dart-类"><a href="#11-7-1-Json-转-Dart-类" class="headerlink" title="11.7.1 Json 转 Dart 类"></a>11.7.1 Json 转 Dart 类</h5><p>返回数据是 JSON 格式的字符串，为了方便在代码中操作 JSON，先将 JSON 格式字符串转为 Dart 对象，可以通过 <code>dart:convert</code> 中的 JSON 解码器 <code>json.decode()</code> 来实现，可以根据 JSON 字符串具体内容将其转为 List 或 Map</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个JSON格式的用户列表字符串</span></span><br><span class="line"><span class="built_in">String</span> jsonStr=<span class="string">&#x27;[&#123;&quot;name&quot;:&quot;Jack&quot;&#125;,&#123;&quot;name&quot;:&quot;Rose&quot;&#125;]&#x27;</span>;`</span><br><span class="line"><span class="comment">//将JSON字符串转为Dart对象(此处是List)</span></span><br><span class="line"><span class="built_in">List</span> items=json.decode(jsonStr);</span><br><span class="line"><span class="comment">//输出第一个用户的姓名</span></span><br><span class="line"><span class="built_in">print</span>(items[<span class="number">0</span>][<span class="string">&quot;name&quot;</span>]);</span><br></pre></td></tr></table></figure>

<p>有如下 JSON</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John Smith&quot;</span>,</span><br><span class="line">  <span class="string">&quot;email&quot;</span>: <span class="string">&quot;john@example.com&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; user = json.decode(json);</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Howdy, <span class="subst">$&#123;user[<span class="string">&#x27;name&#x27;</span>]&#125;</span>!&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;We sent the verification link to <span class="subst">$&#123;user[<span class="string">&#x27;email&#x27;</span>]&#125;</span>.&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>容易出错，比如访问属性字段名写错，编译的时候不会报错，运行时会报错</p>
<p>解决：即 Json Model 化，引入模型类 User，一个 User.fromJson 构造函数，用于从一个 map 构造出一个 User 实例 map 结构；一个 toJson 方法，将 User 实例转化为一个 map</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> email;</span><br><span class="line"></span><br><span class="line">  User(<span class="keyword">this</span>.name, <span class="keyword">this</span>.email);</span><br><span class="line"></span><br><span class="line">  User.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; json)</span><br><span class="line">      : name = json[<span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">        email = json[<span class="string">&#x27;email&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; toJson() =&gt;</span><br><span class="line">    &lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt;&#123;</span><br><span class="line">      <span class="string">&#x27;name&#x27;</span>: name,</span><br><span class="line">      <span class="string">&#x27;email&#x27;</span>: email,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Map</span> userMap = json.decode(json);</span><br><span class="line"><span class="keyword">var</span> user = User.fromJson(userMap);</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Howdy, <span class="subst">$&#123;user.name&#125;</span>!&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;We sent the verification link to <span class="subst">$&#123;user.email&#125;</span>.&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>自动生成 Model</li>
</ul>
<p>官方推荐的 json_serializable package 包，是一个自动化的源代码生成器，可以在开发阶段为我们生成 JSON 序列化模板</p>
<ul>
<li>项目中设置 json_serializable</li>
</ul>
<p>json_serializable 需要一个常规和两个开发依赖项，开发依赖项是不包含在我们应用程序源代码中的依赖项</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  json_annotation: &lt;最新版本&gt;</span><br><span class="line"></span><br><span class="line">dev_dependencies:</span><br><span class="line">  build_runner: &lt;最新版本&gt;</span><br><span class="line">  json_serializable: &lt;最新版本&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>以 json_serializable 的方式创建 model 类</li>
</ul>
<p>user.dart</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:json_annotation/json_annotation.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// User.g.dart 将在我们运行生成命令后自动生成</span></span><br><span class="line"><span class="keyword">part</span> <span class="string">&#x27;User.g.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///<span class="markdown">这个标注是告诉生成器，这个类是需要生成Model类的</span></span></span><br><span class="line"><span class="meta">@JsonSerializable</span>()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">  User(<span class="keyword">this</span>.name, <span class="keyword">this</span>.email);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">String</span> email;</span><br><span class="line">  <span class="comment">//不同的类使用不同的mixin即可</span></span><br><span class="line">  <span class="keyword">factory</span> User.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; json) =&gt; _$UserFromJson(json);</span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; toJson() =&gt; _$UserToJson(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了上面设置，源码生成器将生成用于序列化 name 和 email 字段的 JSON 代码</p>
<ul>
<li>自定义命名策略</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显式关联JSON字段名与Model属性的对应关系 </span></span><br><span class="line"><span class="meta">@JsonKey</span>(name: <span class="string">&#x27;registration_date_millis&#x27;</span>)</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">int</span> registrationDateMillis;</span><br></pre></td></tr></table></figure>

<ul>
<li>运行代码生成程序</li>
</ul>
<p>上面的代码会报错，必须运行代码生成器来生成序列化模板</p>
<ul>
<li>一次性生成</li>
</ul>
<p>在项目根目录运行 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flutter packages pub run build_runner build</span><br></pre></td></tr></table></figure>

<p>这触发了一次构建，会通过源文件，找出需要生成 Model 类的源文件（包含 @JsonSerializable标注的）来生成对应的 .g.dart 文件；可以将所有 Model 类放到一个目录，然后在该目录执行命令</p>
<ul>
<li>持续生成</li>
</ul>
<p>使用 <code>_watcher_</code> 使源代码生成更加方便，会监视我们项目中文件的变换，并在需要时自动构建必要的文件</p>
<p>在项目根目录运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter packages pub run build_runner watch</span><br></pre></td></tr></table></figure>

<p>只需启动一次观察，然后就会在后台运行</p>
<h5 id="11-7-2-自动化生成模板"><a href="#11-7-2-自动化生成模板" class="headerlink" title="11.7.2 自动化生成模板"></a>11.7.2 自动化生成模板</h5><p>。。。</p>
<ul>
<li>json_model 包</li>
</ul>
<p>笔者发布的 json_model 包，把包加入开发依赖后，便可以用一条命令，根据 json 文件生成 Dart 类</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/01/18/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E5%9B%9B%EF%BC%9A%E5%B8%83%E5%B1%80%E7%B1%BB%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>title: 《Flutter实战第二版》四：布局类组件<br>abstract: 输入密码<br>message: 输入密码<br>date: 2022-01-18 12:17:35<br>tags: flutter<br>categories: flutter<br>password:</p>
<h3 id="4-布局类组件"><a href="#4-布局类组件" class="headerlink" title="4 布局类组件"></a>4 布局类组件</h3><h4 id="4-2-布局原理与约束"><a href="#4-2-布局原理与约束" class="headerlink" title="4.2 布局原理与约束"></a>4.2 布局原理与约束</h4><p>尺寸限制类容器用于限制容器大小，如 ConstrainedBox、SizedBox、UnconstrainedBox、AspectRatio等</p>
<p>Flutter 有两种布局模型<br>基于 RenderBox 的盒模型布局<br>基于 Sliver（RenderBox）按需加载列表布局</p>
<ul>
<li>布局流程</li>
</ul>
<p>上层组件向下层组件传递约束条件<br>下层组件确定自己的大小，然后告诉上层组件。注意下层组件的大小必须符合父组件的约束<br>上层组件确定下层组件相对于自身的偏移和确定自身的大小（大多数情况下会根据子组件的大小来确定自身大小）</p>
<p>比如，父组件传递给子组件的约束是“最大宽高不能超过100，最小宽高为0”，如果给子组件设宽高都为100，则子组件最终大小是 100*100，因为任何时候子组件都必须遵守父组件的约束</p>
<h5 id="4-2-1-BoxConstraints"><a href="#4-2-1-BoxConstraints" class="headerlink" title="4.2.1 BoxConstraints"></a>4.2.1 BoxConstraints</h5><p>盒模型布局过程中父渲染对象传递给子渲染对象的 <code>约束信息</code>，包含最大宽高信息，子组件大小需要在约束的范围内</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> BoxConstraints(&#123;</span><br><span class="line">  <span class="keyword">this</span>.minWidth = <span class="number">0.0</span>, <span class="comment">//最小宽度</span></span><br><span class="line">  <span class="keyword">this</span>.maxWidth = <span class="built_in">double</span>.infinity, <span class="comment">//最大宽度</span></span><br><span class="line">  <span class="keyword">this</span>.minHeight = <span class="number">0.0</span>, <span class="comment">//最小高度</span></span><br><span class="line">  <span class="keyword">this</span>.maxHeight = <span class="built_in">double</span>.infinity <span class="comment">//最大高度</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>BoxConstraints 还定义了便捷的构造函数</p>
<p>生成固定宽高的限制</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">constraints: BoxConstraints.tight(Size(<span class="number">100</span>, <span class="number">200</span>)),</span><br></pre></td></tr></table></figure>

<p>生成尽可能大的用以填充另一个容器的 BoxConstraints</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">constraints: BoxConstraints.expand(),</span><br></pre></td></tr></table></figure>

<h5 id="4-2-2-ConstrainedBox"><a href="#4-2-2-ConstrainedBox" class="headerlink" title="4.2.2 ConstrainedBox"></a>4.2.2 ConstrainedBox</h5><p>用于对子组件添加 <code>额外约束</code></p>
<p>实现一个最小高度为50，宽度尽可能大的红色容器</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先定义一个背景色红色盒子，不指定宽高</span></span><br><span class="line">Widget redBox = DecoratedBox(</span><br><span class="line">    decoration: BoxDecoration(color: Colors.red),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">body: Container(</span><br><span class="line">  child: ConstrainedBox(</span><br><span class="line">    constraints: BoxConstraints(</span><br><span class="line">      minWidth: <span class="built_in">double</span>.infinity,<span class="comment">//宽度尽可能大</span></span><br><span class="line">      minHeight: <span class="number">50.0</span>,<span class="comment">//最小高度50</span></span><br><span class="line">    ),</span><br><span class="line">    child: Container(</span><br><span class="line">      height: <span class="number">5</span>,</span><br><span class="line">      child: redBox,</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<p>虽然 Container 高度设置为 5 但最终高度是 50，正是 ConstrainedBox 最小高度限制生效了</p>
<p><img src="/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E5%9B%9B%EF%BC%9A%E5%B8%83%E5%B1%80%E7%B1%BB%E7%BB%84%E4%BB%B6/WeChatb3dfacd2a03676594b4be71803e35712.png" alt="WeChatb3dfacd2a03676594b4be71803e35712"></p>
<h5 id="4-2-3-SizedBox"><a href="#4-2-3-SizedBox" class="headerlink" title="4.2.3 SizedBox"></a>4.2.3 SizedBox</h5><p>用于给子元素指定固定的宽高</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">SizedBox(</span><br><span class="line">  width: <span class="number">80</span>,</span><br><span class="line">  height: <span class="number">80</span>,</span><br><span class="line">  child: redBox,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>实际上 SizedBox 只是 ConstrainedBox 的一个定制</p>
<h5 id="4-2-4-多重限制"><a href="#4-2-4-多重限制" class="headerlink" title="4.2.4 多重限制"></a>4.2.4 多重限制</h5><p>如果组件有多个父级 ConstrainedBox 限制，最终哪个会生效？</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ConstrainedBox(</span><br><span class="line">  constraints: BoxConstraints(minWidth: <span class="number">60.0</span>, minHeight: <span class="number">60.0</span>), <span class="comment">//父</span></span><br><span class="line">  child: ConstrainedBox(</span><br><span class="line">    constraints: BoxConstraints(minWidth: <span class="number">90.0</span>, minHeight: <span class="number">20.0</span>),<span class="comment">//子</span></span><br><span class="line">    child: redBox,</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>最终显示宽度 90，高度 60</p>
<p>多重限制时，对于 minWidth minHeight 是取父子中数值较大的</p>
<h5 id="4-2-5-UnconstrainedBox"><a href="#4-2-5-UnconstrainedBox" class="headerlink" title="4.2.5 UnconstrainedBox"></a>4.2.5 UnconstrainedBox</h5><p>子组件不再受父组件约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body: Container(</span><br><span class="line">  child: ConstrainedBox(</span><br><span class="line">    constraints: BoxConstraints(minWidth: 60, minHeight: 100),</span><br><span class="line">    child: UnconstrainedBox(&#x2F;&#x2F;去除父级限制</span><br><span class="line">      child: ConstrainedBox(</span><br><span class="line">        constraints: BoxConstraints(minWidth: 90, minHeight: 20),</span><br><span class="line">        child: redBox,</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<p>如果没有 UnconstrainedBox，那么根据多重限制的规则最终显示是 90x100<br>由于 UnconstrainedBox，去除了父级限制，最终按子 ConstrainedBox 限制来绘制 redBox，redBox 最终宽 90 高 20</p>
<p>实际开发中，如果已经使用了 SizedBox 或 ConstrainedBox 给子元素指定了固定宽高，但没有效果时，几乎可以断定，已经有父组件指定了约束</p>
<h5 id="4-2-6-其它约束类容器"><a href="#4-2-6-其它约束类容器" class="headerlink" title="4.2.6 其它约束类容器"></a>4.2.6 其它约束类容器</h5><p>AspectRatio，可以指定子组件的长宽比</p>
<p>LimitedBox，可以指定最大宽高</p>
<p>FractionallySizeBox，可以根据父容器宽高的百分比来设置子组件宽高</p>
<h4 id="4-3-线性布局"><a href="#4-3-线性布局" class="headerlink" title="4.3 线性布局"></a>4.3 线性布局</h4><p>线性布局中有两个定义对齐方式的枚举类 MainAxisAlignment 和 CrossAxisAlignment，分别代表主轴对齐和纵轴对齐</p>
<h5 id="4-3-1-Row"><a href="#4-3-1-Row" class="headerlink" title="4.3.1 Row"></a>4.3.1 Row</h5><p>可以沿水平方向排列其子 Widget</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Row(&#123;</span><br><span class="line">  ...  </span><br><span class="line">  TextDirection textDirection,    </span><br><span class="line">  MainAxisSize mainAxisSize = MainAxisSize.max,    </span><br><span class="line">  MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,</span><br><span class="line">  VerticalDirection verticalDirection = VerticalDirection.down,  </span><br><span class="line">  CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,</span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>textDirection 水平方向子组件的布局顺序，从左到右 TextDirection.ltr，从右到左 TextDirection.rtl </p>
<p>mainAxisSize 表示 Row 在主轴（水平）方向占用的空间，MainAxisSize.max 尽可能多的占用水平空间，MainAxisSize.min 尽可能少的占用水平空间</p>
<p>mainAxisAlignment 子组件在 Row 所占空间内对齐方式，MainAxisAlignment.start 表示沿着 textDirection 的初始方向对齐</p>
<p>verticalDirection 纵轴的对齐方向，默认 VerticalDirection.down 从上到下</p>
<p>crossAxisAlignment 子组件在纵轴方向对齐方式</p>
<h5 id="4-3-2-Column"><a href="#4-3-2-Column" class="headerlink" title="4.3.2 Column"></a>4.3.2 Column</h5><p>可以沿垂直方向排列其子组件</p>
<h4 id="4-4-弹性布局"><a href="#4-4-弹性布局" class="headerlink" title="4.4 弹性布局"></a>4.4 弹性布局</h4><p>弹性布局允许子组件按照一定比例来分配父容器空间</p>
<ul>
<li>Flex     </li>
</ul>
<p>Flex 组件可以沿着水平或垂直方向布局子组件，Row 和 Column 都继承自 Flex，参数基本相同，能使用 Flex 的地方都可以使用 Row 或 Column，它也可以和 Expanded 组件配合实现弹性布局</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Flex(&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">this</span>.direction, <span class="comment">//弹性布局的方向, Row默认为水平方向，Column默认为垂直方向</span></span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>Expanded</li>
</ul>
<p>只能作为 Flex 的孩子，它可以按比例扩伸 Flex 子组件所占用的空间</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Expanded(&#123;</span><br><span class="line">  <span class="built_in">int</span> flex = <span class="number">1</span>, </span><br><span class="line">  <span class="keyword">required</span> Widget child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>flex 为弹性系数，为 0 或 null，则 child 是没有弹性的，如果大于 0，所有的 Expand 按照其 flex 的比例来分割主轴的全部剩余空间</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">body: Column(</span><br><span class="line">  children: [</span><br><span class="line">    Flex(</span><br><span class="line">        direction: Axis.horizontal,</span><br><span class="line">        children: [</span><br><span class="line">          Expanded(</span><br><span class="line">              flex: <span class="number">1</span>,</span><br><span class="line">              child: Container(</span><br><span class="line">                height: <span class="number">30</span>,</span><br><span class="line">                color: Colors.red,</span><br><span class="line">              ),</span><br><span class="line">          ),</span><br><span class="line">          Expanded(</span><br><span class="line">              flex: <span class="number">2</span>,</span><br><span class="line">              child: Container(</span><br><span class="line">                height: <span class="number">30</span>,</span><br><span class="line">                color: Colors.green,</span><br><span class="line">              ),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">    ),</span><br><span class="line">    Padding(</span><br><span class="line">        padding: EdgeInsets.only(top: <span class="number">20</span>),</span><br><span class="line">        child: SizedBox(</span><br><span class="line">          height: <span class="number">100</span>,</span><br><span class="line">          child: Flex(</span><br><span class="line">              direction: Axis.vertical,</span><br><span class="line">              children: [</span><br><span class="line">                Expanded(</span><br><span class="line">                    flex: <span class="number">2</span>,</span><br><span class="line">                    child: Container(</span><br><span class="line">                      height: <span class="number">30</span>,</span><br><span class="line">                      color: Colors.red,</span><br><span class="line">                    ),</span><br><span class="line">                ),</span><br><span class="line">                Spacer( <span class="comment">//Spacer 占用指定比例的空间</span></span><br><span class="line">                    flex: <span class="number">1</span>,</span><br><span class="line">                ),</span><br><span class="line">                Expanded(</span><br><span class="line">                    flex: <span class="number">1</span>,</span><br><span class="line">                    child: Container(</span><br><span class="line">                      height: <span class="number">30</span>,</span><br><span class="line">                      color: Colors.green,</span><br><span class="line">                    ),</span><br><span class="line">                ),</span><br><span class="line">              ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">    ),</span><br><span class="line">  ],</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E5%9B%9B%EF%BC%9A%E5%B8%83%E5%B1%80%E7%B1%BB%E7%BB%84%E4%BB%B6/WeChatfbc763c47e927557d16a3e4f1bfe01c1.png" alt="WeChatfbc763c47e927557d16a3e4f1bfe01c1"></p>
<p>Spacer  的功能是占用指定比例的空间，只是 Expanded 的一个包装类</p>
<h4 id="4-5-流式布局"><a href="#4-5-流式布局" class="headerlink" title="4.5 流式布局"></a>4.5 流式布局</h4><p>Row 和 Column，如果子 widget 超出屏幕范围时，会溢出报错</p>
<p>超出屏幕范围会自动折行的布局称为流式布局，通过 Wrap 和 Flow 来支持</p>
<h5 id="4-5-1-Wrap"><a href="#4-5-1-Wrap" class="headerlink" title="4.5.1 Wrap"></a>4.5.1 Wrap</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Wrap(&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">this</span>.direction = Axis.horizontal,</span><br><span class="line">  <span class="keyword">this</span>.alignment = WrapAlignment.start,</span><br><span class="line">  <span class="keyword">this</span>.spacing = <span class="number">0.0</span>,		<span class="comment">//主轴方向子 widget 的间距</span></span><br><span class="line">  <span class="keyword">this</span>.runAlignment = WrapAlignment.start, <span class="comment">//纵轴方向对齐方式</span></span><br><span class="line">  <span class="keyword">this</span>.runSpacing = <span class="number">0.0</span>, <span class="comment">//纵轴方向的间距</span></span><br><span class="line">  <span class="keyword">this</span>.crossAxisAlignment = WrapCrossAlignment.start,</span><br><span class="line">  <span class="keyword">this</span>.textDirection,</span><br><span class="line">  <span class="keyword">this</span>.verticalDirection = VerticalDirection.down,</span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">body: Wrap(</span><br><span class="line">  spacing: <span class="number">8</span>, <span class="comment">// 主轴(水平)方向间距</span></span><br><span class="line">  runSpacing: <span class="number">4</span>,<span class="comment">// 纵轴（垂直）方向间距</span></span><br><span class="line">  alignment: WrapAlignment.center,<span class="comment">//沿主轴方向居中</span></span><br><span class="line">  children: [</span><br><span class="line">    Chip(</span><br><span class="line">      avatar: CircleAvatar(backgroundColor: Colors.blue, child: Text(<span class="string">&quot;A&quot;</span>)),</span><br><span class="line">      label: Text(<span class="string">&quot;Hamilton&quot;</span>),</span><br><span class="line">    ),</span><br><span class="line">    Chip(</span><br><span class="line">      avatar: CircleAvatar(backgroundColor: Colors.blue, child: Text(<span class="string">&quot;M&quot;</span>)),</span><br><span class="line">      label: Text(<span class="string">&quot;Lafayette&quot;</span>),</span><br><span class="line">    ),</span><br><span class="line">    Chip(</span><br><span class="line">      avatar: CircleAvatar(backgroundColor: Colors.blue, child: Text(<span class="string">&quot;H&quot;</span>)),</span><br><span class="line">      label: Text(<span class="string">&quot;Mulligan&quot;</span>),</span><br><span class="line">    ),</span><br><span class="line">    Chip(</span><br><span class="line">      avatar: CircleAvatar(backgroundColor: Colors.blue, child: Text(<span class="string">&quot;J&quot;</span>)),</span><br><span class="line">      label: Text(<span class="string">&quot;Laurens&quot;</span>),</span><br><span class="line">    ),</span><br><span class="line">  ],</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<p><img src="/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E5%9B%9B%EF%BC%9A%E5%B8%83%E5%B1%80%E7%B1%BB%E7%BB%84%E4%BB%B6/WeChat3d54f85053626129a97f139ca49e747e.png" alt="WeChat3d54f85053626129a97f139ca49e747e"></p>
<h5 id="4-5-2-Flow"><a href="#4-5-2-Flow" class="headerlink" title="4.5.2 Flow"></a>4.5.2 Flow</h5><p>一般很少使用 Flow，因为其过于复杂，需要自己实现子 widget 的位置转换，很多情况下首先要考虑 Wrap 是否满足需求</p>
<p>主要用于一些自定义布局策略或性能要求较高（如动画）的场景</p>
<h4 id="4-6-层叠布局"><a href="#4-6-层叠布局" class="headerlink" title="4.6 层叠布局"></a>4.6 层叠布局</h4><p>Flutter 中使用 Stack 和 Positioned 这两个组件来配合实现绝对定位，Stack 允许子组件堆叠，而 Positioned 用于根据 Stack 的四个角来确定子组件的位置</p>
<h5 id="4-6-1-Stack"><a href="#4-6-1-Stack" class="headerlink" title="4.6.1 Stack"></a>4.6.1 Stack</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Stack(&#123;</span><br><span class="line">  <span class="keyword">this</span>.alignment = AlignmentDirectional.topStart,</span><br><span class="line">  <span class="keyword">this</span>.textDirection,</span><br><span class="line">  <span class="keyword">this</span>.fit = StackFit.loose,</span><br><span class="line">  <span class="keyword">this</span>.overflow = Overflow.clip,</span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>fit 用于确定没有定位的子组件如何去适应 Stack 的大小。StackFit.loose 表示使用子组件的大小，StackFit.expand 表示扩伸到 Stack 的大小</p>
<h5 id="4-6-2-Positioned"><a href="#4-6-2-Positioned" class="headerlink" title="4.6.2 Positioned"></a>4.6.2 Positioned</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Positioned(&#123;</span><br><span class="line">  Key? key,</span><br><span class="line">  <span class="keyword">this</span>.left, </span><br><span class="line">  <span class="keyword">this</span>.top,</span><br><span class="line">  <span class="keyword">this</span>.right,</span><br><span class="line">  <span class="keyword">this</span>.bottom,</span><br><span class="line">  <span class="keyword">this</span>.width,</span><br><span class="line">  <span class="keyword">this</span>.height,</span><br><span class="line">  <span class="keyword">required</span> Widget child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>left、right、top、bottom 分别代表 Stack 左、右、上、下四边的距离。width、height 用于配合 left、right、top、bottom 来定位组件，水平方向时，只能指定 left、right、width 三个属性中的两个</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过ConstrainedBox来确保Stack占满屏幕</span></span><br><span class="line">ConstrainedBox(</span><br><span class="line">  constraints: BoxConstraints.expand(),</span><br><span class="line">  child: Stack(</span><br><span class="line">    alignment:Alignment.center , <span class="comment">//指定未定位或部分定位widget的对齐方式</span></span><br><span class="line">    children: &lt;Widget&gt;[</span><br><span class="line">      Container(</span><br><span class="line">        child: Text(<span class="string">&quot;Hello world&quot;</span>,style: TextStyle(color: Colors.white)),</span><br><span class="line">        color: Colors.red,</span><br><span class="line">      ),</span><br><span class="line">      Positioned(</span><br><span class="line">        left: <span class="number">18.0</span>,</span><br><span class="line">        child: Text(<span class="string">&quot;I am Jack&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">      Positioned(</span><br><span class="line">        top: <span class="number">18.0</span>,</span><br><span class="line">        child: Text(<span class="string">&quot;Your friend&quot;</span>),</span><br><span class="line">      )        </span><br><span class="line">    ],</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》四：布局类组件/WeChatb7f223696d8793b8c8b7ad2a3a70efe0.png" alt="WeChatb7f223696d8793b8c8b7ad2a3a70efe0" style="zoom:80%;" />

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Stack(</span><br><span class="line">  alignment:Alignment.center ,</span><br><span class="line">  fit: StackFit.expand, <span class="comment">//未定位widget占满Stack整个空间</span></span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    Positioned(</span><br><span class="line">      left: <span class="number">18.0</span>,</span><br><span class="line">      child: Text(<span class="string">&quot;I am Jack&quot;</span>),</span><br><span class="line">    ),</span><br><span class="line">    Container(child: Text(<span class="string">&quot;Hello world&quot;</span>,style: TextStyle(color: Colors.white)),</span><br><span class="line">      color: Colors.red,</span><br><span class="line">    ),</span><br><span class="line">    Positioned(</span><br><span class="line">      top: <span class="number">18.0</span>,</span><br><span class="line">      child: Text(<span class="string">&quot;Your friend&quot;</span>),</span><br><span class="line">    )</span><br><span class="line">  ],</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》四：布局类组件/WeChat292f6adf44bfae8dcc84ab16cd736158.png" alt="WeChat292f6adf44bfae8dcc84ab16cd736158" style="zoom:80%;" />

<p>第二个文本组件没有定位，fit 属性会对它起作用，就会占满 Stack，Stack 子元素是堆叠的，所以第一个组件被第二个遮挡住了，第三个在最上层正常显示</p>
<h4 id="4-7-对齐与相对定位"><a href="#4-7-对齐与相对定位" class="headerlink" title="4.7 对齐与相对定位"></a>4.7 对齐与相对定位</h4><p>Stack 和 Positioned，我们可以指定一个或多个子元素相对父元素各个边的偏移，并且可以堆叠；如果只想简单调整下一个子元素在父元素中的位置的话使用 Align 组件更简单</p>
<h5 id="4-7-1-Align"><a href="#4-7-1-Align" class="headerlink" title="4.7.1 Align"></a>4.7.1 Align</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Align(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  <span class="keyword">this</span>.alignment = Alignment.center,</span><br><span class="line">  <span class="keyword">this</span>.widthFactor,</span><br><span class="line">  <span class="keyword">this</span>.heightFactor,</span><br><span class="line">  Widget child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>widthFactor，heightFactor 用于确定 Align 组件本身宽高属性，是两个缩放因子，如果为 null，则组件的宽高会占用尽可能多的空间</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">body: Container(</span><br><span class="line">  width: <span class="number">120</span>,</span><br><span class="line">  height: <span class="number">120</span>,</span><br><span class="line">  color: Colors.red,</span><br><span class="line">  child: Align(</span><br><span class="line">    alignment: Alignment.topRight,</span><br><span class="line">    child: FlutterLogo(size: <span class="number">60</span>),</span><br><span class="line">  ),</span><br><span class="line">),</span><br><span class="line"><span class="comment">//相同效果 FlutterLogo宽高为60 则最终宽高都为 120</span></span><br><span class="line">Align(</span><br><span class="line">  widthFactor: <span class="number">2</span>,</span><br><span class="line">  heightFactor: <span class="number">2</span>,</span><br><span class="line">  alignment: Alignment.topRight,</span><br><span class="line">  child: FlutterLogo(size: <span class="number">60</span>),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》四：布局类组件/WeChat8615b0b3da0d913f7ac3f52a0b453f34.png" alt="WeChat8615b0b3da0d913f7ac3f52a0b453f34" style="zoom:80%;" />

<ul>
<li>Alignment</li>
</ul>
<p>继承自 AlignmentGeometry，x y 分别表示在水平和垂直方向偏移</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alignment(this.x, this.y)</span><br></pre></td></tr></table></figure>

<p>会以矩形中心点作为原点，x y 值从 -1 到 1 分别代表矩形左边到右边的距离和顶部到底部的距离，Alignment(-1,-1) 代表左上角顶点</p>
<ul>
<li>FractionalOffset</li>
</ul>
<p>FractionalOffset 继承自 Alignment，唯一区别就是坐标原点不同，坐标原点为矩形左侧顶点</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Container(</span><br><span class="line">  height: <span class="number">120.0</span>,</span><br><span class="line">  width: <span class="number">120.0</span>,</span><br><span class="line">  color: Colors.blue[<span class="number">50</span>],</span><br><span class="line">  child: Align(</span><br><span class="line">    alignment: FractionalOffset(<span class="number">0.2</span>, <span class="number">0.6</span>),</span><br><span class="line">    child: FlutterLogo(</span><br><span class="line">      size: <span class="number">60</span>,</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="4-7-2-Align-和-Stack-对比"><a href="#4-7-2-Align-和-Stack-对比" class="headerlink" title="4.7.2 Align 和 Stack 对比"></a>4.7.2 Align 和 Stack 对比</h5><p>定位参考系统不同；Stack/Positioned 定位参考系可以是父容器的四个顶点，Align 则需要通过 aligment 参数来确定坐标原点</p>
<p>Stack 可以有多个子元素，并且子元素可以堆叠，而 Align 只能有一个子元素，不存在堆叠</p>
<h5 id="4-7-3-Center-组件"><a href="#4-7-3-Center-组件" class="headerlink" title="4.7.3 Center 组件"></a>4.7.3 Center 组件</h5><p>Center 继承自 Align，比 Align 少了一个 aligment 参数</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">...<span class="comment">//省略无关代码</span></span><br><span class="line">DecoratedBox(</span><br><span class="line">  decoration: BoxDecoration(color: Colors.red),</span><br><span class="line">  child: Center(</span><br><span class="line">    child: Text(<span class="string">&quot;xxx&quot;</span>),</span><br><span class="line">  ),</span><br><span class="line">),</span><br><span class="line">DecoratedBox(</span><br><span class="line">  decoration: BoxDecoration(color: Colors.red),</span><br><span class="line">  child: Center(</span><br><span class="line">    widthFactor: <span class="number">1</span>,</span><br><span class="line">    heightFactor: <span class="number">1</span>,</span><br><span class="line">    child: Text(<span class="string">&quot;xxx&quot;</span>),</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》四：布局类组件/WeChat5e3ebd6ef218ee6f1388e9e97b95ecb0.png" alt="WeChat5e3ebd6ef218ee6f1388e9e97b95ecb0" style="zoom:80%;" />

<ul>
<li>总结</li>
</ul>
<p>在需要指定一些精确的偏移时优先使用 FractionalOffset，因为它的坐标原点和布局系统相同</p>
<h4 id="4-8-LayoutBuilder、AfterLayout"><a href="#4-8-LayoutBuilder、AfterLayout" class="headerlink" title="4.8 LayoutBuilder、AfterLayout"></a>4.8 LayoutBuilder、AfterLayout</h4><h5 id="4-8-1-LayoutBuilder"><a href="#4-8-1-LayoutBuilder" class="headerlink" title="4.8.1 LayoutBuilder"></a>4.8.1 LayoutBuilder</h5><p>通过  LayoutBuilder 我们可以在布局过程中拿到父组件传递的约束信息，然后可以根据约束信息动态的构建不同的布局</p>
<p>例子：当当前可用宽度小于200时，将子组件显示为一列，否则显示为两列</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResponsiveColumn</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ResponsiveColumn(&#123;Key? key, <span class="keyword">required</span> <span class="keyword">this</span>.children&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Widget&gt; children;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 通过 LayoutBuilder 拿到父组件传递的约束，然后判断 maxWidth 是否小于200</span></span><br><span class="line">    <span class="keyword">return</span> LayoutBuilder(</span><br><span class="line">      builder: (BuildContext context, BoxConstraints constraints) &#123;</span><br><span class="line">        <span class="keyword">if</span> (constraints.maxWidth &lt; <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="comment">// 最大宽度小于200，显示单列</span></span><br><span class="line">          <span class="keyword">return</span> Column(children: children, mainAxisSize: MainAxisSize.min);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 大于200，显示双列</span></span><br><span class="line">          <span class="keyword">var</span> _children = &lt;Widget&gt;[];</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; children.length) &#123;</span><br><span class="line">              _children.add(Row(</span><br><span class="line">                children: [children[i], children[i + <span class="number">1</span>]],</span><br><span class="line">                mainAxisSize: MainAxisSize.min,</span><br><span class="line">              ));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              _children.add(children[i]);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> Column(children: _children, mainAxisSize: MainAxisSize.min);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LayoutBuilderRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> LayoutBuilderRoute(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">var</span> _children = <span class="built_in">List</span>.filled(<span class="number">6</span>, Text(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">    <span class="comment">// Column在本示例中在水平方向的最大宽度为屏幕的宽度</span></span><br><span class="line">    <span class="keyword">return</span> Column(</span><br><span class="line">      children: [</span><br><span class="line">        <span class="comment">// 限制宽度为190，小于 200</span></span><br><span class="line">        SizedBox(width: <span class="number">190</span>, child: ResponsiveColumn(children: _children)),</span><br><span class="line">        ResponsiveColumn(children: _children),</span><br><span class="line">        LayoutLogPrint(child:Text(<span class="string">&quot;xx&quot;</span>)) <span class="comment">// 下面介绍</span></span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用 LayoutBuilder 来根据设备的尺寸来实现响应式布局</p>
<p>LayoutBuilder 可以帮助排查问题，如遇到布局问题或想调试组件树中一个节点布局的约束时</p>
<h5 id="4-8-2-AfterLayout"><a href="#4-8-2-AfterLayout" class="headerlink" title="4.8.2 AfterLayout"></a>4.8.2 AfterLayout</h5><p>作者封装的组件，可以在子组件布局完成后执行一个回调</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AfterLayout(</span><br><span class="line">  callback: (RenderAfterLayout ral) &#123;</span><br><span class="line">    <span class="built_in">print</span>(ral.size); <span class="comment">//子组件的大小</span></span><br><span class="line">    <span class="built_in">print</span>(ral.offset);<span class="comment">// 子组件在屏幕中坐标</span></span><br><span class="line">  &#125;,</span><br><span class="line">  child: Text(<span class="string">&#x27;flutter@wendux&#x27;</span>),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

































]]></content>
  </entry>
  <entry>
    <title>音视频开发</title>
    <url>/2021/08/03/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h4 id="音视频基础"><a href="#音视频基础" class="headerlink" title="音视频基础"></a>音视频基础</h4><h5 id="数字音频"><a href="#数字音频" class="headerlink" title="数字音频"></a>数字音频</h5><p>将模拟信号转换为数字信号的过程</p>
<ul>
<li>采样</li>
</ul>
<p>在时间轴上对信号进行数字化。</p>
<p>根据奈奎斯特定理（也称为采样定理），按比声音最高频率高2倍以上的频率对声音进行采样（也称为AD转换）</p>
<p>比如：对高质量音频信号，其频率范围是20Hz~20kHz（人耳能够听到的频率范围），所以采样频率一般为44.1kHz，这样就可以保证采样声音达到20kHz也能被数字化，从而使得经过数字化处理之后，人耳听到的声音质量不会被降低</p>
<p>44.1kHz就是代表1秒会采样44100次</p>
<ul>
<li>量化</li>
</ul>
<p>在幅度轴上对信号进行数字化</p>
<ul>
<li>编码</li>
</ul>
<p>按照一定的格式记录采样和量化后的数字数据</p>
<p>音频格式有很多种，音频裸数据格式就是脉冲编码调制（PCM）数据。</p>
<p>描述一段PCM数据一般需要以下几个概念：<br>量化格式（sampleFormat）<br>采样率（sampleRate）<br>声道数（channel）</p>
<p>以CD音质为例：量化格式为16比特（2字节），采样率为44100，声道数为2，这些信息就描述</p>
<p>CD音质的比特率：即1秒时间内的比特数目，衡量音频数据单位时间内的容量大小<br>44100 * 16 * 2 = 1378.125kbps</p>
<p>那么1分钟内，这类CD音质的数据需要占据多大内存空间？<br>1378.125 * 60 / 8 / 1024 = 10.09M</p>
<p>如果sampleFormat更加精确（比如用4字节来描述一个采样）或者sampleRate更加密集（比如48kHz的采样率）那么所占的存储空间会更大，同时能够描述的声音细节会越精确</p>
<h5 id="音频编码"><a href="#音频编码" class="headerlink" title="音频编码"></a>音频编码</h5><p>通过计算CD音质的数据采样，每分钟需要存储10.1M，若要在网络中实时在线传播的话，数据量可能就太大了，需要进行压缩编码</p>
<p>压缩算法包括有损压缩和无损压缩，无损压缩是指解压后的数据可以完全恢复，有损压缩解压后的数据不能完全恢复，会丢失一部分信息，压缩比越小，丢失的信息就越多</p>
<p>压缩编码实际上是压缩掉冗余信号，冗余信号是指不能被人耳感知到的信号</p>
<p>常见压缩编码格式：</p>
<ol>
<li>WAV编码</li>
</ol>
<p>在PCM数据格式前加上44字节，分辨用来描述PCM的采样率、声道数、数据格式等信息</p>
<p>特点：音质非常好，大量软件都支持其播放</p>
<p>适合场所：多媒体开发中的中间文件，保存音乐和音效素材</p>
<ol start="2">
<li>MP3编码</li>
</ol>
<p>具有不错的压缩比，听感上非常解决WAV文件</p>
<p>特点：音质在128kbps/s以上表现还不错，压缩比比较高，大量软件和硬件都支持，兼容性好</p>
<p>适合场所：搞比特率下对兼容性有要求的音乐欣赏</p>
<ol start="3">
<li>AAC编码</li>
</ol>
<p>目前比较热门的有损压缩编码技术，并衍生出了LC-AAC、HE-AAC、HE-AAC v2三种主要编码格式。</p>
<p>LC-AAC 是比较传统的AAC，主要应用于中高码率场景编码（&gt;=80Kbit/s）</p>
<p>HE-AAC 主要应用于低码率场景的编码（&lt;=80Kbit/s）</p>
<p>HE-AAC v2 主要应用于低码率场景的编码（&lt;=48Kbit/s）</p>
<p>特点：在小于128Kbit/s的码率下表现优异，多用于视频中的音频编码</p>
<ol start="4">
<li>Ogg编码</li>
</ol>
<p>一种非常有潜力的编码，各种码率下都有比较优秀的表现，尤其在中低码率场景下。可以用更下的码率达到更好的音质，128Kbit/s的Ogg币192Kbit/s甚至更高码率的MP3还要出色，但目前还没有媒体服务软件的支持</p>
<p>特点：可以用比MP3更小的码率实现比MP3更好的音质，高中低码率下均有良好表现，兼容性不够好，流媒体特性不支持</p>
<p>适用场景：语音聊天的音频消息场景</p>
<h5 id="视频编码"><a href="#视频编码" class="headerlink" title="视频编码"></a>视频编码</h5><p>视频压缩也是通过去除冗余信息来进行压缩的</p>
<p>使用帧间编码技术可以去除时间上冗余信息</p>
<p>使用帧内编码技术可以去除空间上冗余信息</p>
<h5 id="编码概念"><a href="#编码概念" class="headerlink" title="编码概念"></a>编码概念</h5><p>MPEG 算法适用于动态视频的压缩算法，它除了对单幅图像进行编码外，还利用图像序列中的相关原则去除冗余，大大提高视频压缩比。</p>
<p>MPEG主要包括几个版本：Mpeg1（用于VCD）、Mpeg2（用于DVD）、Mpeg4 AVC（现在流媒体使用最多的就是它了）</p>
<p>相比较与ISO指定的MPEG的视频压缩标准，ITU-T制定的H.261、H.262、H.263、H.264一系列视频编码标准是一套单独的体系。其中H.264集中了以往标准的所有有点，采用简洁设计，使得它比Mpeg4更容易推广，现在使用最多的就是H.264标准</p>
<ul>
<li>I帧</li>
</ul>
<p>帧内编码帧，</p>
<ul>
<li><p>P帧</p>
</li>
<li><p>B帧</p>
</li>
</ul>
<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>项目增加C++支持，OC语法支持混编，把引用C++的OC类后缀名改为.mm，就可以和C++一块编译了</p>
<p>LAME 一种MP3编码引擎，转码成MP3格式的音频文件时，最常用的就是LAME库</p>
<p>编译LAME，<a href="https://lame.sourceforge.io/download.php">LAME</a> 下载不下来，使用别人编译好的版本 <a href="https://github.com/JIANHUI2015/RemoteIODemo">lame </a> 两个文件 lame.h 和 libmp3lame.a，拖进项目就可以了</p>
<h4 id="AudioUnit"><a href="#AudioUnit" class="headerlink" title="AudioUnit"></a>AudioUnit</h4><p>iOS 平台上所有的音频框架底层都是基于 AudioUnit 实现的</p>
<p>较高层次的音频框架包括：Mediia Player、AVFoundation、OpenAL、AudioToolbox，这些框架都封装了 AudioUnit，提供了更高层次的API（功能更少，职责更单一接口）</p>
<p><img src="/2021/08/03/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/AudioUnit.png" alt="AudioUnit"></p>
<p>如果对音频需要更高成都的控制、性能以及灵活性，或者想要使用一些特殊功能（回声消除）时，可以直接使用 AudioUnit API，以下场景更适合使用 AudioUnit</p>
<ul>
<li>想使用低延迟的音频 I/O（input或者output）比如说 VoIP 的应用场景下</li>
<li>多路声音的合成并且回放，比如游戏或者音乐合成器的应用</li>
<li>使用 AudioUnit 里提供的特殊功能，比如：回声消除、Mix两轨音频、以及均衡器、压缩器、混响器等效果器</li>
<li>需要图状结构来处理音频，可以将音频处理模块组装到灵活的图状结构中</li>
</ul>
<h6 id="AudioSession"><a href="#AudioSession" class="headerlink" title="AudioSession"></a>AudioSession</h6><p>音频会话，用于管理与获取 iOS 设备音频的硬件信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AVAudioSession *audioSession &#x3D; [AVAudioSession sharedInstance];</span><br><span class="line">NSError *error &#x3D; nil;</span><br><span class="line">&#x2F;&#x2F;设置以何种方式使用音频硬件</span><br><span class="line">[audioSession setCategory:AVAudioSessionCategoryPlayAndRecord error:&amp;error];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置I&#x2F;O的Buffer，Buffer越小则说明延迟越低</span><br><span class="line">NSTimeInterval bufferDuration &#x3D; 0.002;</span><br><span class="line">[audioSession setPreferredIOBufferDuration:bufferDuration error:&amp;error];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置采样频率 让硬件设备按照设置的采样频率来采集或者播放音频</span><br><span class="line">double hwSampleRate &#x3D; 44100.0;</span><br><span class="line">[audioSession setPreferredSampleRate:hwSampleRate error:&amp;error];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置完所有参数之后就可以激活 AudioSession</span><br><span class="line">[audioSession setActive:YES error:&amp;error];</span><br></pre></td></tr></table></figure>

<h6 id="构建-AudioUnit"><a href="#构建-AudioUnit" class="headerlink" title="构建 AudioUnit"></a>构建 AudioUnit</h6><p>创建并启用 AudioSession 音频会话之后就可以构建 AudioUnit 了</p>
<p>需要指定类型（Type）、子类型（subtype）以及厂商（Manufacture），利用三个变量可以完整描述一个 AudioUnit 了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AudioComponentDescription ioUnitDescription;</span><br><span class="line">ioUnitDescription.componentType &#x3D; kAudioUnitType_Output;</span><br><span class="line">ioUnitDescription.componentSubType &#x3D; kAudioUnitSubType_RemoteIO;</span><br><span class="line">&#x2F;&#x2F;比较固定 直接kAudioUnitManufacturer_Apple就可以了</span><br><span class="line">ioUnitDescription.componentManufacturer &#x3D; kAudioUnitManufacturer_Apple;</span><br><span class="line">ioUnitDescription.componentFlags &#x3D; 0;</span><br><span class="line">ioUnitDescription.componentFlagsMask &#x3D; 0;</span><br></pre></td></tr></table></figure>

<p>上面代码构造了 RemoteIO 类型的 AudioUnit 描述的结构体，下面构造 AudioUnit</p>
<p>两种方式构建：1. 使用 AudioUnit 裸的创建方式 2. 使用 AUGraph 和 AUNode 的 Wrapper 来构建</p>
<ol>
<li>裸的创建方式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;根据 AudioUnit 的描述，找出实际的 AudioUnit 类型</span><br><span class="line">AudioComponent ioUnitRef &#x3D; AudioComponentFindNext(NULL, &amp;ioUnitDescription);</span><br><span class="line">&#x2F;&#x2F;声明一个 AudioUnit 引用</span><br><span class="line">AudioUnit ioUnitInstance;</span><br><span class="line">&#x2F;&#x2F;根据类型创建 AudioUnit 实例</span><br><span class="line">AudioComponentInstanceNew(ioUnitRef, &amp;ioUnitInstance);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>AUGraph 创建方式（扩展性更高）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;声明并实例化一个AUGraph</span><br><span class="line">AUGraph processingGraph;</span><br><span class="line">NewAUGraph(&amp;processingGraph);</span><br><span class="line">&#x2F;&#x2F;按照AudioUnit的描述在AUGraph中增加一个AUNode</span><br><span class="line">AUNode ioNode;</span><br><span class="line">AUGraphAddNode(processingGraph, &amp;ioUnitDescription, &amp;ioNode);</span><br><span class="line">&#x2F;&#x2F;打开AUGraph，必须在获取AudioUnit之前打开整个AUGraph</span><br><span class="line">AUGraphOpen(processingGraph);</span><br><span class="line">&#x2F;&#x2F;在AUGraph中的某个Node里获得AudioUnit的引用</span><br><span class="line">AudioUnit ioUnit;</span><br><span class="line">AUGraphNodeInfo(processingGraph, ioNode, NULL, &amp;ioUnit);</span><br></pre></td></tr></table></figure>

<h6 id="AudioUnit-通用参数"><a href="#AudioUnit-通用参数" class="headerlink" title="AudioUnit 通用参数"></a>AudioUnit 通用参数</h6><p>以 RemoteIO  为例，RemoteIO 这个 AudioUnit 是与硬件 IO 相关的一个 Unit，分为输入和输出端，输入端一般是麦克风，输出端一般指扬声器或者耳机，如果需要同事使用输入输出，即K歌应用中的耳返功能，则需要做一些设置将他们连接起来</p>
<img src="remoteio.png" alt="remoteio" style="zoom:90%;" />

<p>RemoteIO Unit 分为 Element0 和 Element 1，Element0 控制输出端，Element1 控制输入端，每个 Element 又分为 Input Scope 和 Output Scope。</p>
<p>如果想要使用扬声器的声音播放功能，必须将这个 Unit 的 Element0 的 OutputScope 和 Speaker 进行连接</p>
<p>如果想要使用麦克风录音功能，必须将这个Unit 的 Element1 的 InputScope 和麦克风进行连接</p>
<p>使用扬声器代码：把 RemoteIOUnit的 Element0 的 OutputScope 连接到 Speaker 上，会返回一个 OSStatus 值，使用自定义 CheckStatus 函数判断错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OSStatus status &#x3D; noErr;</span><br><span class="line">UInt32 oneFlag &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F;Element 0</span><br><span class="line">UInt32 busZero &#x3D; 0;</span><br><span class="line">status &#x3D; AudioUnitSetProperty(ioUnit,</span><br><span class="line">                              kAudioOutputUnitProperty_EnableIO,</span><br><span class="line">                              kAudioUnitScope_Output,</span><br><span class="line">                              busZero,</span><br><span class="line">                              &amp;oneFlag,</span><br><span class="line">                              sizeof(oneFlag));</span><br><span class="line">&#x2F;&#x2F;自定义的CheckStatus函数来判断错误并输出</span><br><span class="line">CheckStatus(status, @&quot;Could not Connect To Speaker&quot;, YES);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CheckStatus</span><span class="params">(OSStatus status, NSString *message, BOOL fatal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status != noErr) &#123;</span><br><span class="line">        <span class="keyword">char</span> fourCC[<span class="number">16</span>];</span><br><span class="line">        *(UInt32 *)fourCC = CFSwapInt32HostToBig(status);</span><br><span class="line">        fourCC[<span class="number">4</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isprint</span>(fourCC[<span class="number">0</span>]) &amp;&amp;</span><br><span class="line">            <span class="built_in">isprint</span>(fourCC[<span class="number">1</span>]) &amp;&amp;</span><br><span class="line">            <span class="built_in">isprint</span>(fourCC[<span class="number">2</span>]) &amp;&amp;</span><br><span class="line">            <span class="built_in">isprint</span>(fourCC[<span class="number">3</span>])) &#123;</span><br><span class="line">            NSLog(@<span class="string">&quot;%@: %s&quot;</span>, message, fourCC);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            NSLog(@<span class="string">&quot;%@: %d&quot;</span>, message, (<span class="keyword">int</span>)status);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fatal) &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启用麦克风：把 RemoteIOUnit 的 Element1 的 InputScope 连接上麦克风</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Element 1</span><br><span class="line">UInt32 busOne &#x3D; 1;</span><br><span class="line">AudioUnitSetProperty(ioUnit,</span><br><span class="line">                     kAudioOutputUnitProperty_EnableIO,</span><br><span class="line">                     kAudioUnitScope_Input,</span><br><span class="line">                     busOne,</span><br><span class="line">                     &amp;oneFlag,</span><br><span class="line">                     sizeof(oneFlag));</span><br></pre></td></tr></table></figure>

<p>连接成功后，就该给 AudioUnit 设置数据格式了，AudioUnit 数据格式分为输入和输出两个部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;设置AudioUnit数据格式 AudioStreamBasicDescription描述音视频具体格式</span><br><span class="line">UInt32 bytesPerSample &#x3D; sizeof(Float32);</span><br><span class="line">AudioStreamBasicDescription asbd;</span><br><span class="line">bzero(&amp;asbd, sizeof(asbd));</span><br><span class="line"></span><br><span class="line">double _samplerRate &#x3D; 44100.0;</span><br><span class="line">UInt32 channels &#x3D; 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指定音频的编码格式 此处 PCM</span><br><span class="line">asbd.mFormatID &#x3D; kAudioFormatLinearPCM;</span><br><span class="line">&#x2F;&#x2F;采样率</span><br><span class="line">asbd.mSampleRate &#x3D; _samplerRate;</span><br><span class="line">&#x2F;&#x2F;声道数 1单身到 2立体声</span><br><span class="line">asbd.mChannelsPerFrame &#x3D; channels;</span><br><span class="line">&#x2F;&#x2F;每个Packers有几个Frame</span><br><span class="line">asbd.mFramesPerPacket &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F;mFormatFlags 描述声音表示格式的参数</span><br><span class="line">&#x2F;&#x2F;kAudioFormatFlagsNativeFloatPacked 指定每个sample的表示格式是Float格式；</span><br><span class="line">&#x2F;&#x2F;kAudioFormatFlagIsNonInterleaved   左右声道是非交错存放的</span><br><span class="line">&#x2F;&#x2F;实际的音频数据会存储在一个 AudioBufferList结构中的变量mBuffers中，如果mFormatFlags指定的是 NonInterleaved，那么左声道就会在mBuffers[0]里面，右声道就会在 mBuffers[1]里面</span><br><span class="line">asbd.mFormatFlags &#x3D; kAudioFormatFlagsNativeFloatPacked | kAudioFormatFlagIsNonInterleaved;</span><br><span class="line">&#x2F;&#x2F;一个声道的音频数据用多少位来表示</span><br><span class="line">asbd.mBitsPerChannel &#x3D; 8 * bytesPerSample;</span><br><span class="line">&#x2F;&#x2F;每一帧有多少字节 mBytesPerFrame和mBytesPerPacket根据mFormatFlags来分配</span><br><span class="line">&#x2F;&#x2F;NonInterleaved情况下bytesPerSample(因为左右声道分开存放的)；Interleaved的话bytesPerSample * channels(因为左右声道是交错存放)</span><br><span class="line">asbd.mBytesPerFrame &#x3D; bytesPerSample;</span><br><span class="line">&#x2F;&#x2F;每个包有多少字节</span><br><span class="line">asbd.mBytesPerPacket &#x3D; bytesPerSample;</span><br></pre></td></tr></table></figure>

<p>构造好了 BasicDescription 结构体，将结构体设置给对应 AudioUnit</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;构造好了BasicDescription结构体，将这结构体设置给对应的AudioUnit</span><br><span class="line">AudioUnitSetProperty(ioUnit,</span><br><span class="line">                     kAudioUnitProperty_StreamFormat,</span><br><span class="line">                     kAudioUnitScope_Output, 1,</span><br><span class="line">                     &amp;asbd, sizeof(asbd));</span><br></pre></td></tr></table></figure>



<ul>
<li>kAudioOutputUnitProperty_EnableIO 用于启用或禁用 I/O Unit上的输入输出，默认启用输出但禁用输入</li>
<li>kAudioUnitProperty_ElementCount 配置 Mixer Unit上的输入元素数量</li>
<li>kAudioUnitProperty_MaximumFramesPerSlice 指定音频数据最大帧数</li>
<li>kAudioUnitProperty_StreamFormat 指定特定音频单元输入或输出总线的音频流数据格式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UInt32 maximumFramesPerSlice &#x3D; 4096;</span><br><span class="line">AudioUnitSetProperty (</span><br><span class="line">              _ioUnit,</span><br><span class="line">              kAudioUnitProperty_MaximumFramesPerSlice,</span><br><span class="line">              kAudioUnitScope_Global,0,</span><br><span class="line">              &amp;maximumFramesPerSlice,</span><br><span class="line">              sizeof (maximumFramesPerSlice));</span><br></pre></td></tr></table></figure>

<p>Global Scope适用于整个AudioUnit，不与任何特定音频流相关，只有1个元素即0，某些属性，如每个切片最大帧数，仅适用于 Global Scope</p>
<p>设置音频数据流格式</p>
<img src="音视频开发/IOWithoutRenderCallback.png" alt="IOWithoutRenderCallback" style="zoom:70%;" />













<h6 id="AudioUnit-分类"><a href="#AudioUnit-分类" class="headerlink" title="AudioUnit 分类"></a>AudioUnit 分类</h6><ol>
<li>Effect Unit</li>
</ol>
<p>类型是 <code>kAudioUnitType_Effect</code>，主要提供声音特效处理的功能，子类型如下：</p>
<p>均衡器效果：子类型是 <code>kAudioUnitSubType_NBandEQ</code>，主要作用 是为声音的某些频带增强或者减弱能量，该效果器需要指定多个频带， 然后为各个频带设置宽度以及增益，最终将改变声音在频域上的能量分布</p>
<p>压缩效果器：子类型是 <code>kAudioUnitSubType_DynamicsProcessor</code>，主 要作用是当声音较小的时候可以提高声音的能量，当声音的能量超过了 设置的阈值时，可以降低声音的能量，当然应合理地设置作用时间、释 放时间以及触发值，使得最终可以将声音在时域上的能量压缩到一定范 围之内</p>
<p>混响效果器：子类型是 <code>kAudioUnitSubType_Reverb2</code>，对于人声处 理来讲这是非常重要的效果器，可以想象自己身处在一个空房子中，如 果有非常多的反射声和原始声音叠加在一起，那么从听感上可能会更有 震撼力，但是同时原始声音也会变得更加模糊，原始声音的一些细节会 被遮盖掉，所以混响设置的大或者小对于不同的人来讲会很不一致，可以根据自己的喜好来进行设置</p>
<p>Effect Unit下最常使用的就是上述三种效果器，其下还有很多种子类型的效果器，像高通(High Pass)、低通(Low Pass)、带通 (Band Pass)、延迟(Delay)、压限(Limiter)等效果器</p>
<ol start="2">
<li>Mixer Units</li>
</ol>
<p>类型是 <code>kAudioUnitType_Mixer</code>，主要提供 Mix 多路声音的功能，子类型如下：</p>
<p>3D Mixer：该效果器在移动身上无法使用</p>
<p>MultiChannelMixer：子类型是 <code>kAudioUnitSubType_MultiChannelMixer</code>，它是多路声音混音的效果器，可以接收多路音频的输入，还可以 分别调整每一路音频的增益与开关，并将多路音频合并成一路，该效果 器在处理音频的图状结构中非常有用</p>
<p>OutputScope仅设置采样率</p>
<p>默认情况下 kAudioUnitProperty_MaximumFramesPerSlice 设置为1024，如果在屏幕锁定情况下播放音频，必须增加此属性值，除非音频输入处于活动状态</p>
<p>如果音频活动处于活动状态，无需为 kAudioUnitProperty_MaximumFramesPerSlice 设置值</p>
<p>如果音频输入不活跃，将此属性设置为 4096</p>
<ol start="3">
<li>I/O Units</li>
</ol>
<p>类型是 <code>kAudioUnitType_Output</code>，主要提供的就是I/O的功能</p>
<p>RemoteIO：子类型是 <code>kAudioUnitSubType_RemoteIO</code>，是用来采集音频与播放音频的</p>
<p>Generic Output：子类型是 <code>kAudioUnitSubType_GenericOutput</code>，当 开发者需要进行离线处理，或者说在AUGraph中不使用Speaker(扬声 器)来驱动整个数据流，而是希望使用一个输出(可以放入内存队列或 者进行磁盘I/O操作)来驱动数据流时，就使用该子类型</p>
<ol start="4">
<li>Format Converter Units</li>
</ol>
<p>类型是 <code>kAudioUnitType_FormatConverter</code>，主要用于提供格式转换 的功能，比如:采样格式由Float到SInt16的转换、交错和平铺的格式转换、单双声道的转换等</p>
<p>AUConverter：子类型是 <code>kAudioUnitSubType_AUConverter</code>，当某些效果器对输入的音频格式有 明确的要求时(比如3D Mixer Unit就必须使用UInt16格式的sample)， 或者开发者将音频数据输入给一些其他的编码器进行编码，又或者开发 者想使用SInt16格式的PCM裸数据在其他CPU上进行音频算法计算等的 场景下，就需要使用到这个ConverterNode了。下面来看一个比较典型的 场景，我们自定义一个音频播放器(代码仓库中的AudioPlayer项目)， 由FFmpeg解码出来的PCM数据是SInt16格式的，因此不能直接输送给 RemoteIO Unit进行播放，所以需要构建一个ConvertNode将SInt16格式 表示的数据转换为Float32格式表示的数据，然后再输送给RemoteIO Unit，最终才能正常播放出来</p>
<p>Time Pitch:子类型是 <code>kAudioUnitSubType_NewTimePitch</code>，即变速 变调效果器，这是一个很有意思的效果器，可以对声音的音高、速度进 行调整，像“会说话的Tom猫”类似的应用场景就可以使用这个效果器来 实现</p>
<ol start="5">
<li>Generator Units</li>
</ol>
<p>类型是 <code>kAudioUnitType_Generator</code>，在开发中我们经常使用它来提供播放器的功能</p>
<p>AudioFilePlayer：子类型是 <code>kAudioUnitSubType_AudioFilePlayer</code>， 在 AudioUnit 里面，如果我们的输入不是麦克风，而希望其是一个媒体 文件，当然，也可以类似于代码仓库中的 AudioPlayer 项目自行解码，转 换之后将数据输送给 RemoteIO Unit 播放出来，但是其实还有一种更加简 单、方便的方式，那就是使用 AudioFilePlayer 这个 AudioUnit，可以参考 代码仓库中的 AUPlayer 项目，该项目就是利用 AudioFilePlayer 作为输入 数据源来提供数据的。需要注意的是，必须在初始化 AUGraph 之后，再 去配置 AudioFilePlayer 的数据源以及播放范围等属性，否则就会出现错 误，其实数据源还是会调用 AudioFile 的解码功能，将媒体文件中的压缩 数据解压成为PCM裸数据，最终再交给 AudioFilePlayer Unit 进行后续处 理</p>
<h6 id="构造一个-AUGraph"><a href="#构造一个-AUGraph" class="headerlink" title="构造一个 AUGraph"></a>构造一个 AUGraph</h6><p>实际的K歌应用场景，会对用户发出的声音进行处理，并且立即给 用户一个耳返(在50ms之内将声音输出到耳机中，让用户可以听到)。 那么如何让 RemoteIOUnit 利用麦克风采集出来的声音，经过中间效果器 的处理，最终输出到 Speaker 中播放给用户呢？如何 以AUGraph的方式将声音采集、声音处理以及声音输出的整个过程管理 起来</p>
<p>首先要知道数据可以在通道中传递是由最右端 Speaker(RemoteIO Unit)来驱动的，它会向其前一级——AUNode要数 据，然后它的前一级会继续向上一级节点要数据，并最终从 RemoteIOUnit的Element1 (即麦克风)中要数据，这样就可以将数据按 照相反的方向一级一级地传递下去，最终传递到RemoteIOUnit的 Element0(即Speaker)并播放给用户听到。当然你可能会想到离线处理 的时候应该由谁来进行驱动呢?其实在进行离线处理的时候应该使用 Mixer Unit大类型下面子类型为Generic Output的AudioUnit来做驱动端。 那么这些AudioUnit或者说AUNode是如何进行连接的呢?有两种方式， 第一种方式是直接将AUNode连接起来;第二种方式是通过回调的方式 将两个AUNode连接起来</p>
<p><img src="/2021/08/03/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/02.png" alt="02"></p>
<ul>
<li>直接连接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AUGraphConnectNodeInput(mPlayerGraph, mPlayerNode, 0, mPlayerIONode, 0);</span><br></pre></td></tr></table></figure>

<p>AUPlayer实例中的一段代码，目标是将Audio File Player Unit和RemoteIO Unit直接连接起来，当RemoteIO Unit需要播放数据的时 候，就会调用AudioFilePlayer Unit来获取数据，这样就把这两个 AudioUnit连接起来了</p>
<ul>
<li>回调方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AURenderCallbackStruct renderProc;</span><br><span class="line">renderProc.inputProc &#x3D; &amp;inputAvailableCallback;</span><br><span class="line">renderProc.inputProcRefCon &#x3D; (__bridge void *)self;</span><br><span class="line">AUGraphSetNodeInputCallback(mGraph, ioNode, 0, &amp;finalRenderProc);</span><br></pre></td></tr></table></figure>

<p>这段代码首先是构造一个AURenderCallback的结构体，并指定一个 回调函数，然后设置给RemoteIO Unit的输入端，当RemoteIO Unit需要 数据输入的时候就会回调该回调函数，回调函数代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static OSStatus renderCallback(void *inRefCon, AudioUnitRenderActionFlags</span><br><span class="line">           *ioActionFlags, const AudioTimeStamp *inTimeStamp, UInt32</span><br><span class="line">           inBusNumber, UInt32 inNumberFrames, AudioBufferList *ioData)</span><br><span class="line"> &#123;</span><br><span class="line">     OSStatus result &#x3D; noErr;</span><br><span class="line">     __unsafe_unretained AUGraphRecorder *THIS &#x3D; (__bridge</span><br><span class="line">             AUGraphRecorder *)inRefCon;</span><br><span class="line">     AudioUnitRender(THIS-&gt;mixerUnit, ioActionFlags, inTimeStamp, 0,</span><br><span class="line">             inNumberFrames, ioData);</span><br><span class="line">     result &#x3D; ExtAudioFileWriteAsync(THIS-&gt;finalAudioFile, inNumberFrames,</span><br><span class="line">             ioData);</span><br><span class="line">     return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该回调函数主要完成两件事情:第一件事情是去Mixer Unit里面要 数据，通过调用AudioUnitRender的方式来驱动Mixer Unit获取数据，得 到数据之后放入ioData中，从而填充回调方法中的参数，将Mixer Unit与 RemoteIO Unit连接了起来;第二件事情则是利用ExtAudioFile将这段声 音编码并写入本地磁盘的一个文件中</p>
<p>本节的代码仓库中包含了两个实例项目:一个是AUPlayer，利用 AudioFilePlayer Unit和RemoteIO Unit做了一个最简单的播放器;另外一个是AudioPlayer，它会利用FFmpeg进行解码操作，解码出来的是SInt16 格式表示的数据，然后再通过一个ConvertNode将其转换为Float32格式 表示的数据，最终输送给RemoteIO Unit进行播放。将这两个项目对比来 看，第二种方式十分不便</p>
<h4 id="音频采集"><a href="#音频采集" class="headerlink" title="音频采集"></a>音频采集</h4><p>示例代码 AudioRecorder</p>
<p>如果想要直接指定一个路径，可以将录制的音频编码到文件中，可以使用 <code> AVAudioRecorder</code>，优点是简单易用</p>
<p>但如果想要实时在内存中获取录音数据来说，限制性非常强，iOS提供了两个层次API来协助实现</p>
<p><code>AudioQueue</code>：是AudioUnit更高级的封装，功能更单一，接口调用更简单，如果仅仅要获取内存中的录音数据，然后再进行编码输出，用更高级的AudioQueue的API会更好些</p>
<p><code>AudioUnit</code>：如果要使用更多音效处理，以及实时的监听（耳机中听到自己说话），使用AudioUnit会更方便一些</p>
<p>要使用 AudioUnit，需要通过 AudioSession 来开启硬件设备以及对硬件设备做一些设置，然后才能使用 AudioUnit</p>
<ol>
<li>获取 AVAudioSession 实例</li>
<li>为 AVAudioSession 设置类别，录音的同时为用户输送监听耳返，类别使用 AVAudioSessionCategoryPlayAndRecord，</li>
<li>为 AVAudioSession 设置预设采样率</li>
<li>启用 AVAudioSession</li>
<li>为 AVAudioSession 设置路由监听，采集音频或视频输出的路线发生变化时（比如拔出耳机、蓝牙设备连接成功）回调此方法，以便可以重新设置使用当前最新的麦克风或扬声器</li>
</ol>
<p>接下来构造应用所使用的 AUGraph，因为这里要使用录音功能，所以需要启用RemoteIO这个AudioUnit 的InputElement。RemoteIO 这个 AudioUnit 比较特别，Input-Element实际 上使用的是麦克风，而OutputElement使用的则是扬声器，所以这里首先 会启用 RemoteIOUnit 的 InputElement。</p>
<p>为了支持所开发的App可以在后续 Mix 一轨伴奏这一扩展功能，在AUGraph中需要增加 MultiChannelMixer 这个 AudioUnit。由于每个 AudioUnit 的输入输出格式并不相同，所以这 里还要使用AudioConvert这个AudioUnit将输入的AudioUnit连接到  MixerUnit上。最终将 MixerUnit 连接到 RemoteIO 这个 AudioUnit 的 OutputElement，将声音发送到耳机的扬声器中(如果直接发送到手机的 扬声器中就会出现啸叫)，这样就将 AUGraph 整体地建立起来了</p>
<p><img src="/2021/08/03/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/01.png" alt="01"></p>
<p><a href="https://developer.apple.com/library/archive/documentation/Audio/Conceptual/AudioSessionProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007875">Audio Session Programming Guide</a></p>
<p><a href="https://developer.apple.com/library/archive/documentation/MusicAudio/Conceptual/AudioUnitHostingGuide_iOS/ConstructingAudioUnitApps/ConstructingAudioUnitApps.html#//apple_ref/doc/uid/TP40009492-CH16-SW1">Audio Unit Hosting Guide for iOS</a></p>
<p><a href="https://github.com/zhanxiaokai/iOS-AudioRecorder">音频采集代码 AudioRecorder</a></p>
<p><a href="https://github.com/zhanxiaokai?tab=repositories">音视频进阶开发指南源码</a></p>
]]></content>
  </entry>
  <entry>
    <title>Python3网络爬虫开发实战</title>
    <url>/2021/02/26/Python3%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h4 id="Python-IDE"><a href="#Python-IDE" class="headerlink" title="Python IDE"></a>Python IDE</h4><h5 id="PyCharm"><a href="#PyCharm" class="headerlink" title="PyCharm"></a>PyCharm</h5><p>配置</p>
<p>终端 which python3 查看 python3 路径</p>
<p>Preference-Project:pythonProject-PythonInterpreter</p>
<p>Show All 添加 上面 python 路径</p>
<h4 id="Python-版本"><a href="#Python-版本" class="headerlink" title="Python 版本"></a>Python 版本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python 3.7.9</span><br></pre></td></tr></table></figure>

<h4 id="请求库安装"><a href="#请求库安装" class="headerlink" title="请求库安装"></a>请求库安装</h4><h5 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h5><p>阻塞式 HTTP 请求，发出请求后，会一直等待服务器响应</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install requests</span><br></pre></td></tr></table></figure>

<p>验证安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python3</span><br><span class="line">&gt;&gt;&gt; import requests</span><br></pre></td></tr></table></figure>

<h5 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h5><p>自动化测试工具，可以驱动浏览器执行特定的动作，如点击、下拉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install selenium</span><br></pre></td></tr></table></figure>

<h5 id="ChromeDriver"><a href="#ChromeDriver" class="headerlink" title="ChromeDriver"></a>ChromeDriver</h5><p>Selenium 是一个自动化测试工具，需要配合浏览器使用</p>
<p>安装 ChromeDriver 才能驱动 Chrome 浏览器完成相应操作</p>
<p>查看 Chrome 版本号：帮助-关于 Google Chrome 版本 88.0.4324.192（正式版本） (x86_64)</p>
<p>ChromeDriver <a href="http://npm.taobao.org/mirrors/chromedriver/">下载地址</a> 选择 88.0.4324.96/chromedriver_mac64.zip  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mv chromedriver &#x2F;usr&#x2F;local&#x2F;bin</span><br></pre></td></tr></table></figure>

<p>验证安装： 终端输入 chromedriver 开启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python3</span><br><span class="line">&gt;&gt;&gt; from selenium import webdriver</span><br><span class="line">&gt;&gt;&gt; browser &#x3D; webdriver.Chrome()</span><br></pre></td></tr></table></figure>

<p>运行后，弹出一个空白 Chrome 浏览器，证明配置没问题</p>
<h5 id="GeckoDriver"><a href="#GeckoDriver" class="headerlink" title="GeckoDriver"></a>GeckoDriver</h5><p> <a href="https://github.com/mozilla/geckodriver/releases">下载地址</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mv geckodriver &#x2F;usr&#x2F;local&#x2F;bin</span><br></pre></td></tr></table></figure>

<p>验证安装： 终端输入 geckodriver 开启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python3</span><br><span class="line">&gt;&gt;&gt; from selenium import webdriver</span><br><span class="line">&gt;&gt;&gt; browser &#x3D; webdriver.Firefox()</span><br></pre></td></tr></table></figure>

<h5 id="PhantomJS"><a href="#PhantomJS" class="headerlink" title="PhantomJS"></a><del>PhantomJS</del></h5><p><del>无界面的、可脚本编程的 WebKit 浏览器引擎</del></p>
<p><del>Selenium 支持 PhantomJS，这样运行的时候就不会再弹出一个浏览器了</del></p>
<p><a href="https://phantomjs.org/download.html">下载地址</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mv phantomjs &#x2F;usr&#x2F;local&#x2F;bin</span><br></pre></td></tr></table></figure>

<p><del>验证安装： 终端输入 phantomjs</del></p>
<p><del>Selenium中使用，只需要将 Chrome 切换为 PhantomJS</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver </span><br><span class="line">browser &#x3D; webdriver.PhantomJS() </span><br><span class="line">browser.get(&#39;https:&#x2F;&#x2F;www.baidu.com’) </span><br><span class="line">print(browser.current_url)</span><br></pre></td></tr></table></figure>

<p>报错了：<code>Selenium support for PhantomJS has been deprecated</code></p>
<p>使用无界面版本 <code>use headless versions of Chrome or Firefox instead</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"># 创建chrome参数对象</span><br><span class="line">opt &#x3D; webdriver.ChromeOptions()</span><br><span class="line"># 把chrome设置成无界面模式，不论windows还是linux都可以，自动适配对应参数</span><br><span class="line">opt.set_headless()</span><br><span class="line"># 创建chrome无界面对象</span><br><span class="line">driver &#x3D; webdriver.Chrome(options&#x3D;opt)</span><br><span class="line"># 访问百度</span><br><span class="line">driver.get(&#39;https:&#x2F;&#x2F;baidu.com&#x2F;&#39;)</span><br><span class="line">#打印内容</span><br><span class="line">print(driver.page_source)</span><br></pre></td></tr></table></figure>

<h5 id="aiohttp"><a href="#aiohttp" class="headerlink" title="aiohttp"></a>aiohttp</h5><p>异步 Web 服务的库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install aiohttp</span><br></pre></td></tr></table></figure>

<p>字符编码检测库 cchardet , 加速 DNS 的解析库  aiodns</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install cchardet aiodns</span><br></pre></td></tr></table></figure>

<h4 id="解析库安装"><a href="#解析库安装" class="headerlink" title="解析库安装"></a>解析库安装</h4><h5 id="lxml"><a href="#lxml" class="headerlink" title="lxml"></a>lxml</h5><p>Python 的一个解析库，支持 HTML 和 XML 的解析，支持 XPath 解析方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install lxml</span><br></pre></td></tr></table></figure>

<h5 id="Beautiful-Soup"><a href="#Beautiful-Soup" class="headerlink" title="Beautiful Soup"></a>Beautiful Soup</h5><p>Python 的一个 HTML 或 XML 的解析库</p>
<p>Beautiful Soup 的 HTML 和 XML 解析器是依赖于 lxml 库的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install beautifulsoup4</span><br></pre></td></tr></table></figure>

<p>验证安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python3</span><br><span class="line">&gt;&gt;&gt; from bs4 import BeautifulSoup</span><br><span class="line">&gt;&gt;&gt; soup &#x3D; BeautifulSoup(&#39;&lt;p&gt;Hello&lt;&#x2F;p&gt;&#39;, &#39;lxml&#39;)</span><br><span class="line">&gt;&gt;&gt; print(soup.p.string)</span><br></pre></td></tr></table></figure>

<h5 id="pyquery"><a href="#pyquery" class="headerlink" title="pyquery"></a>pyquery</h5><p>网页解析工具，提供和 jQuery类型语法来解析 HTML 文档，支持 CSS 选择器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install pyquery</span><br></pre></td></tr></table></figure>

<h5 id="tesserocr"><a href="#tesserocr" class="headerlink" title="tesserocr"></a>tesserocr</h5><p>OCR 识别</p>
<p>使用 Homebrew 安装 ImageMagick 和 tesseract 库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install imagemagick</span><br><span class="line">brew install tesseract-lang</span><br><span class="line">pip3 install tesserocr pillow</span><br></pre></td></tr></table></figure>

<p><a href="http://my.cnki.net/elibregister/CheckCode.aspx">验证码测试连接</a></p>
<p>使用命令行测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tesseract image.png result -1 eng &amp;&amp; cat result.txt</span><br></pre></td></tr></table></figure>

<p>Python 代码测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python3</span><br><span class="line">&gt;&gt;&gt; import tesserocr</span><br><span class="line">&gt;&gt;&gt; from PIL import Image</span><br><span class="line">&gt;&gt;&gt; image &#x3D; Image.open(&#39;&#x2F;Users&#x2F;midland_whk&#x2F;Downloads&#x2F;CheckCode.aspx.jpeg&#39;)</span><br><span class="line">&gt;&gt;&gt; print(tesserocr.image_to_text(image))</span><br><span class="line">或者</span><br><span class="line">&gt;&gt;&gt; print(tesserocr.file_to_text(&#39;image.png&#39;))</span><br></pre></td></tr></table></figure>

<h4 id="数据库安装"><a href="#数据库安装" class="headerlink" title="数据库安装"></a>数据库安装</h4><h5 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h5><p>轻量级关系型数据库</p>
<p><a href="https://downloads.mysql.com/archives/community/">下载地址</a></p>
<p>MySQL安装后 <code>open ~/.bash_profile</code><br>添加 <code>PATH=$PATH:/usr/local/mysql/bin</code><br>生效 <code>source ~/.bash_profile</code><br>终端登录mysql <code>mysql -uroot -p</code></p>
<p>或者 Homebrew 方式安装 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install mysql</span><br></pre></td></tr></table></figure>

<p>启动、停止、重启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mysql.server start </span><br><span class="line">sudo mysql.server stop </span><br><span class="line">sudo mysql.server restart</span><br></pre></td></tr></table></figure>

<h5 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h5><p>C++编写的非关系型数据库，内容存储形式类似 JSON 对象，字段值可以包含其它文档、数组及文档数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install mongodb</span><br></pre></td></tr></table></figure>

<p>启动、停止和重启 MongoDB</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew services start mongodb </span><br><span class="line">sudo mongod</span><br><span class="line">brew services stop mongodb </span><br><span class="line">brew services restart mongodb</span><br></pre></td></tr></table></figure>

<h5 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h5><p>基于内存的高效的非关系型数据库</p>
<h4 id="Python-存储库"><a href="#Python-存储库" class="headerlink" title="Python 存储库"></a>Python 存储库</h4><p>MySQL 需要安装 PyMySQL</p>
<p>MongoDB 需要安装 PyMongo</p>
<h5 id="PyMySQL"><a href="#PyMySQL" class="headerlink" title="PyMySQL"></a>PyMySQL</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install pymysql</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import pymysql</span><br><span class="line">&gt;&gt;&gt; pymysql.VERSION</span><br><span class="line">(1, 0, 2, None)</span><br></pre></td></tr></table></figure>

<h5 id="PyMongo"><a href="#PyMongo" class="headerlink" title="PyMongo"></a>PyMongo</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install pymongo</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import pymongo </span><br><span class="line">&gt;&gt;&gt; pymongo.version</span><br></pre></td></tr></table></figure>

<h5 id="redis-py"><a href="#redis-py" class="headerlink" title="redis-py"></a>redis-py</h5><p>Redis 使用 redis-py 库来与其交互</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install redis</span><br></pre></td></tr></table></figure>

<h5 id="RedisDump"><a href="#RedisDump" class="headerlink" title="RedisDump"></a>RedisDump</h5><p>RedisDump 一个用于 Redis 数据导入/导出的工具，基于 Ruby 实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gem install redis-dump</span><br></pre></td></tr></table></figure>

<p>验证：安装成功后执行下面命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis dump </span><br><span class="line">redis-load</span><br></pre></td></tr></table></figure>

<h5 id="Web-库安装"><a href="#Web-库安装" class="headerlink" title="Web 库安装"></a>Web 库安装</h5><h5 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h5><p>轻量级的 Web 服务程序，主要用来做一些 API 服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install flask</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line">@app.route(&quot;&#x2F;&quot;)</span><br><span class="line">def hello():</span><br><span class="line">    return &quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>运行后，系统会在 5000 端口开启 Web 服务</p>
<h5 id="Tornado"><a href="#Tornado" class="headerlink" title="Tornado"></a>Tornado</h5><p>支持异步的 Web 框架，通过使用非阻塞 I/O 流，可以支撑成千上万的开放连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install tornado</span><br></pre></td></tr></table></figure>

<p>验证 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tornado.ioloop</span><br><span class="line">import tornado.web</span><br><span class="line"></span><br><span class="line">class MainHandler(tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.write(&quot;hello world&quot;)</span><br><span class="line">def make_app():</span><br><span class="line">    return  tornado.web.Application([</span><br><span class="line">        (r&quot;&#x2F;&quot;, MainHandler)</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    app &#x3D; make_app()</span><br><span class="line">    app.listen(8888)</span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></table></figure>

<p>运行后，系统在 8888 端口运行了 Web 服务， 访问 <a href="http://127.0.0.8888/">http://127.0.0.8888/</a> 网页呈现 helloworld</p>
<h4 id="APP-爬取相关库安装"><a href="#APP-爬取相关库安装" class="headerlink" title="APP 爬取相关库安装"></a>APP 爬取相关库安装</h4><h5 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a>Charles</h5><h5 id="mitmproxy"><a href="#mitmproxy" class="headerlink" title="mitmproxy"></a>mitmproxy</h5><p>支持 HTTP 和 HTTPS 的抓包程序，通过控制台的形式操作</p>
<p>有两个关联组件</p>
<p>mitmdump：是 mitmproxy 命令行接口，利用它对接 Python 脚本</p>
<p>mitmweb：一个 Web 程序，通过它以清楚观察到 mitmproxy 捕获请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install mitmproxy</span><br></pre></td></tr></table></figure>

<p>证书配置</p>
<p>mitmproxy 安装后会提供一套 CA 证书，运行 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mitmdump</span><br></pre></td></tr></table></figure>

<p>在用户目录 .mitmproxy 目录里面找到 CA 证书</p>
<p>配置：</p>
<p>双击 mitmproxy-ca-cert.pem 弹出钥匙串管理，找到 mitmproxy 证书，打开设置，选始终信任</p>
<p>将 mitmproxy-ca-cert.pem 隔空投送到手机设备，安装</p>
<ul>
<li>设置代理</li>
</ul>
<p>启动 mitmproxy，之后会在 8080 端口上运行一个代理服务，右下角显示当前正在监听的端口，或者启动 mitmdump，也会监听 8080 端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mitmproxy</span><br></pre></td></tr></table></figure>

<p>手机设置代理 端口号设置 8080</p>
<p>设置好之后，手机浏览请求，mitmproxy 页面便会呈现手机上的请求</p>
<p>敲击回车可以查看详情，可以查看 Request、Response、Detail 点击 Tab 切换</p>
<ul>
<li>提供了命令行编辑功能：</li>
</ul>
<p>点击 e 进入编辑功能，跳转需要编辑哪部分内容，回车确定</p>
<p>退出返回 q 或者 :q  : wq!</p>
<p>敲击 a 保存修改，敲击 r 重新发起修改后的请求</p>
<ul>
<li>mitmdump</li>
</ul>
<p>可以命令行启动，并把截获的数据保存到文件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mitmdump -w outfile</span><br></pre></td></tr></table></figure>

<p>还可以指定一个脚本来处理截获的数据，使用 -s 参数，脚本需要放在当前命令执行的目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mitmdump -s script.py</span><br></pre></td></tr></table></figure>

<p>脚本写入如下代码：定义了一个 request() 方法，参数为 flow，其实是一个 HTTPFlow 对象，通过 request 属性即可获取当前请求对象，然后打印输出请求头</p>
<p>手机端访问 <a href="http://httpbin.org/get">http://httpbin.org/get</a> 测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def request(flow):</span><br><span class="line">	flow.request.headers[&#39;User-Agent&#39;] &#x3D; &#39;MitmProxy&#39;</span><br><span class="line">	print(flow.request.headers)</span><br></pre></td></tr></table></figure>

<ul>
<li>日志输出</li>
</ul>
<p>可以设定不同级别以不同颜色输出结果 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python3</span><br><span class="line">from mitmproxy import ctx</span><br><span class="line">def request(flow):</span><br><span class="line">	flow.request.headers[&#39;User-Agent&#39;] &#x3D; &#39;MitmProxy&#39;</span><br><span class="line">	ctx.log.info(str(flow.request.headers))</span><br><span class="line">	ctx.log.warn(str(flow.request.headers))</span><br><span class="line">	ctx.log.error(str(flow.request.headers))</span><br><span class="line">	print(flow.request.headers)</span><br></pre></td></tr></table></figure>

<p>这里调用了 ctx 模块，它有一个 log 功能</p>
<ul>
<li>请求</li>
</ul>
<p>还可输出其它内容 headers、cookies 等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python3</span><br><span class="line">from mitmproxy import ctx</span><br><span class="line">def request(flow):</span><br><span class="line">	request &#x3D; flow.request</span><br><span class="line">	info &#x3D; ctx.log.info</span><br><span class="line">	print(info(str(request.headers)))</span><br><span class="line">	print(info(str(request.cookies)))</span><br><span class="line">	print(info(str(request.host)))</span><br><span class="line">	print(info(str(request.method)))</span><br><span class="line">	print(info(str(request.port)))</span><br><span class="line">	print(info(str(request.scheme)))</span><br></pre></td></tr></table></figure>

<p>可以对属性修改 ，修改脚本如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def request(flow):</span><br><span class="line">	url &#x3D; &#39;https:&#x2F;&#x2F;httpbin.org&#x2F;get&#39;</span><br><span class="line">	flow.request.url &#x3D; url</span><br></pre></td></tr></table></figure>

<p>访问 <a href="https://baidu.com/">https://baidu.com</a> 直接跳转到这里了 <a href="https://httpbin.org/get">https://httpbin.org/get</a></p>
<p>Request 还有很多属性 参考 <a href="http://docs.mitmproxy.org/en/latest/scripting/api.html">http://docs.mitmproxy.org/en/latest/scripting/api.html</a></p>
<ul>
<li>响应</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from mitmproxy import ctx</span><br><span class="line"></span><br><span class="line">def request(flow):</span><br><span class="line">	response &#x3D; flow.response</span><br><span class="line">	info &#x3D; ctx.log.info</span><br><span class="line">	info(str(response.status_code))</span><br><span class="line">	info(str(response.headers))</span><br><span class="line">	info(str(response.cookies))</span><br><span class="line">	info(str(response.text))</span><br></pre></td></tr></table></figure>

<p>再访问 httpbin （报错了。。） </p>
<ul>
<li>mitmdump 爬 ‘得到’ APP 电子书信息</li>
</ul>
<h5 id="Appium-安装"><a href="#Appium-安装" class="headerlink" title="Appium 安装"></a>Appium 安装</h5><p>移动端的自动化测试工具</p>
<p><a href="http://appium.io/">下载链接</a> 直接安装</p>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g appium</span><br></pre></td></tr></table></figure>

<p>利用 WebDriver 来实现 APP 的自动化测试</p>
<p>Appium 相当于一个服务器，可以向 Appium 发送一些操作指令，Appium 就会跟进不同指令对设备进行驱动</p>
<p>点击 Start Server 按钮即可启动 Appium 的服务，相当于开启了一个 Appium 服务器。</p>
<p>可以通过 Appium 内置驱动或 Python 代码向 Appium 的服务器发送一系列操作指令</p>
<p>默认 Appium 运行后正在监听 4723 端口</p>
<h5 id="WebDriverAgent"><a href="#WebDriverAgent" class="headerlink" title="WebDriverAgent"></a>WebDriverAgent</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;appium&#x2F;WebDriverAgent</span><br><span class="line">brew install Carthage</span><br><span class="line">.&#x2F;scripts&#x2F;bootstrap.sh</span><br></pre></td></tr></table></figure>

<h5 id="libimobiledevice"><a href="#libimobiledevice" class="headerlink" title="libimobiledevice"></a>libimobiledevice</h5><p>使用原生协议与评估 iOS 设备进行通信的库，通过这个库 MacOS 能够获取到 iOS 设备信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install --HEAD libimobiledevice</span><br></pre></td></tr></table></figure>









<h4 id="爬虫框架"><a href="#爬虫框架" class="headerlink" title="爬虫框架"></a>爬虫框架</h4><h5 id="pyspider"><a href="#pyspider" class="headerlink" title="pyspider"></a>pyspider</h5><p>依赖 PhantomJS，所以还需要安装 PhantomJS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install pyspider</span><br></pre></td></tr></table></figure>

<p>验证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyspider all</span><br></pre></td></tr></table></figure>

<p>这时 pyspider 的 Web 服务器会在本地 5000 端口运行，直接打开浏览器 <a href="http://localhost:5000/">http://localhost:5000/</a> 即可进入 pyspider 的 WebUI 管理页面</p>
<p>报错 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">File &quot;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.8&#x2F;lib&#x2F;python3.8&#x2F;site-packages&#x2F;pyspider&#x2F;run.py&quot;, line 231</span><br><span class="line">    async&#x3D;True, get_object&#x3D;False, no_input&#x3D;False):</span><br></pre></td></tr></table></figure>

<p>修改文件 <code>/Library/Frameworks/Python.framework/Versions/3.8/lib/python3.8/site-packages/pyspider/run.py</code> </p>
<p><code>pyspider/fetcher/tornado_fetcher.py</code></p>
<p><code>pyspider/webui/app.py</code></p>
<p>async 改成 async_mode</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 uninstall wsgidav</span><br><span class="line">pip3 install wsgidav&#x3D;&#x3D;2.4.1</span><br></pre></td></tr></table></figure>

<p>报错： <code>ImportError: cannot import name DispatcherMiddleware</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 uninstall werkzeug</span><br><span class="line">pip3 install werkzeug&#x3D;&#x3D;0.16.0</span><br></pre></td></tr></table></figure>

<h5 id="Scrapy"><a href="#Scrapy" class="headerlink" title="Scrapy"></a>Scrapy</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install scrapy</span><br></pre></td></tr></table></figure>

<p>验证： 命令行输入 scrapy</p>
<h5 id="Scrapy-Splash"><a href="#Scrapy-Splash" class="headerlink" title="Scrapy-Splash"></a>Scrapy-Splash</h5><p>Scrapy-Splash 是一个 Scrapy 中支持 JavaScript 渲染的工具</p>
<p>安装分两部分：</p>
<ul>
<li>Splash 服务安装</li>
</ul>
<p>通过 Docker安装，安装后会启动一个 Splash 服务，可以通过它的接口来实现 JavaScript 页面的加载</p>
<p>安装 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -p 8050:8050 scrapinghub&#x2F;splash</span><br></pre></td></tr></table></figure>

<p>Scrapy-Splash 会使用 Splash 的 HTTP API 进行页面渲染，安装 Splash 来提供渲染服务</p>
<p>安装完成后 Splash 已经在 8050 上运行了， 打开 <a href="http://localhost:8050/">http://localhost:8050</a> 即可看到 Splash 的主页</p>
<ul>
<li>Scrapy-Splash 的 Python 库安装</li>
</ul>
<p>安装之后即可在 Scrapy 中使用 Splash 服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install scrapy-splash</span><br></pre></td></tr></table></figure>

<h5 id="Scrapy-Redis"><a href="#Scrapy-Redis" class="headerlink" title="Scrapy-Redis"></a>Scrapy-Redis</h5><p>Scrapy 的分布式扩展模块，有了它，可以方便实现 Scrapy 分布式爬虫的搭建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install scrapy-redis</span><br></pre></td></tr></table></figure>



<h4 id="部署相关库安装"><a href="#部署相关库安装" class="headerlink" title="部署相关库安装"></a>部署相关库安装</h4><h5 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install --cask --appdir&#x3D;&#x2F;Applications docker</span><br></pre></td></tr></table></figure>

<p>测试运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>

<p>运行测试命令时，会发现它首先会下载一个 Hello World 的镜像，然后将其运行</p>
<p>下载镜像有时候会非常慢，因为默认是从国外 Docker Hub 下载的，为了提高下载速度，可以使用国内镜像来加速</p>
<p>推荐的加速器 <a href="https://daocloud.io/mirror">Docker</a> 和 <a href="https://cr.console.aliyun.com/#/accelerator">阿里云</a> </p>
<h5 id="Scrapyd"><a href="#Scrapyd" class="headerlink" title="Scrapyd"></a>Scrapyd</h5><p>用于部署和运行 Scrapy 项目的工具，有了它，可以将写好的 Scrapy 项目上传到云主机并通过 API 来控制它</p>
<h5 id="Scrapyd-Client"><a href="#Scrapyd-Client" class="headerlink" title="Scrapyd-Client"></a>Scrapyd-Client</h5><h5 id="Scrapyd-API-安装"><a href="#Scrapyd-API-安装" class="headerlink" title="Scrapyd API 安装"></a>Scrapyd API 安装</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install python-scrapyd-api</span><br></pre></td></tr></table></figure>

<h5 id="Scrapyrt"><a href="#Scrapyrt" class="headerlink" title="Scrapyrt"></a>Scrapyrt</h5><h5 id="Gerapy"><a href="#Gerapy" class="headerlink" title="Gerapy"></a>Gerapy</h5><p>Scrapy 分布式管理模块</p>
<h4 id="3-基本库使用"><a href="#3-基本库使用" class="headerlink" title="3. 基本库使用"></a>3. 基本库使用</h4><h5 id="3-1-urllib"><a href="#3-1-urllib" class="headerlink" title="3.1 urllib"></a>3.1 urllib</h5><p>Python内置请求库，包含4个模块</p>
<ul>
<li>request</li>
</ul>
<p>基本 HTTP 请求模块，用来模拟发送请求</p>
<ul>
<li>error</li>
</ul>
<p>异常处理，如果出现请求错误，可以捕获这些异常</p>
<ul>
<li>parse</li>
</ul>
<p>工具模块，提供了许多 URL 处理方法 如拆分、解析、合并</p>
<ul>
<li>robotparser</li>
</ul>
<p>识别网站 robots.txt 文件，然后判断哪些网站可以爬，实际用的少</p>
<h6 id="3-1-1-发送请求"><a href="#3-1-1-发送请求" class="headerlink" title="3.1.1 发送请求"></a>3.1.1 发送请求</h6><ol>
<li>urlopen() </li>
</ol>
<p>可以完成简单请求和网页抓取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line">import ssl</span><br><span class="line">ssl._create_default_https_context &#x3D; ssl._create_unverified_context</span><br><span class="line">response &#x3D; urllib.request.urlopen(&#39;https:&#x2F;&#x2F;www.python.org&#39;)</span><br><span class="line">print(type(response))</span><br><span class="line">print(response.read().decode(&#39;utf-8&#39;))</span><br><span class="line">print(response.status)</span><br><span class="line">print(response.getheaders())</span><br><span class="line">print(response.getheader(&#39;Server&#39;))</span><br></pre></td></tr></table></figure>

<p>urlopen 的参数 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">urlopen(url, data&#x3D;None, timeout&#x3D;socket._GLOBAL_DEFAULT_TIMEOUT,*, cafile&#x3D;None, capath&#x3D;None, cadefault&#x3D;False, context&#x3D;None)</span><br></pre></td></tr></table></figure>

<p>data参数： 可选，如果是字节流编码格式内容，即 bytes 类型，需要通过 bytes() 方法转换，如果传递了参数则是 POST 方式请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import urllib.parse</span><br><span class="line">import urllib.request</span><br><span class="line">data &#x3D; bytes(urllib.parse.urlencode(&#123;&#39;world&#39;: &#39;hello&#39;&#125;), encoding&#x3D;&#39;utf8&#39;)</span><br><span class="line">response &#x3D; urllib.request.urlopen(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;post&#39;, data&#x3D;data)</span><br><span class="line">print(response.read)</span><br></pre></td></tr></table></figure>

<p>byte() 方法第一个参数需要 str 类型，需要用 urllib.parse 模块里的 urlencode() 方法将参数字典转化为字符串</p>
<p>站点 <code>http://httpbin.org/post</code>  可以提供 HTTP 请求测试</p>
<p>timeout参数： 超时时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import urllib.error</span><br><span class="line">import urllib.request</span><br><span class="line">try:</span><br><span class="line">    response &#x3D; urllib.request.urlopen(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;get&#39;, timeout&#x3D;0.1)</span><br><span class="line">except urllib.error.URLError as e:</span><br><span class="line">    if isinstance(e.reason, socket.timeout):</span><br><span class="line">        print(&#39;TIME OUT&#39;)</span><br></pre></td></tr></table></figure>

<p>context 参数：必须是 ssl.SSLContext 类型，用来指定 SSL 设置</p>
<p>cafile 和 capath ：分别指定 CA 证书 和 它的路径</p>
<ol start="2">
<li>Request</li>
</ol>
<p>如果需要 Headers 等信息，可以利用 Resquest 类来构建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line">import ssl</span><br><span class="line">ssl._create_default_https_context &#x3D; ssl._create_unverified_context</span><br><span class="line">request &#x3D; urllib.request.Request(&#39;https:&#x2F;&#x2F;python.org&#39;)</span><br><span class="line">response &#x3D; urllib.request.urlopen(request)</span><br><span class="line">print(response.read().decode(&#39;utf-8&#39;))</span><br></pre></td></tr></table></figure>

<p>Request 参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url, data&#x3D;None, headers&#x3D;&#123;&#125;,origin_req_host&#x3D;None, unverifiable&#x3D;False,method&#x3D;None</span><br></pre></td></tr></table></figure>

<p>headers： 是一个字典，可以通过修改 User-Agent 来伪装浏览器，默认是 Python-urllib</p>
<p>origin_req_host：请求方 host 名称或 IP 地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from urllib import request, parse</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;httpbin.org&#x2F;post&#39;</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &#39;User-Agent&#39;: &#39;Mozilla&#x2F;4.0 (compatible; MSIE 5.5; Windows NT)&#39;,</span><br><span class="line">    &#39;Host&#39;: &#39;httpbin.org&#39;</span><br><span class="line">&#125;</span><br><span class="line">dict &#x3D; &#123;</span><br><span class="line">    &#39;name&#39;: &#39;Germey&#39;</span><br><span class="line">&#125;</span><br><span class="line">data &#x3D; bytes(parse.urlencode(dict), encoding&#x3D;&#39;utf8&#39;)</span><br><span class="line">req &#x3D; request.Request(url&#x3D;url, data&#x3D;data, headers&#x3D;headers, method&#x3D;&#39;POST&#39;)</span><br><span class="line">response &#x3D; request.urlopen(req)</span><br><span class="line">print(response.read().decode(&#39;utf-8&#39;))</span><br></pre></td></tr></table></figure>

<p>headers 也可以用 add_header() 方法添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">req &#x3D; request.Request(url&#x3D;url, data&#x3D;data, method&#x3D;&#39;POST&#39;)</span><br><span class="line">req.add_header(&#39;User-Agent&#39;, &#39;Mozilla&#x2F;4.0 (compatible; MSIE 5.5; Windows NT)&#39;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>高级用法</li>
</ol>
<p>request 模块里的 BaseHandler 类</p>
<p>HTTPDefaultErrorHandler：处理 HTTP 响应错误，错误会抛出 HTTPError 类型异常</p>
<p>HTTPRedirectHandler：用于处理重定向</p>
<p>HTTPCookieProcessor：用于处理 Cookies</p>
<p>ProxyHandler：用于设置代理</p>
<p>HTTPPasswordMgr：用于管理密码</p>
<p>HTTPBasicAuthHandler：用于管理认证</p>
<p>OpenerDirector：可以称为 Opener，可以利用 Handler 来构建 Opener</p>
<p>用法：登录验证、代理、Cookie</p>
<h6 id="3-1-2-处理异常"><a href="#3-1-2-处理异常" class="headerlink" title="3.1.2 处理异常"></a>3.1.2 处理异常</h6><ol>
<li>URLError</li>
<li>HTTPError</li>
</ol>
<h6 id="3-1-3-解析链接"><a href="#3-1-3-解析链接" class="headerlink" title="3.1.3 解析链接"></a>3.1.3 解析链接</h6><ol>
<li>urlparse()</li>
</ol>
<p>实现 URL 的识别和分段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from urllib.parse import urlparse</span><br><span class="line">result &#x3D; urlparse(&#39;http:www.baidu.com&#x2F;index.html;user?id&#x3D;s#comment&#39;)</span><br><span class="line">print(type(result), result)</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;class &#39;urllib.parse.ParseResult&#39;&gt; ParseResult(scheme&#x3D;&#39;http&#39;, netloc&#x3D;&#39;&#39;, path&#x3D;&#39;www.baidu.com&#x2F;index.html&#39;, params&#x3D;&#39;user&#39;, query&#x3D;&#39;id&#x3D;s&#39;, fragment&#x3D;&#39;comment&#39;)</span><br></pre></td></tr></table></figure>

<p>输出结果是 ParseResult 类型，包含 6 个部分，可以用索引顺序来获取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(result.scheme, result[0], result.netloc, result[1], sep&#x3D;&#39;\n&#39;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>urlunparse()</li>
</ol>
<ol start="3">
<li>urlsplit()</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from urllib.parse import urlsplit</span><br><span class="line">result &#x3D; urlsplit(&#39;http:www.baidu.com&#x2F;index.html;user?id&#x3D;s#comment&#39;)</span><br><span class="line">print(type(result), result)</span><br></pre></td></tr></table></figure>

<p>和 urlparse 使用类似，不过不再单独解析 params 部分，只返回 5个 结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;class &#39;urllib.parse.SplitResult&#39;&gt; SplitResult(scheme&#x3D;&#39;http&#39;, netloc&#x3D;&#39;&#39;, path&#x3D;&#39;www.baidu.com&#x2F;index.html;user&#39;, query&#x3D;&#39;id&#x3D;s&#39;, fragment&#x3D;&#39;comment&#39;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>urlunsplit()</li>
<li>urljoin()</li>
</ol>
<p>实现连接拼合与生成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from urllib.parse import urljoin</span><br><span class="line">print(urljoin(&#39;http:&#x2F;&#x2F;www.baidu.com&#39;, &#39;?category&#x3D;2&#39;))</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>urlencode()</li>
</ol>
<p>将字典序列化为 GET 请求参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from urllib.parse import urlencode</span><br><span class="line">params &#x3D; &#123;</span><br><span class="line">    &#39;name&#39;: &#39;germey&#39;,</span><br><span class="line">    &#39;age&#39;: 22</span><br><span class="line">&#125;</span><br><span class="line">base_url &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com?&#39;</span><br><span class="line">url &#x3D; base_url + urlencode(params)</span><br><span class="line">print(url)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>parse_qs()</li>
</ol>
<p>将请求参数反序列化成字典类型</p>
<ol start="7">
<li>parse_sql()</li>
</ol>
<p>将参数转化成元组组成的列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from urllib.parse import parse_qsl</span><br><span class="line">query &#x3D; &#39;name&#x3D;germey&amp;age&#x3D;2&#39;</span><br><span class="line">print(parse_qsl(query))</span><br><span class="line"></span><br><span class="line">[(&#39;name&#39;, &#39;germey&#39;), (&#39;age&#39;, &#39;2&#39;)]</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>quote()</li>
</ol>
<p>将内容转化为 URL 编码格式，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from urllib.parse import quote</span><br><span class="line">keyword &#x3D; &#39;测试&#39;</span><br><span class="line">url &#x3D; &#39;https:&#x2F;&#x2F;baidu.com&#x2F;s?wd&#x3D;&#39; + quote(keyword)</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>unquote()</li>
</ol>
<p>可以进行 URL 解码</p>
<h6 id="3-1-4-分析-Robots-协议"><a href="#3-1-4-分析-Robots-协议" class="headerlink" title="3.1.4 分析 Robots 协议"></a>3.1.4 分析 Robots 协议</h6><p>urllib 的 robotparser 模块，可以实现网站 Robots 协议的分析</p>
<ol>
<li>Robots 协议</li>
</ol>
<p>爬虫协议，全名叫网络爬虫排除标准，告诉爬虫和搜索引擎哪些页面可以抓取不抓取，通常是一个 robots.txt 协议</p>
<ol start="2">
<li>robotparser</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from urllib.robotparser import RobotFileParser</span><br><span class="line">from urllib.request import urlopen</span><br><span class="line">import ssl</span><br><span class="line"></span><br><span class="line">ssl._create_default_https_context &#x3D; ssl._create_unverified_context</span><br><span class="line">rp &#x3D; RobotFileParser()</span><br><span class="line">rp.set_url(&#39;https:&#x2F;&#x2F;www.jianshu.com&#x2F;robots.txt&#39;)</span><br><span class="line">rp.read()</span><br><span class="line">print(rp.can_fetch(&#39;*&#39;, &#39;https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;823596514412&#39;))</span><br></pre></td></tr></table></figure>

<h5 id="3-2-使用-Request"><a href="#3-2-使用-Request" class="headerlink" title="3.2 使用 Request"></a>3.2 使用 Request</h5><h6 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h6><p>GET 请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">r &#x3D; requests.get(&#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;)</span><br><span class="line">print(type(r))</span><br><span class="line">print(r.status_code)</span><br><span class="line">print(r.text)</span><br><span class="line">print(r.cookies)</span><br></pre></td></tr></table></figure>

<p>带参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import  requests</span><br><span class="line">params &#x3D; &#123;</span><br><span class="line">    &#39;name&#39;: &#39;germey&#39;,</span><br><span class="line">    &#39;age&#39;: 22</span><br><span class="line">&#125;</span><br><span class="line">r &#x3D; requests.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;get&#39;, params&#x3D;params)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure>

<p>网页的返回类型实际上是 str 类型，JSON格式的，想得到字典格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(r.json())</span><br></pre></td></tr></table></figure>



<h6 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h6><h5 id="3-3-正则表达式"><a href="#3-3-正则表达式" class="headerlink" title="3.3 正则表达式"></a>3.3 正则表达式</h5><h5 id="3-4-抓取猫眼电影排行"><a href="#3-4-抓取猫眼电影排行" class="headerlink" title="3.4 抓取猫眼电影排行"></a>3.4 抓取猫眼电影排行</h5><p>书本配套代码 <a href="https://github.com/Python3WebSpider/MaoYan">https://github.com/Python3WebSpider/MaoYan</a></p>
<p>排行链接  <a href="https://maoyan.com/board/4">https://maoyan.com/board/4</a></p>
<p>第二页链接  <a href="https://maoyan.com/board/4?offset=10">https://maoyan.com/board/4?offset=10</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">import requests</span><br><span class="line">import json</span><br><span class="line">from requests.exceptions import RequestException</span><br><span class="line"></span><br><span class="line">def get_one_page(url):</span><br><span class="line">	try:</span><br><span class="line">		headers &#x3D; &#123;</span><br><span class="line">			&#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; U; Intel Mac OS X 10_6_10; en-us) AppleWebKit&#x2F;534.50 (KHTML, like Gecko) Version&#x2F;5.1 Safari&#x2F;534.50&#39;</span><br><span class="line">		&#125;</span><br><span class="line">		response &#x3D; requests.get(url, headers&#x3D;headers)</span><br><span class="line">		if response.status_code &#x3D;&#x3D; 200:</span><br><span class="line">			return response.text</span><br><span class="line">		return None</span><br><span class="line">	except RequestException:</span><br><span class="line">		return None</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">	url &#x3D; &#39;https:&#x2F;&#x2F;maoyan.com&#x2F;board&#x2F;4&#39;</span><br><span class="line">	html &#x3D; get_one_page(url)</span><br><span class="line">	print(html)</span><br></pre></td></tr></table></figure>

<p>可以通过浏览器查看源码，选择网络查看原始请求部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dd&gt;</span><br><span class="line">	&lt;i class&#x3D;&quot;board-index board-index-1&quot;&gt;1&lt;&#x2F;i&gt;</span><br><span class="line">	&lt;a href&#x3D;&quot;&#x2F;films&#x2F;1200486&quot; title&#x3D;&quot;我不是药神&quot; class&#x3D;&quot;image-link&quot; data-act&#x3D;&quot;boarditem-click&quot; data-val&#x3D;&quot;&#123;movieId:1200486&#125;&quot;&gt;</span><br><span class="line">      &lt;img src&#x3D;&quot;&#x2F;&#x2F;s3plus.meituan.net&#x2F;v1&#x2F;mss_e2821d7f0cfe4ac1bf9202ecf9590e67&#x2F;cdn-prod&#x2F;file:5788b470&#x2F;image&#x2F;loading_2.e3d934bf.png&quot; alt&#x3D;&quot;&quot; class&#x3D;&quot;poster-default&quot; &#x2F;&gt;</span><br><span class="line">      &lt;img data-src&#x3D;&quot;https:&#x2F;&#x2F;p0.meituan.net&#x2F;movie&#x2F;414176cfa3fea8bed9b579e9f42766b9686649.jpg@160w_220h_1e_1c&quot; alt&#x3D;&quot;我不是药神&quot; class&#x3D;&quot;board-img&quot; &#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;a&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;board-item-main&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;board-item-content&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;movie-item-info&quot;&gt;</span><br><span class="line">        &lt;p class&#x3D;&quot;name&quot;&gt;&lt;a href&#x3D;&quot;&#x2F;films&#x2F;1200486&quot; title&#x3D;&quot;我不是药神&quot; data-act&#x3D;&quot;boarditem-click&quot; data-val&#x3D;&quot;&#123;movieId:1200486&#125;&quot;&gt;我不是药神&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p class&#x3D;&quot;star&quot;&gt;主演：徐峥,周一围,王传君&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p class&#x3D;&quot;releasetime&quot;&gt;上映时间：2018-07-05&lt;&#x2F;p&gt;</span><br><span class="line">		  &lt;&#x2F;div&gt;</span><br><span class="line">  		&lt;div class&#x3D;&quot;movie-item-number score-num&quot;&gt;</span><br><span class="line">				&lt;p class&#x3D;&quot;score&quot;&gt;&lt;i class&#x3D;&quot;integer&quot;&gt;9.&lt;&#x2F;i&gt;&lt;i class&#x3D;&quot;fraction&quot;&gt;6&lt;&#x2F;i&gt;&lt;&#x2F;p&gt;        </span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">     &lt;&#x2F;div&gt;</span><br><span class="line">   &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;dd&gt;</span><br></pre></td></tr></table></figure>

<p>一部电影信息对应源码是一个 dd 节点</p>
<p>先获取排行信息，在 class 为 board-index 的 i 节点内，提取 i 节点内的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;&#x2F;i&gt;</span><br></pre></td></tr></table></figure>

<p>图片信息：dd 后面有个 a 节点，内部有两个 img 节点，第二个 img 节点的 data-src 属性是图片的链接，提取第二个 img 节点 data-sr 属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;&#x2F;i&gt;.*?data-src&#x3D;&quot;(.*?)&quot;</span><br></pre></td></tr></table></figure>

<p>电影名称：后面 p 节点内， class 为 name</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;&#x2F;i&gt;.*?data-src&#x3D;&quot;(.*?)&quot;.*?name.*?&gt;(.*?)&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p>findall 提取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pattern &#x3D; re.compile(&#39;&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;&#x2F;i&gt;.*?data-src&#x3D;&quot;(.*?)&quot;.*?name.*?&gt;(.*?)&lt;&#x2F;a&gt;&#39;, re.S)</span><br><span class="line">items &#x3D; re.findall(pattern, html)</span><br><span class="line">print(items)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[(&#39;1&#39;, &#39;https:&#x2F;&#x2F;p0.meituan.net&#x2F;movie&#x2F;414176cfa3fea8bed9b579e9f42766b9686649.jpg@160w_220h_1e_1c&#39;, &#39;&lt;a href&#x3D;&quot;&#x2F;films&#x2F;1200486&quot; title&#x3D;&quot;我不是药神&quot; data-act&#x3D;&quot;boarditem-click&quot; data-val&#x3D;&quot;&#123;movieId:1200486&#125;&quot;&gt;我不是药神&#39;), (&#39;2&#39;, &#39;https:&#x2F;&#x2F;p0.meituan.net&#x2F;movie&#x2F;8112a8345d7f1d807d026282f2371008602126.jpg@160w_220h_1e_1c&#39;, &#39;&lt;a href&#x3D;&quot;&#x2F;films&#x2F;1297&quot; title&#x3D;&quot;肖申克的救赎&quot; data-act&#x3D;&quot;boarditem-click&quot; data-val&#x3D;&quot;&#123;movieId:1297&#125;&quot;&gt;肖申克的救赎&#39;), (&#39;3&#39;, &#39;https:&#x2F;&#x2F;p1.meituan.net&#x2F;movie&#x2F;c9b280de01549fcb71913edec05880585769972.jpg@160w_220h_1e_1c&#39;, &#39;&lt;a href&#x3D;&quot;&#x2F;films&#x2F;1206605&quot; title&#x3D;&quot;绿皮书&quot; data-act&#x3D;&quot;boarditem-click&quot; data-val&#x3D;&quot;&#123;movieId:1206605&#125;&quot;&gt;绿皮书&#39;), (&#39;4&#39;, &#39;https:&#x2F;&#x2F;p0.meituan.net&#x2F;movie&#x2F;609e45bd40346eb8b927381be8fb27a61760914.jpg@160w_220h_1e_1c&#39;, &#39;&lt;a href&#x3D;&quot;&#x2F;films&#x2F;1292&quot; title&#x3D;&quot;海上钢琴师&quot; data-act&#x3D;&quot;boarditem-click&quot; data-val&#x3D;&quot;&#123;movieId:1292&#125;&quot;&gt;海上钢琴师&#39;), (&#39;5&#39;, &#39;https:&#x2F;&#x2F;p1.meituan.net&#x2F;movie&#x2F;ac8f0004928fbce5a038a007b7c73cec746794.jpg@160w_220h_1e_1c&#39;, &#39;&lt;a href&#x3D;&quot;&#x2F;films&#x2F;1216365&quot; title&#x3D;&quot;小偷家族&quot; data-act&#x3D;&quot;boarditem-click&quot; data-val&#x3D;&quot;&#123;movieId:1216365&#125;&quot;&gt;小偷家族&#39;), (&#39;6&#39;, &#39;https:&#x2F;&#x2F;p0.meituan.net&#x2F;movie&#x2F;61fea77024f83b3700603f6af93bf690585789.jpg@160w_220h_1e_1c&#39;, &#39;&lt;a href&#x3D;&quot;&#x2F;films&#x2F;1203&quot; title&#x3D;&quot;霸王别姬&quot; data-act&#x3D;&quot;boarditem-click&quot; data-val&#x3D;&quot;&#123;movieId:1203&#125;&quot;&gt;霸王别姬&#39;), (&#39;7&#39;, &#39;https:&#x2F;&#x2F;p0.meituan.net&#x2F;movie&#x2F;005955214d5b3e50c910d7a511b0cb571445301.jpg@160w_220h_1e_1c&#39;, &#39;&lt;a href&#x3D;&quot;&#x2F;films&#x2F;1211270&quot; title&#x3D;&quot;哪吒之魔童降世&quot; data-act&#x3D;&quot;boarditem-click&quot; data-val&#x3D;&quot;&#123;movieId:1211270&#125;&quot;&gt;哪吒之魔童降世&#39;), (&#39;8&#39;, &#39;https:&#x2F;&#x2F;p1.meituan.net&#x2F;movie&#x2F;580d81a2c78bf204f45323ddb4244b6c6821175.jpg@160w_220h_1e_1c&#39;, &#39;&lt;a href&#x3D;&quot;&#x2F;films&#x2F;1303&quot; title&#x3D;&quot;美丽人生&quot; data-act&#x3D;&quot;boarditem-click&quot; data-val&#x3D;&quot;&#123;movieId:1303&#125;&quot;&gt;美丽人生&#39;), (&#39;9&#39;, &#39;https:&#x2F;&#x2F;p1.meituan.net&#x2F;movie&#x2F;6bea9af4524dfbd0b668eaa7e187c3df767253.jpg@160w_220h_1e_1c&#39;, &#39;&lt;a href&#x3D;&quot;&#x2F;films&#x2F;4055&quot; title&#x3D;&quot;这个杀手不太冷&quot; data-act&#x3D;&quot;boarditem-click&quot; data-val&#x3D;&quot;&#123;movieId:4055&#125;&quot;&gt;这个杀手不太冷&#39;), (&#39;10&#39;, &#39;https:&#x2F;&#x2F;p0.meituan.net&#x2F;moviemachine&#x2F;c2496a7290a72eac6081321898c347693550574.jpg@160w_220h_1e_1c&#39;, &#39;&lt;a href&#x3D;&quot;&#x2F;films&#x2F;416&quot; title&#x3D;&quot;盗梦空间&quot; data-act&#x3D;&quot;boarditem-click&quot; data-val&#x3D;&quot;&#123;movieId:416&#125;&quot;&gt;盗梦空间&#39;)]</span><br></pre></td></tr></table></figure>

<p>写入文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def write_to_file(content):</span><br><span class="line">	with open(&#39;result.txt&#39;, &#39;a&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:</span><br><span class="line">		print(type(json.dumps(content)))</span><br><span class="line">		f.write(json.dumps(content, ensure_ascii&#x3D;False)+&#39;\n&#39;)</span><br></pre></td></tr></table></figure>

<p>分页爬取：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">def main(offset):</span><br><span class="line">	url &#x3D; &#39;https:&#x2F;&#x2F;maoyan.com&#x2F;board&#x2F;4?offset&#x3D;&#39; + str(offset) </span><br><span class="line">	html &#x3D; get_one_page(url)</span><br><span class="line">	pattern &#x3D; re.compile(&#39;&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;&#x2F;i&gt;.*?data-src&#x3D;&quot;(.*?)&quot;.*?name.*?&gt;(.*?)&lt;&#x2F;a&gt;&#39;, re.S)</span><br><span class="line">	items &#x3D; re.findall(pattern, html)</span><br><span class="line">	print(items)</span><br><span class="line">	write_to_file(items)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">	for i in range(10):</span><br><span class="line">		main(offset&#x3D;i*10)</span><br><span class="line">		time.sleep(1)</span><br></pre></td></tr></table></figure>

<h4 id="4-解析库使用"><a href="#4-解析库使用" class="headerlink" title="4. 解析库使用"></a>4. 解析库使用</h4><h5 id="4-1-XPath"><a href="#4-1-XPath" class="headerlink" title="4.1 XPath"></a>4.1 XPath</h5><p>常用规则</p>
<table>
<thead>
<tr>
<th>nodename</th>
<th align="left">选取此节点的所有子节点</th>
</tr>
</thead>
<tbody><tr>
<td>/</td>
<td align="left">从当前节点选取直接子节点</td>
</tr>
<tr>
<td>//</td>
<td align="left">从当前节点选取子孙节点</td>
</tr>
<tr>
<td>.</td>
<td align="left">选取当前节点</td>
</tr>
<tr>
<td>..</td>
<td align="left">选取当前节点的父节点</td>
</tr>
<tr>
<td>@</td>
<td align="left">选取属性</td>
</tr>
</tbody></table>
<p>所有名称为 title，同时属性 lang 的值为 eng 的节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;title[@lang&#x3D;&#39;eng&#39;]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line">text &#x3D; &#39;&#39;&#39;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;ul&gt;</span><br><span class="line">		&lt;li class&#x3D;&quot;item-0&quot;&gt;&lt;a href&#x3D;&quot;link1.html&quot;&gt;first item&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">		&lt;li class&#x3D;&quot;item-1&quot;&gt;&lt;a href&#x3D;&quot;link2.html&quot;&gt;second item&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">		&lt;li class&#x3D;&quot;item-inactive&quot;&gt;&lt;a href&#x3D;&quot;link3.html&quot;&gt;third item&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">		&lt;li class&#x3D;&quot;item-1&quot;&gt;&lt;a href&#x3D;&quot;link4.html&quot;&gt;fourth item&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">		&lt;li class&#x3D;&quot;item-0&quot;&gt;&lt;a href&#x3D;&quot;link5.html&quot;&gt;fifth item&lt;&#x2F;a&gt;</span><br><span class="line">	&lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">html &#x3D; etree.HTML(text)</span><br><span class="line">result &#x3D; etree.tostring(html)</span><br><span class="line">print(result.decode(&#39;utf-8&#39;))</span><br></pre></td></tr></table></figure>

<p>导入 lxml 库的 etree 模块，声明一段 HTML 文本，调用 HTML 类进行初始化，这样就成功构造了一个 XPath 解析对象</p>
<p>HTML 文件最后一个 li 节点是没有闭合的，但 etree 模块可以自动修正 HTML 文本</p>
<p>toString 输出修正后的 HTML 代码，结果是 bytes 类型，利用 decode 转成 str 类型</p>
<p>也可读取文本进行解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html &#x3D; etree.parse(&#39;.&#x2F;test.html&#39;, etree.HTMLParser())</span><br></pre></td></tr></table></figure>

<ul>
<li>所有结点</li>
</ul>
<p>// 开头的 XPath 规则来选取所有符合要求的节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; html.xpath(&#39;&#x2F;&#x2F;*&#39;)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<p>返回形式是一个列表，每个元素是 Element 类型，其后跟了节点的名称，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&lt;Element html at 0x7f8f63e97280&gt;, &lt;Element body at 0x7f8f63f225c0&gt;, &lt;Element div at 0x7f8f63f22b40&gt;, &lt;Element ul at 0x7f8f63f22b80&gt;, &lt;Element li at 0x7f8f63f22bc0&gt;, &lt;Element a at 0x7f8f63f22c40&gt;, &lt;Element li at 0x7f8f63f22c80&gt;, &lt;Element a at 0x7f8f63f22cc0&gt;, &lt;Element li at 0x7f8f63f22d00&gt;, &lt;Element a at 0x7f8f63f22c00&gt;, &lt;Element li at 0x7f8f63f22d40&gt;, &lt;Element a at 0x7f8f63f22d80&gt;, &lt;Element li at 0x7f8f63f22dc0&gt;, &lt;Element a at 0x7f8f63f22e00&gt;]</span><br></pre></td></tr></table></figure>

<p>也可指定节点名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li&#39;)</span><br></pre></td></tr></table></figure>

<ul>
<li>子节点</li>
</ul>
<p>/ 或 // 查找元素的子节点或子孙节点，选择 li 节点的所有直接 a 子节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li&#x2F;a&#39;) </span><br></pre></td></tr></table></figure>

<p>ul 节点下的所有子孙 a 节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; html.xpath(&#39;&#x2F;&#x2F;ul&#x2F;&#x2F;a&#39;)</span><br></pre></td></tr></table></figure>

<ul>
<li>父节点</li>
</ul>
<p>href 属性为 link4.html 的 a 节点，然后再获取其父结点，然后再获取其 class 属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; html.xpath(&#39;&#x2F;&#x2F;a[@href&#x3D;&quot;link4.html&quot;]&#x2F;..&#x2F;@class&#39;)</span><br></pre></td></tr></table></figure>

<p>也可以通过 parent:: 获取父节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; html.xpath(&#39;&#x2F;&#x2F;a[@href&#x3D;link4.html&#x2F;parent::*&#x2F;@class]&#39;)</span><br></pre></td></tr></table></figure>

<ul>
<li>属性匹配</li>
</ul>
<p>@ 符号进行属性过滤，如果选取 class 为 item-1 的 li 节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li[@class&#x3D;&#39;item-1&#39;]&#39;)</span><br></pre></td></tr></table></figure>

<ul>
<li>文本获取</li>
</ul>
<p>text() 方法获取节点中的文本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li[@class&#x3D;&#39;item-0&#39;]&#x2F;a&#x2F;text()&#39;)</span><br><span class="line">结果：[&#39;first item&#39;, &#39;fifth item&#39;]</span><br><span class="line">或者</span><br><span class="line">result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li[@class&#x3D;&#39;item-0&#39;]&#x2F;&#x2F;text()&#39;)</span><br><span class="line">结果：[&#39;first item&#39;, &#39;fifth item&#39;, &#39;\n  &#39;]</span><br></pre></td></tr></table></figure>

<ul>
<li>属性获取</li>
</ul>
<p>获取 li 节点下所有 a 节点的 href 属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li&#x2F;a&#x2F;@href&#39;)</span><br><span class="line">结果</span><br><span class="line">[&#39;link1.html&#39;, &#39;link2.html&#39;, &#39;link3.html&#39;, &#39;link4.html&#39;, &#39;link5.html&#39;]</span><br></pre></td></tr></table></figure>

<ul>
<li>属性多值匹配</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">text &#x3D; &#39;&#39;&#39;</span><br><span class="line">&lt;li class&#x3D;&quot;li li-first&quot;&gt;&lt;a href&#x3D;&quot;link.html&quot;&gt;first item&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">html &#x3D; etree.HTML(text)</span><br><span class="line">result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li[contains(@class, &quot;li&quot;)]&#x2F;a&#x2F;text()&#39;)</span><br></pre></td></tr></table></figure>

<p>html 中 li 节点的 class 属性有两个值 li 和 li-list，就需要用到 cantains() 函数了</p>
<ul>
<li>多属性匹配</li>
</ul>
<p>多个属性确定一个节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">text &#x3D; &#39;&#39;&#39;</span><br><span class="line">&lt;li class&#x3D;&quot;li li-first&quot; name&#x3D;&quot;item&quot;&gt;&lt;a href&#x3D;&quot;link.html&quot;&gt;first item&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">html &#x3D; etree.HTML(text)</span><br><span class="line">result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li[contains(@class, &quot;li&quot;) and @name&#x3D;&quot;item&quot;]&#x2F;a&#x2F;text()&#39;)</span><br></pre></td></tr></table></figure>

<ul>
<li>运算符：</li>
</ul>
<table>
<thead>
<tr>
<th>or、and</th>
<th>或、与</th>
</tr>
</thead>
<tbody><tr>
<td>+、-、*、div、mod</td>
<td>加、减、乘、除、除法余数</td>
</tr>
<tr>
<td>&gt;、=、&lt;、!=、&gt;=、&lt;=</td>
<td>大于、等于、小于、不等于、大于等于、小于等于</td>
</tr>
</tbody></table>
<ul>
<li>按序选择</li>
</ul>
<p>有时候匹配了多个节点，只想要其中某个节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li[1]&#x2F;a&#x2F;text()&#39;)</span><br><span class="line">result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li[last()]&#x2F;a&#x2F;text()&#39;)</span><br><span class="line">result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li[position()&lt;3]&#x2F;a&#x2F;text()&#39;)</span><br><span class="line">result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li[last()-2]&#x2F;a&#x2F;text()&#39;)</span><br></pre></td></tr></table></figure>

<p>Xpath 中提供了 100 多个函数，具体参考 <a href="http://www.w3school.com.en/xpath/xpath_functions.asp">http://www.w3school.com.en/xpath/xpath_functions.asp</a></p>
<ul>
<li>节点轴选择</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获取所有祖先节点</span><br><span class="line">result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li[1]&#x2F;ancestor::*&#39;)</span><br><span class="line">&#x2F;&#x2F;获取所有 div 的祖先节点</span><br><span class="line">result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li[1]&#x2F;ancestor::div&#39;)</span><br><span class="line">&#x2F;&#x2F;获取 li 节点所有属性值</span><br><span class="line">result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li[1]&#x2F;attribute::*&#39;)</span><br><span class="line">&#x2F;&#x2F;获取直接字节点，取 href 属性为 link.html 的 a 节点</span><br><span class="line">result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li[1]&#x2F;child::a[@href&#x3D;&quot;link1.html&quot;]&#39;)</span><br><span class="line">&#x2F;&#x2F;获取子孙节点，取包含 span 节点</span><br><span class="line">result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li[1]&#x2F;descendant::span&#39;)</span><br><span class="line">&#x2F;&#x2F;获取当前节点之后所有节点，只获取第二个后续节点</span><br><span class="line">result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li[1]&#x2F;following::*[2]&#39;)</span><br><span class="line">&#x2F;&#x2F;获取当前节点之后的所有同级节点</span><br><span class="line">result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li[1]&#x2F;following-sibling::*&#39;)</span><br></pre></td></tr></table></figure>

<p>XPath 轴 <a href="http://www.w3school.com.cn/xpath/xpath_axes.asp">http://www.w3school.com.cn/xpath/xpath_axes.asp</a></p>
<h5 id="4-2-Beautiful-Soup"><a href="#4-2-Beautiful-Soup" class="headerlink" title="4.2 Beautiful Soup"></a>4.2 Beautiful Soup</h5><p>HTML 或 XML 的解析库</p>
<p>自动将输入文档转换为 Unicode 编码，输出文档转换为 UTF-8 编码，不需要考虑编码方式</p>
<p>Beautiful Soup 在解析时依赖解析器，lxml 解析器有解析 HTML 和 XML 的功能，且速度快，容错能力强</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup &#x3D; BeautifulSoup(&#39;&lt;p&gt;Hello&lt;&#x2F;p&gt;&#39;, &#39;lxml&#39;)</span><br><span class="line">print(soup.p.string)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html &#x3D; &#39;&#39;&#39;</span><br><span class="line">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p class&#x3D;&quot;title&quot; name&#x3D;&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;&#x2F;b&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p class&#x3D;&quot;story&quot; Once upon a time there were three little sisters; and their names were</span><br><span class="line">&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot; class&#x3D;&quot;sister&quot; id&#x3D;&quot;linkl&quot;&gt;&lt;! - Elsie ...&gt;&lt;&#x2F;a&gt;,</span><br><span class="line">&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;lacie&quot; class&#x3D;&quot;sister&quot; id&#x3D;&quot;link2&quot;&gt;Lacie&lt;&#x2F;a&gt; and</span><br><span class="line">&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;tillie&quot; class&#x3D;&quot;sister&quot; id&#x3D;&quot;link3&quot;&gt;Tillie&lt;&#x2F;a&gt;;</span><br><span class="line">and they lived at the bottom of a well.&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p class&#x3D;&quot;story&quot;&gt;...&lt;&#x2F;p&gt;</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">soup &#x3D; BeautifulSoup(html, &#39;lxml&#39;)</span><br><span class="line">print(soup.prettify())</span><br><span class="line">print(soup.title.string)</span><br></pre></td></tr></table></figure>

<p>调用 pretttify() 方法，把要解析的字符串以标准的缩进格式输出，Beautiful Soup 可以自动更正格式</p>
<ul>
<li>节点选择器</li>
</ul>
<p>直接调用节点名称就可以选择节点元素，再调用 string 属性就可以得到节点内的文本了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(soup.title)</span><br><span class="line">print(type(soup.title))</span><br><span class="line">print(soup.title.string)</span><br><span class="line">print(soup.head)</span><br><span class="line">print(soup.p)</span><br><span class="line">结果</span><br><span class="line">&lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;</span><br><span class="line">&lt;class &#39;bs4.element.Tag&#39;&gt;</span><br><span class="line">The Dormouse&#39;s story</span><br><span class="line">&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;</span><br><span class="line">&lt;p class&#x3D;&quot;title&quot; name&#x3D;&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;&#x2F;b&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<p>只打印了第一个 p 节点的内容，多个节点时，这种选择方式只会选择到第一个匹配的节点</p>
<ul>
<li>提取信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获取名称</span><br><span class="line">print(soup.title.name)  		</span><br><span class="line">title</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获取属性</span><br><span class="line">print(soup.p.attrs)					</span><br><span class="line">&#123;&#39;class&#39;: [&#39;title&#39;], &#39;name&#39;: &#39;dromouse&#39;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获取 name 属性</span><br><span class="line">print(soup.p.attrs[&#39;name&#39;])	</span><br><span class="line">dromouse</span><br></pre></td></tr></table></figure>

<p>比较简单方式，注意返回有的是字符串，有的是字符串组成的列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(soup.p[&#39;name&#39;])</span><br><span class="line">print(soup.p[&#39;class&#39;])</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获取内容(是第一个 p 节点)</span><br><span class="line">print(soup.p.string)</span><br></pre></td></tr></table></figure>

<ul>
<li>嵌套选择</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(soup.head.title.string)</span><br></pre></td></tr></table></figure>

<ul>
<li>关联选择</li>
</ul>
<p>有时候不能一步就选到想要的节点元素，需要先选中某个节点元素，然后以它为基准再选择它的父节点、子节点、兄弟节点</p>
<ol>
<li>直接子节点</li>
</ol>
<p>添加一个 p 节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p class&#x3D;&quot;story&quot;&gt;</span><br><span class="line">Once upon a time there were three little sisters; and their names were</span><br><span class="line">&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot; class&#x3D;&quot;sister&quot; id&#x3D;&quot;linkl&quot;&gt; </span><br><span class="line">&lt;span&gt; Elsie&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p>结果，返回 p 节点的直接子节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(soup.p.contents)</span><br><span class="line">[&#39;\n\tOnce upon a time there were three little sisters; and their names were\n\t&#39;, &lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot; id&#x3D;&quot;linkl&quot;&gt;</span><br><span class="line">&lt;span&gt; Elsie&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;a&gt;, &#39;\n&#39;]</span><br></pre></td></tr></table></figure>

<p>同样可以直接调用 children 属性等到相应的结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(soup.p.children)</span><br><span class="line">for i, child in enumerate(soup.p.children):</span><br><span class="line">  print(i, child)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>父节点和 子孙节点</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(soup.a.parent)</span><br></pre></td></tr></table></figure>

<p>想要获取所有的祖先节点，调用 parents 属性</p>
<ol start="3">
<li>兄弟节点</li>
</ol>
<p>next_sibling 节点下一个兄弟元素</p>
<p>previous_sibling 节点上一个兄弟元素</p>
<p>next_siblings 所有前面的兄弟元素</p>
<p>previous_siblings 所有后面的兄弟元素</p>
<ol start="4">
<li>提取信息</li>
</ol>
<p>返回的是单个节点，直接调用 string、attrs 等属性获取文本和属性</p>
<p>多个节点的生成器，则可转为列表后取出元素，然后调用 string、attrs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(soup.a.next_sibling)</span><br><span class="line">print(list(soup.a.parents))</span><br><span class="line">print(list(soup.a.parents)[0])</span><br><span class="line">pirnt(list(soup.a.parents)[0].attrs[&#39;class&#39;])</span><br></pre></td></tr></table></figure>

<ul>
<li>方法选择器</li>
</ul>
<ol>
<li>find_all()  查找所有符合条件的元素，传入属性或文本，就可以得到符合条件的元素</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find_all(name, attrs, recursive, text, **kwargs)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html &#x3D; &#39;&#39;&#39;</span><br><span class="line">  &lt;div class&#x3D;&quot;panel&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;panel-heading&quot;&gt;</span><br><span class="line">    &lt;h4&gt;Hello&lt;&#x2F;h4&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;panel-body&quot;&gt;</span><br><span class="line">    &lt;ul class&#x3D;&quot;list&quot; id&#x3D;&quot;list-1&quot;&gt;</span><br><span class="line">      &lt;li class&#x3D;&quot;element&quot;&gt;Foo&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li class&#x3D;&quot;element&quot;&gt;Bar&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li class&#x3D;&quot;element&quot;&gt;Jay&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;ul class&#x3D;&quot;list list-small&quot; id&#x3D;&quot;list-2&quot;&gt;</span><br><span class="line">      &lt;li class&#x3D;&quot;element&quot;&gt;Foo&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li class&#x3D;&quot;element&quot;&gt;Bar&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">soup &#x3D; BeautifulSoup(html,&#39;lxml&#39;)</span><br><span class="line">print(soup.find_all(name&#x3D;&#39;ul&#39;))</span><br></pre></td></tr></table></figure>

<p>  查询所有 ul 节点，返回结果是列表类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for ul in soup.find_all(name&#x3D;&#39;ul&#39;):</span><br><span class="line">	print(ul, find_all(name&#x3D;&#39;li&#39;))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>attrs 传入属性查询</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(soup.find_all(attrs&#x3D;&#123;&#39;id&#39;: &#39;list-1&#39;&#125;))</span><br><span class="line">print(soup.find_all(attrs&#x3D;&#123;&#39;name&#39;: &#39;elements&#39;&#125;))</span><br><span class="line"></span><br><span class="line">print(soup.find_all(id&#x3D;&#39;list-1&#39;))</span><br><span class="line">print(soup.find_all(class_&#x3D;&#39;element&#39;)) </span><br><span class="line">class 是 Python 关键字，需要加下划线</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>text 匹配节点的文本，可以传字符串或正则表达式对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(soup.find_all(text&#x3D;re.compile(&#39;link&#39;)))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>find() 返回的是单个元素，也就是第一个匹配的元素</p>
</li>
<li><p>CSS 选择器</p>
</li>
</ul>
<h5 id="4-3-pyquery"><a href="#4-3-pyquery" class="headerlink" title="4.3 pyquery"></a>4.3 pyquery</h5><h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><h5 id="5-1-文件存储"><a href="#5-1-文件存储" class="headerlink" title="5.1 文件存储"></a>5.1 文件存储</h5><h5 id="5-2-关系型数据库存储"><a href="#5-2-关系型数据库存储" class="headerlink" title="5.2 关系型数据库存储"></a>5.2 关系型数据库存储</h5><h6 id="5-2-1-MySQL"><a href="#5-2-1-MySQL" class="headerlink" title="5.2.1. MySQL"></a>5.2.1. MySQL</h6><h5 id="5-3-非关系型数据库存储"><a href="#5-3-非关系型数据库存储" class="headerlink" title="5.3 非关系型数据库存储"></a>5.3 非关系型数据库存储</h5><h6 id="5-3-1-MongoDB"><a href="#5-3-1-MongoDB" class="headerlink" title="5.3.1. MongoDB"></a>5.3.1. MongoDB</h6><h6 id="5-3-2-Redis"><a href="#5-3-2-Redis" class="headerlink" title="5.3.2. Redis"></a>5.3.2. Redis</h6><h4 id="6-Ajax-数据爬取"><a href="#6-Ajax-数据爬取" class="headerlink" title="6. Ajax 数据爬取"></a>6. Ajax 数据爬取</h4><h4 id="7-动态渲染页面爬取"><a href="#7-动态渲染页面爬取" class="headerlink" title="7. 动态渲染页面爬取"></a>7. 动态渲染页面爬取</h4><h4 id="8-验证码识别"><a href="#8-验证码识别" class="headerlink" title="8. 验证码识别"></a>8. 验证码识别</h4><h4 id="9-代理的使用"><a href="#9-代理的使用" class="headerlink" title="9. 代理的使用"></a>9. 代理的使用</h4><h4 id="10-模拟登录"><a href="#10-模拟登录" class="headerlink" title="10. 模拟登录"></a>10. 模拟登录</h4><h4 id="11-App-的爬取"><a href="#11-App-的爬取" class="headerlink" title="11. App 的爬取"></a>11. App 的爬取</h4><h4 id="12-pyspider-框架使用"><a href="#12-pyspider-框架使用" class="headerlink" title="12. pyspider 框架使用"></a>12. pyspider 框架使用</h4><h4 id="13-Scrapy-框架使用"><a href="#13-Scrapy-框架使用" class="headerlink" title="13. Scrapy 框架使用"></a>13. Scrapy 框架使用</h4><h4 id="14-分布式爬虫"><a href="#14-分布式爬虫" class="headerlink" title="14. 分布式爬虫"></a>14. 分布式爬虫</h4><h4 id="15-分布式爬虫部署"><a href="#15-分布式爬虫部署" class="headerlink" title="15. 分布式爬虫部署"></a>15. 分布式爬虫部署</h4>]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>《Flutter实战第二版》六：可滚动组件</title>
    <url>/2022/01/18/%E3%80%8AFlutter%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E3%80%8B%E5%85%AD%EF%BC%9A%E5%8F%AF%E6%BB%9A%E5%8A%A8%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="6-可滚动组件"><a href="#6-可滚动组件" class="headerlink" title="6 可滚动组件"></a>6 可滚动组件</h3><h5 id="6-1-可滚动组件"><a href="#6-1-可滚动组件" class="headerlink" title="6.1 可滚动组件"></a>6.1 可滚动组件</h5><p>Flutter 中有两种布局模型<br>基于 RenderBox 的盒模型布局<br>基于 Sliver（RenderSliver）按需加载列表布局</p>
<p>Flutter 中的可滚动主要由三个角色组成：Scollable、Viewport 和 Sliver<br>Scollable 用于处理滑动手势，确定滑动偏移，滑动偏移时构建 Viewport<br>Viewport 显示的视窗，即列表的可视区域<br>Sliver 视窗里显示的元素</p>
<ul>
<li>布局过程</li>
</ul>
<p>Scrollable 监听到用户滑动行为后，根据最新的滑动偏移构建 Viewport</p>
<p>Viewport 将当前视口信息和配置信息通过 SliverConstraints 传递给 Sliver</p>
<p>Sliver 中对子组件（RenderBox）按需进行构建和布局，然后确认自身的位置、绘制等信息，保存在 geometry 中（一个 SliverGeometry 类型的对象）</p>
<ul>
<li>Scrollable</li>
</ul>
<p>用于处理滑动手势，确定滑动偏移，滑动偏移变化时构建 Viewport</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Scrollable(&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">this</span>.axisDirection = AxisDirection.down, <span class="comment">//滚动方向</span></span><br><span class="line">  <span class="keyword">this</span>.controller,</span><br><span class="line">  <span class="keyword">this</span>.physics,</span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">this</span>.viewportBuilder, <span class="comment">//后面介绍</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>physics</code> 接受一个 ScrollPhysics 类型的对象，决定可滚动组件如何响应用户操作</p>
<p>比如用户滑动完抬起手指后，继续执行动画；或者滑动到边界时如何显示，默认情况下，Flutter会根据平台分别使用不同 ScrollPhysics 对象，应用不同效果，如滑动到边界时，继续拖动，iOS上会出现弹性效果，Android上会出现微光效果</p>
<p>Flutter SDK中包含两个 ScrollPhysics 的子类</p>
<p>ClampingScrollPhysics 列表滑动到边界时将不能继续滑动，通常Android中配合GlowingOverscrollIndicator （实现微光效果的组件）使用</p>
<p>BouncingScrollPhysics iOS 下弹性效果</p>
<p><code>controller</code>  接受一个 ScrollController 对象，主要作用是控制滚动位置和监听滚动事件</p>
<p><code>viewportBuilder</code> 构建 Viewport 的回调，用户滑动时，Scrollable 会调用此回调构建新的 Viewport</p>
<ul>
<li>Viewport</li>
</ul>
<p>用于渲染当前视口中需要显示 Sliver</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Viewport(&#123;</span><br><span class="line">  Key? key,</span><br><span class="line">  <span class="keyword">this</span>.axisDirection = AxisDirection.down,</span><br><span class="line">  <span class="keyword">this</span>.crossAxisDirection,</span><br><span class="line">  <span class="keyword">this</span>.anchor = <span class="number">0.0</span>,</span><br><span class="line">  <span class="keyword">required</span> ViewportOffset offset, <span class="comment">// 用户的滚动偏移</span></span><br><span class="line">  <span class="comment">// 类型为Key，表示从什么地方开始绘制，默认是第一个元素</span></span><br><span class="line">  <span class="keyword">this</span>.center,</span><br><span class="line">  <span class="keyword">this</span>.cacheExtent, <span class="comment">// 预渲染区域</span></span><br><span class="line">  <span class="comment">//该参数用于配合解释cacheExtent的含义，也可以为主轴长度的乘数</span></span><br><span class="line">  <span class="keyword">this</span>.cacheExtentStyle = CacheExtentStyle.pixel, </span><br><span class="line">  <span class="keyword">this</span>.clipBehavior = Clip.hardEdge,</span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; slivers = <span class="keyword">const</span> &lt;Widget&gt;[], <span class="comment">// 需要显示的 Sliver 列表</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>offset：该参数为 Scrollable 构建 Viewport 时传入，描述了 Viewport 应该显示哪一部分内容</p>
<p>cacheExtentStyle：是个枚举，有 pixel 和 viewport 两个取值，为 pixel 时，cacheExtent 的值为预渲染区域的具体像素长度，为 viewport 时，cacheExtent 的值是一个乘数，表示有几个 viewport 的长度</p>
<ul>
<li>Sliver</li>
</ul>
<p>Sliver 主要作用是对子组件进行构建和布局</p>
<ul>
<li>可滚动组件通用配置</li>
</ul>
<p>几乎所有的可滚动组件在构造时都能指定 scrollDirection（滚动的主轴）reverse（滑动方向是否反向）controller、physics、cacheExtent</p>
<ul>
<li>Scrollbar</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Scrollbar(</span><br><span class="line">  child: SingleChildScrollView(</span><br><span class="line">    ...</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="6-2-SingleChildScrollView"><a href="#6-2-SingleChildScrollView" class="headerlink" title="6.2 SingleChildScrollView"></a>6.2 SingleChildScrollView</h4><p>SingleChildScrollView 类似 Android 中的 ScrollView</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">SingleChildScrollView(&#123;</span><br><span class="line">  <span class="keyword">this</span>.scrollDirection = Axis.vertical, <span class="comment">//滚动方向，默认是垂直方向</span></span><br><span class="line">  <span class="keyword">this</span>.reverse = <span class="keyword">false</span>, </span><br><span class="line">  <span class="keyword">this</span>.padding, </span><br><span class="line">  <span class="built_in">bool</span> primary, </span><br><span class="line">  <span class="keyword">this</span>.physics, </span><br><span class="line">  <span class="keyword">this</span>.controller,</span><br><span class="line">  <span class="keyword">this</span>.child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>primary 属性：表示是否使用 widget 树中默认的 PrimaryScrollController</p>
<p>通常 SingleChildScrollView 只应在期望的内容不会超过屏幕太多的时候使用，因为 SingleChildScrollView 不支持基于 Sliver 的延迟加载模型</p>
<p>例如：将大写字母 A-Z 沿垂直方向显示，垂直方向空间会超过屏幕视口高度，使用 SingleChildScrollView</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleChildScrollViewTestRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">String</span> str = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> Scrollbar( <span class="comment">// 显示进度条</span></span><br><span class="line">      child: SingleChildScrollView(</span><br><span class="line">        padding: EdgeInsets.all(<span class="number">16.0</span>),</span><br><span class="line">        child: Center(</span><br><span class="line">          child: Column( </span><br><span class="line">            <span class="comment">//动态创建一个List&lt;Widget&gt;  </span></span><br><span class="line">            children: str.split(<span class="string">&quot;&quot;</span>) </span><br><span class="line">                <span class="comment">//每一个字母都用一个Text显示,字体为原来的两倍</span></span><br><span class="line">                .map((c) =&gt; Text(c, textScaleFactor: <span class="number">2.0</span>,)) </span><br><span class="line">                .toList(),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》六：可滚动组件/WeChat6f1348f5e3cb71768b5c796b10ce1e55.png" alt="WeChat6f1348f5e3cb71768b5c796b10ce1e55" style="zoom:80%;" />

<h4 id="6-3-ListView"><a href="#6-3-ListView" class="headerlink" title="6.3 ListView"></a>6.3 ListView</h4><p>最常用可滚动组件之一，可以沿一个方向排布所有子组件，支持列表懒加载</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ListView(&#123;</span><br><span class="line">  ...  </span><br><span class="line">  <span class="comment">//可滚动widget公共参数</span></span><br><span class="line">  Axis scrollDirection = Axis.vertical,</span><br><span class="line">  <span class="built_in">bool</span> reverse = <span class="keyword">false</span>,</span><br><span class="line">  ScrollController? controller,</span><br><span class="line">  <span class="built_in">bool?</span> primary,</span><br><span class="line">  ScrollPhysics? physics,</span><br><span class="line">  EdgeInsetsGeometry? padding,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//ListView各个构造函数的共同参数  </span></span><br><span class="line">  <span class="built_in">double?</span> itemExtent,</span><br><span class="line">  Widget? prototypeItem, <span class="comment">//列表项原型，后面解释</span></span><br><span class="line">  <span class="built_in">bool</span> shrinkWrap = <span class="keyword">false</span>,</span><br><span class="line">  <span class="built_in">bool</span> addAutomaticKeepAlives = <span class="keyword">true</span>,</span><br><span class="line">  <span class="built_in">bool</span> addRepaintBoundaries = <span class="keyword">true</span>,</span><br><span class="line">  <span class="built_in">double?</span> cacheExtent, <span class="comment">// 预渲染区域长度</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">//子widget列表</span></span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>itemExtent：参数如果不为 null，则会强制 children 的长度为 itemExtent 的值，长度指滚动方向上子组件的长度</p>
<p>prototypeItem：如果我们知道列表中的所有列表项长度都相同但不知道具体是多少，我们可以指定一个列表项，这个列表项为 prototypeItem（列表项原型），和 itemExtent 互斥</p>
<p>ShrinkWrap：是否跟进子组件总长度来设置 ListView 的长度，默认 false；默认情况下，ListView 会在滚动方向尽可能多的占用空间，当 ListView 在一个无边界（滚动向上）的容器中时，必须为 true</p>
<p>addAutomaticKeepAlives</p>
<p>addRepaintBoundaries</p>
<h5 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h5><p>默认构造函数有一个 children 参数，接受一个 Widget 列表，这种方式适合只有少量的子组件数量已知且比较少的情况，反之使用 ListView.builder 按需动态构建列表</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ListView(</span><br><span class="line">  shrinkWrap: <span class="keyword">true</span>, </span><br><span class="line">  padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    <span class="keyword">const</span> Text(<span class="string">&#x27;I\&#x27;m dedicating every day to you&#x27;</span>),</span><br><span class="line">    <span class="keyword">const</span> Text(<span class="string">&#x27;Domestic life was never quite my style&#x27;</span>),</span><br><span class="line">    <span class="keyword">const</span> Text(<span class="string">&#x27;When you smile, you knock me out, I fall apart&#x27;</span>),</span><br><span class="line">    <span class="keyword">const</span> Text(<span class="string">&#x27;And I thought I was so smart&#x27;</span>),</span><br><span class="line">  ],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="ListView-builder"><a href="#ListView-builder" class="headerlink" title="ListView.builder"></a>ListView.builder</h5><p>适合列表项比较多或者列表项不确定的情况</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ListView.builder(&#123;</span><br><span class="line">  <span class="comment">// ListView公共参数已省略  </span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">required</span> IndexedWidgetBuilder itemBuilder,</span><br><span class="line">  <span class="built_in">int</span> itemCount,</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>itemBuilder：是列表项的构造器</p>
<ul>
<li>例子</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ListView.builder(</span><br><span class="line">  itemCount: <span class="number">100</span>,</span><br><span class="line">  itemExtent: <span class="number">50.0</span>, <span class="comment">//强制高度为50.0</span></span><br><span class="line">  itemBuilder: (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> ListTile(title: Text(<span class="string">&quot;<span class="subst">$index</span>&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》六：可滚动组件/WeChatd89bad409c79874b042dc4ffbed29249.png" alt="WeChatd89bad409c79874b042dc4ffbed29249" style="zoom:80%;" />

<h5 id="ListView-separated"><a href="#ListView-separated" class="headerlink" title="ListView.separated"></a>ListView.separated</h5><p>可以在生成的列表项之间加一个分割组件，比 ListView.builder 多了一个 separatedBuilder 参数，是一个分割组件生成器</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListView3</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">//下划线widget预定义以供复用。  </span></span><br><span class="line">    Widget divider1=Divider(color: Colors.blue,);</span><br><span class="line">    Widget divider2=Divider(color: Colors.green);</span><br><span class="line">    <span class="keyword">return</span> ListView.separated(</span><br><span class="line">      itemCount: <span class="number">100</span>,</span><br><span class="line">      <span class="comment">//列表项构造器</span></span><br><span class="line">      itemBuilder: (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> ListTile(title: Text(<span class="string">&quot;<span class="subst">$index</span>&quot;</span>));</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//分割器构造器</span></span><br><span class="line">      separatorBuilder: (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> index%<span class="number">2</span>==<span class="number">0</span>?divider1:divider2;</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》六：可滚动组件/WeChat5ceee9697183ace9c3a29f3a4ca3973e.png" alt="WeChat5ceee9697183ace9c3a29f3a4ca3973e" style="zoom:80%;" />

<h5 id="固定高度列表"><a href="#固定高度列表" class="headerlink" title="固定高度列表"></a>固定高度列表</h5><p>给列表指定 itemExtent 或 prototypeItem 会有更高的性能，在知道列表项的高度都相同时，强烈建议指定 itemExtent 或 prototypeItem</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedExtentList</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> FixedExtentList(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ListView.builder(</span><br><span class="line">   		prototypeItem: ListTile(title: Text(<span class="string">&quot;1&quot;</span>)),</span><br><span class="line">      <span class="comment">//itemExtent: 56,</span></span><br><span class="line">      itemBuilder: (context, index) &#123;</span><br><span class="line">        <span class="comment">//LayoutLogPrint是一个自定义组件，在布局时可以打印当前上下文中父组件给子组件的约束信息</span></span><br><span class="line">        <span class="keyword">return</span> LayoutLogPrint(</span><br><span class="line">          tag: index, </span><br><span class="line">          child: ListTile(title: Text(<span class="string">&quot;<span class="subst">$index</span>&quot;</span>)),</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="无限加载列表"><a href="#无限加载列表" class="headerlink" title="无限加载列表"></a>无限加载列表</h5><p>从数据源异步分批次拉取数据，用 ListView 展示，当滑动到列表末尾时，判断是否需要去拉取数据，如果是，则去拉取，拉取过程中表尾显示一个 loading，拉取成功后将数据插入表尾，如果不需要拉取，则表尾显示没有更多</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:english_words/english_words.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/rendering.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfiniteListView</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _InfiniteListViewState createState() =&gt; _InfiniteListViewState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_InfiniteListViewState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">InfiniteListView</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> loadingTag = <span class="string">&quot;##loading##&quot;</span>; <span class="comment">//表尾标记</span></span><br><span class="line">  <span class="keyword">var</span> _words = &lt;<span class="built_in">String</span>&gt;[loadingTag];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _retrieveData();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ListView.separated(</span><br><span class="line">      itemCount: _words.length,</span><br><span class="line">      itemBuilder: (context, index) &#123;</span><br><span class="line">        <span class="comment">//如果到了表尾</span></span><br><span class="line">        <span class="keyword">if</span> (_words[index] == loadingTag) &#123;</span><br><span class="line">          <span class="comment">//不足100条，继续获取数据</span></span><br><span class="line">          <span class="keyword">if</span> (_words.length - <span class="number">1</span> &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="comment">//获取数据</span></span><br><span class="line">            _retrieveData();</span><br><span class="line">            <span class="comment">//加载时显示loading</span></span><br><span class="line">            <span class="keyword">return</span> Container(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">16.0</span>),</span><br><span class="line">              alignment: Alignment.center,</span><br><span class="line">              child: SizedBox(</span><br><span class="line">                width: <span class="number">24.0</span>,</span><br><span class="line">                height: <span class="number">24.0</span>,</span><br><span class="line">                child: CircularProgressIndicator(strokeWidth: <span class="number">2.0</span>),</span><br><span class="line">              ),</span><br><span class="line">            );</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//已经加载了100条数据，不再获取数据。</span></span><br><span class="line">            <span class="keyword">return</span> Container(</span><br><span class="line">              alignment: Alignment.center,</span><br><span class="line">              padding: EdgeInsets.all(<span class="number">16.0</span>),</span><br><span class="line">              child: Text(</span><br><span class="line">                <span class="string">&quot;没有更多了&quot;</span>,</span><br><span class="line">                style: TextStyle(color: Colors.grey),</span><br><span class="line">              ),</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//显示单词列表项</span></span><br><span class="line">        <span class="keyword">return</span> ListTile(title: Text(_words[index]));</span><br><span class="line">      &#125;,</span><br><span class="line">      separatorBuilder: (context, index) =&gt; Divider(height: <span class="number">.0</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _retrieveData() &#123;</span><br><span class="line">    Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">2</span>)).then((e) &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        <span class="comment">//重新构建列表</span></span><br><span class="line">        _words.insertAll(</span><br><span class="line">          _words.length - <span class="number">1</span>,</span><br><span class="line">          <span class="comment">//每次生成20个单词</span></span><br><span class="line">          generateWordPairs().take(<span class="number">20</span>).map((e) =&gt; e.asPascalCase).toList(),</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》六：可滚动组件/WeChat4aceb0db67ca479d945b472396307dd9.png" alt="WeChat4aceb0db67ca479d945b472396307dd9" style="zoom:80%;" />

<p>_retrieveData 是模拟从数据源异步获取数据，使用 english_words 包的 generateWordPairs 方法每次生成 20 个单词</p>
<h5 id="添加固定表头"><a href="#添加固定表头" class="headerlink" title="添加固定表头"></a>添加固定表头</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> Column(children: &lt;Widget&gt;[</span><br><span class="line">    ListTile(title:Text(<span class="string">&quot;商品列表&quot;</span>)),</span><br><span class="line">    Expanded(</span><br><span class="line">      child: ListView.builder(itemBuilder: (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> ListTile(title: Text(<span class="string">&quot;<span class="subst">$index</span>&quot;</span>));</span><br><span class="line">      &#125;),</span><br><span class="line">    ),</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自动拉伸 ListView 以填充屏幕剩余空间</p>
<h4 id="6-4-滚动监听及控制"><a href="#6-4-滚动监听及控制" class="headerlink" title="6.4 滚动监听及控制"></a>6.4 滚动监听及控制</h4><h5 id="6-4-1-ScrollController"><a href="#6-4-1-ScrollController" class="headerlink" title="6.4.1 ScrollController"></a>6.4.1 ScrollController</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ScrollController(&#123;</span><br><span class="line">  <span class="built_in">double</span> initialScrollOffset = <span class="number">0.0</span>, <span class="comment">//初始滚动位置</span></span><br><span class="line">  <span class="keyword">this</span>.keepScrollOffset = <span class="keyword">true</span>,<span class="comment">//是否保存滚动位置</span></span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>ScrollController 常用属性和方法</p>
<p>offset：可滚动组件当前的滚动位置</p>
<p>jumpTo(double offset)、animateTo(double offset, …)：这两个方法用于跳转到指定的位置</p>
<ul>
<li>滚动监听</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">controller.addListener(()=&gt;<span class="built_in">print</span>(controller.offset))</span><br></pre></td></tr></table></figure>

<ul>
<li>示例</li>
</ul>
<p>创建一个 ListView，滚动位置发生变化时，打印当前滚动位置，判断超过 1000 像素，屏幕右下角显示返回顶部按钮，按钮点击恢复到初始位置；没超过 1000 像素，隐藏按钮</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollControllerTestRoute</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ScrollControllerTestRouteState createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> ScrollControllerTestRouteState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollControllerTestRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ScrollControllerTestRoute</span>&gt; </span>&#123;</span><br><span class="line">  ScrollController _controller = ScrollController();</span><br><span class="line">  <span class="built_in">bool</span> showToTopBtn = <span class="keyword">false</span>; <span class="comment">//是否显示“返回到顶部”按钮</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">//监听滚动事件，打印滚动位置</span></span><br><span class="line">    _controller.addListener(() &#123;</span><br><span class="line">      <span class="built_in">print</span>(_controller.offset); <span class="comment">//打印滚动位置</span></span><br><span class="line">      <span class="keyword">if</span> (_controller.offset &lt; <span class="number">1000</span> &amp;&amp; showToTopBtn) &#123;</span><br><span class="line">        setState(() &#123;</span><br><span class="line">          showToTopBtn = <span class="keyword">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_controller.offset &gt;= <span class="number">1000</span> &amp;&amp; showToTopBtn == <span class="keyword">false</span>) &#123;</span><br><span class="line">        setState(() &#123;</span><br><span class="line">          showToTopBtn = <span class="keyword">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="comment">//为了避免内存泄露，需要调用_controller.dispose</span></span><br><span class="line">    _controller.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">&quot;滚动控制&quot;</span>)),</span><br><span class="line">      body: Scrollbar(</span><br><span class="line">        child: ListView.builder(</span><br><span class="line">          itemCount: <span class="number">100</span>,</span><br><span class="line">          itemExtent: <span class="number">50.0</span>, <span class="comment">//列表项高度固定时，显式指定高度是一个好习惯(性能消耗小)</span></span><br><span class="line">          controller: _controller,</span><br><span class="line">          itemBuilder: (context, index) &#123;</span><br><span class="line">            <span class="keyword">return</span> ListTile(title: Text(<span class="string">&quot;<span class="subst">$index</span>&quot;</span>),);</span><br><span class="line">          &#125;</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: !showToTopBtn ? <span class="keyword">null</span> : FloatingActionButton(</span><br><span class="line">        child: Icon(Icons.arrow_upward),</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          <span class="comment">//返回到顶部时执行动画</span></span><br><span class="line">          _controller.animateTo(</span><br><span class="line">            <span class="number">.0</span>,</span><br><span class="line">            duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">200</span>),</span><br><span class="line">            curve: Curves.ease,</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》六：可滚动组件/WeChat42973799693e4227480a0cc11ab05bd7.png" alt="WeChat42973799693e4227480a0cc11ab05bd7" style="zoom:80%;" />

<ul>
<li>滚动位置恢复</li>
</ul>
<p>PageStorage 是一个用于保存页面（路由）相关数据的组件，是一个功能型组件，拥有一个存储桶，子树中的widget可以通过指定不同的 PageStorageKey 来存储各自的数据或状态</p>
<p>每次滚动结束，可滚动组件都会将滚动位置 offset 存储到 PageStorage 中</p>
<p>如果 ScrollController.keepScrollOffset 为 false，则滚动位置将不会被存储</p>
<p>多个可滚动组件时，显示指定 PageStorageKey</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ListView(key: PageStorageKey(<span class="number">1</span>), ... );</span><br><span class="line">...</span><br><span class="line">ListView(key: PageStorageKey(<span class="number">2</span>), ... );</span><br></pre></td></tr></table></figure>

<ul>
<li>ScrollPosition</li>
</ul>
<p>ScrollPosition 是用来保存可滚动组件的滚动位置的，一个 ScrollController 对象可以同时被多个可滚动组件使用，ScrollController 会为每个可滚动组件创建一个 ScrollPosition 对象，这些 ScrollPosition 保存在 ScrollController 的 positions 属性中</p>
<p>offset</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span> <span class="keyword">get</span> offset =&gt; position.pixels;</span><br><span class="line">...</span><br><span class="line">controller.positions.elementAt(<span class="number">0</span>).pixels</span><br><span class="line">controller.positions.elementAt(<span class="number">1</span>).pixels</span><br><span class="line">...    </span><br></pre></td></tr></table></figure>

<p>controller.positions.length 来确定 controller 被几个可滚动组件使用</p>
<ul>
<li>ScrollPosition 的方法</li>
</ul>
<p>ScrollPosition 两个常用方法 animateTo() 和 jumpTo()，控制跳转滚动位置的方法</p>
<h5 id="6-4-2-滚动监听"><a href="#6-4-2-滚动监听" class="headerlink" title="6.4.2 滚动监听"></a>6.4.2 滚动监听</h5><p>Flutter widget 树中，子 widget 可以通过发送通知与父（包括祖先）widget 通信，父 widget 通过 NotificationListener 组件监听自己关注的通知</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollNotificationTestRoute</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ScrollNotificationTestRouteState createState() =&gt; _ScrollNotificationTestRouteState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ScrollNotificationTestRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ScrollNotificationTestRoute</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> _progress = <span class="string">&#x27;0%&#x27;</span>;<span class="comment">//保存进度百分比</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&#x27;标题&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Scrollbar(<span class="comment">//进度条，监听滚动通知</span></span><br><span class="line">          child: NotificationListener(</span><br><span class="line">              onNotification: (ScrollNotification notification) &#123;</span><br><span class="line">                <span class="built_in">double</span> progress = notification.metrics.pixels / notification.metrics.maxScrollExtent;</span><br><span class="line">                setState(() &#123;</span><br><span class="line">                  <span class="keyword">var</span> value = (progress * <span class="number">100</span>).toInt();</span><br><span class="line">                  <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">$value</span>%, <span class="subst">$progress</span>&quot;</span>);</span><br><span class="line">                  _progress = <span class="string">&quot;<span class="subst">$value</span>%&quot;</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// print(progress);</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">              &#125;,</span><br><span class="line">              child: Stack(</span><br><span class="line">                alignment: Alignment.center,</span><br><span class="line">                children: [</span><br><span class="line">                  ListView.builder(</span><br><span class="line">                    itemCount: <span class="number">100</span>,</span><br><span class="line">                    itemExtent: <span class="number">50.0</span>,</span><br><span class="line">                    itemBuilder: (context, index) =&gt; ListTile(title: Text(<span class="string">&#x27;<span class="subst">$index</span>&#x27;</span>)),</span><br><span class="line">                  ),</span><br><span class="line">                  CircleAvatar(</span><br><span class="line">                    radius: <span class="number">30.0</span>,</span><br><span class="line">                    child: Text(_progress),</span><br><span class="line">                    backgroundColor: Colors.black54,</span><br><span class="line">                  ),</span><br><span class="line">                ],</span><br><span class="line">              )</span><br><span class="line">          )</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》六：可滚动组件/WeChat5139ec30bc349c3ef1280b60d76c0f9e.png" alt="WeChat5139ec30bc349c3ef1280b60d76c0f9e" style="zoom:80%;" />

<p>接收到滚动事件时，参数类型为 ScrollNotification，包括一个 metrics 属性，类型是 ScrollMetrics</p>
<p>该属性包含当前 ViewPort 及滚动位置等信息</p>
<p>pixels：当前滚动位置<br>maxScrollPosition：最大可滚动长度<br>extentBefore：滑出ViewPort顶部的长度，相当于顶部滑出屏幕上方的列表长度<br>extentInside：ViewPort内部长度，相当于屏幕显示的列表长度<br>extentAfter：列表中未滑入ViewPort部分的长度<br>atEdge：是否滑到了可滚动组件的边界</p>
<h4 id="6-5-AnimatedList"><a href="#6-5-AnimatedList" class="headerlink" title="6.5 AnimatedList"></a>6.5 AnimatedList</h4><p>AnimatedList 和 ListView 的功能大体相似，AnimatedList 可以在列表中插入或删除节点时执行一个动画</p>
<ul>
<li>示例</li>
</ul>
<p>点击底部 + 号向列表追加一个列表项，点击列表项删除按钮，删除该列表项，添加和删除分别执行指定的动画</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimatedListRoute</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> AnimatedListRoute(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _AnimatedListRouteState createState() =&gt; _AnimatedListRouteState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimatedListRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimatedListRoute</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = &lt;<span class="built_in">String</span>&gt;[];</span><br><span class="line">  <span class="built_in">int</span> counter = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> globalKey = GlobalKey&lt;AnimatedListState&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; counter; i++) &#123;</span><br><span class="line">      data.add(<span class="string">&#x27;<span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Stack(</span><br><span class="line">      children: [</span><br><span class="line">        AnimatedList(</span><br><span class="line">          key: globalKey,</span><br><span class="line">          initialItemCount: data.length,</span><br><span class="line">          itemBuilder: (</span><br><span class="line">            BuildContext context,</span><br><span class="line">            <span class="built_in">int</span> index,</span><br><span class="line">            Animation&lt;<span class="built_in">double</span>&gt; animation,</span><br><span class="line">          ) &#123;</span><br><span class="line">            <span class="comment">//添加列表项时会执行渐显动画</span></span><br><span class="line">            <span class="keyword">return</span> FadeTransition(</span><br><span class="line">              opacity: animation,</span><br><span class="line">              child: buildItem(context, index),</span><br><span class="line">            );</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">        buildAddBtn(),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个 “+” 按钮，点击后会向列表中插入一项</span></span><br><span class="line">  Widget buildAddBtn() &#123;</span><br><span class="line">    <span class="keyword">return</span> Positioned(</span><br><span class="line">      child: FloatingActionButton(</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          <span class="comment">// 添加一个列表项</span></span><br><span class="line">          data.add(<span class="string">&#x27;<span class="subst">$&#123;++counter&#125;</span>&#x27;</span>);</span><br><span class="line">          <span class="comment">// 告诉列表项有新添加的列表项</span></span><br><span class="line">          globalKey.currentState!.insertItem(data.length - <span class="number">1</span>);</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&#x27;添加 <span class="subst">$counter</span>&#x27;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">      bottom: <span class="number">30</span>,</span><br><span class="line">      left: <span class="number">0</span>,</span><br><span class="line">      right: <span class="number">0</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建列表项</span></span><br><span class="line">  Widget buildItem(context, index) &#123;</span><br><span class="line">    <span class="built_in">String</span> char = data[index];</span><br><span class="line">    <span class="keyword">return</span> ListTile(</span><br><span class="line">      <span class="comment">//数字不会重复，所以作为Key</span></span><br><span class="line">      key: ValueKey(char),</span><br><span class="line">      title: Text(char),</span><br><span class="line">      trailing: IconButton(</span><br><span class="line">        icon: Icon(Icons.delete),</span><br><span class="line">        <span class="comment">// 点击时删除</span></span><br><span class="line">        onPressed: () =&gt; onDelete(context, index),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> onDelete(context, index) &#123;</span><br><span class="line">    <span class="comment">// 待实现</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除 onDelete 执行渐隐+收缩组合动画</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">setState(() &#123;</span><br><span class="line">  globalKey.currentState!.removeItem(</span><br><span class="line">    index,</span><br><span class="line">    (context, animation) &#123;</span><br><span class="line">      <span class="comment">// 删除过程执行的是反向动画，animation.value 会从1变为0</span></span><br><span class="line">      <span class="keyword">var</span> item = buildItem(context, index);</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;删除 <span class="subst">$&#123;data[index]&#125;</span>&#x27;</span>);</span><br><span class="line">      data.removeAt(index);</span><br><span class="line">      <span class="comment">// 删除动画是一个合成动画：渐隐 + 缩小列表项告诉</span></span><br><span class="line">      <span class="keyword">return</span> FadeTransition(</span><br><span class="line">        opacity: CurvedAnimation(</span><br><span class="line">          parent: animation,</span><br><span class="line">          <span class="comment">//让透明度变化的更快一些</span></span><br><span class="line">          curve: <span class="keyword">const</span> Interval(<span class="number">0.5</span>, <span class="number">1.0</span>),</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// 不断缩小列表项的高度</span></span><br><span class="line">        child: SizeTransition(</span><br><span class="line">          sizeFactor: animation,</span><br><span class="line">          axisAlignment: <span class="number">0.0</span>,</span><br><span class="line">          child: item,</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">    duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">200</span>), <span class="comment">// 动画时间为 200 ms</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》六：可滚动组件/WeChat11c3ca4197d326442fed540c599a1cd8.png" alt="WeChat11c3ca4197d326442fed540c599a1cd8" style="zoom:80%;" />

<h4 id="6-6-GridView"><a href="#6-6-GridView" class="headerlink" title="6.6 GridView"></a>6.6 GridView</h4><p>GridView 可以构建一个二维网格列表</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">GridView(&#123;</span><br><span class="line">    Key? key,</span><br><span class="line">    Axis scrollDirection = Axis.vertical,</span><br><span class="line">    <span class="built_in">bool</span> reverse = <span class="keyword">false</span>,</span><br><span class="line">    ScrollController? controller,</span><br><span class="line">    <span class="built_in">bool?</span> primary,</span><br><span class="line">    ScrollPhysics? physics,</span><br><span class="line">    <span class="built_in">bool</span> shrinkWrap = <span class="keyword">false</span>,</span><br><span class="line">    EdgeInsetsGeometry? padding,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.gridDelegate,  <span class="comment">//下面解释</span></span><br><span class="line">    <span class="built_in">bool</span> addAutomaticKeepAlives = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">bool</span> addRepaintBoundaries = <span class="keyword">true</span>,</span><br><span class="line">    <span class="built_in">double?</span> cacheExtent, </span><br><span class="line">    <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>gridDelegate 类型是 SliverGridDelegate，作用是控制 GridView 子组件如何排列（layout）</p>
<p>Flutter 提供了 SliverGridDelegate 的子类，SliverGridDelegateWithFixedCrossAxisCount，SliverGridDelegateWithMaxCrossAxisExtent</p>
<ul>
<li>SliverGridDelegateWithFixedCrossAxisCount</li>
</ul>
<p>该子类实现了一个横轴为固定数量子元素的 layout 算法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">SliverGridDelegateWithFixedCrossAxisCount(&#123;</span><br><span class="line">  <span class="meta">@required</span> <span class="built_in">double</span> crossAxisCount,  <span class="comment">//横轴子元素数量</span></span><br><span class="line">  <span class="built_in">double</span> mainAxisSpacing = <span class="number">0.0</span>, <span class="comment">//主轴方向间距</span></span><br><span class="line">  <span class="built_in">double</span> crossAxisSpacing = <span class="number">0.0</span>, <span class="comment">//横轴方向子元素间距</span></span><br><span class="line">  <span class="built_in">double</span> childAspectRatio = <span class="number">1.0</span>, </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>childAspectRatio：子元素在横轴长度和主轴长度的比例</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">GridView(</span><br><span class="line">  gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">      crossAxisCount: <span class="number">3</span>, <span class="comment">//横轴三个子widget</span></span><br><span class="line">      childAspectRatio: <span class="number">1.0</span> <span class="comment">//宽高比为1时，子widget</span></span><br><span class="line">  ),</span><br><span class="line">  children:&lt;Widget&gt;[</span><br><span class="line">    Icon(Icons.ac_unit),</span><br><span class="line">    Icon(Icons.airport_shuttle),</span><br><span class="line">    Icon(Icons.all_inclusive),</span><br><span class="line">    Icon(Icons.beach_access),</span><br><span class="line">    Icon(Icons.cake),</span><br><span class="line">    Icon(Icons.free_breakfast)</span><br><span class="line">  ]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》六：可滚动组件/WeChat1903ec58a90f35b79a5be2f22e6d67bb.png" alt="WeChat1903ec58a90f35b79a5be2f22e6d67bb" style="zoom:80%;" />

<p>子元素的大小通过 crossAxisCount 和 childAspectRatio 两个参数共同决定的</p>
<h5 id="GridView-count"><a href="#GridView-count" class="headerlink" title="GridView.count"></a>GridView.count</h5><p>构造函数，通过它可以快速创建横轴固定数量子元素的 GridView，上面代码等价于</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">GridView.count( </span><br><span class="line">  crossAxisCount: <span class="number">3</span>,</span><br><span class="line">  childAspectRatio: <span class="number">1.0</span>,</span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    Icon(Icons.ac_unit),</span><br><span class="line">    Icon(Icons.airport_shuttle),</span><br><span class="line">    Icon(Icons.all_inclusive),</span><br><span class="line">    Icon(Icons.beach_access),</span><br><span class="line">    Icon(Icons.cake),</span><br><span class="line">    Icon(Icons.free_breakfast),</span><br><span class="line">  ],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>SliverGridDelegateWithMaxCrossAxisExtent</li>
</ul>
<p>该子类实现一个横轴子元素为固定最大长度的 layout 算法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">SliverGridDelegateWithMaxCrossAxisExtent(&#123;</span><br><span class="line">  <span class="built_in">double</span> maxCrossAxisExtent,</span><br><span class="line">  <span class="built_in">double</span> mainAxisSpacing = <span class="number">0.0</span>,</span><br><span class="line">  <span class="built_in">double</span> crossAxisSpacing = <span class="number">0.0</span>,</span><br><span class="line">  <span class="built_in">double</span> childAspectRatio = <span class="number">1.0</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>maxCrossAxisExtent：子元素在横轴上最大长度，横轴方向上每个子元素的长度仍然是等分的</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">GridView(</span><br><span class="line">  padding: EdgeInsets.zero,</span><br><span class="line">  gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(</span><br><span class="line">      maxCrossAxisExtent: <span class="number">120.0</span>,</span><br><span class="line">      childAspectRatio: <span class="number">2.0</span> <span class="comment">//宽高比为2</span></span><br><span class="line">  ),</span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    Icon(Icons.ac_unit),</span><br><span class="line">    Icon(Icons.airport_shuttle),</span><br><span class="line">    Icon(Icons.all_inclusive),</span><br><span class="line">    Icon(Icons.beach_access),</span><br><span class="line">    Icon(Icons.cake),</span><br><span class="line">    Icon(Icons.free_breakfast),</span><br><span class="line">  ],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》六：可滚动组件/WeChatae018d1dc24fdb3bad25c5536cf3294b.png" alt="WeChatae018d1dc24fdb3bad25c5536cf3294b" style="zoom:80%;" />

<h5 id="GridView-extent"><a href="#GridView-extent" class="headerlink" title="GridView.extent"></a>GridView.extent</h5><p>构造函数，通过它可以快速构建纵轴子元素为固定最大长度的 GridView，上面代码等价于</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">GridView.extent(</span><br><span class="line">   maxCrossAxisExtent: <span class="number">120.0</span>,</span><br><span class="line">   childAspectRatio: <span class="number">2.0</span>,</span><br><span class="line">   children: &lt;Widget&gt;[</span><br><span class="line">     Icon(Icons.ac_unit),</span><br><span class="line">     Icon(Icons.airport_shuttle),</span><br><span class="line">     Icon(Icons.all_inclusive),</span><br><span class="line">     Icon(Icons.beach_access),</span><br><span class="line">     Icon(Icons.cake),</span><br><span class="line">     Icon(Icons.free_breakfast),</span><br><span class="line">   ],</span><br><span class="line"> );</span><br></pre></td></tr></table></figure>

<h5 id="GridView-builder"><a href="#GridView-builder" class="headerlink" title="GridView.builder"></a>GridView.builder</h5><p>上面介绍的都需要一个 widget 数组作为其子元素，适用于子 widget 数量比较少，子 widget 比较多时，可以通过 GridView.builder 来动态构建子 widget</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">GridView.builder(</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">required</span> SliverGridDelegate gridDelegate, </span><br><span class="line"> <span class="keyword">required</span> IndexedWidgetBuilder itemBuilder,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>示例</li>
</ul>
<p>异步数据源分批获取 Icon</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfiniteGridView</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _InfiniteGridViewState createState() =&gt; _InfiniteGridViewState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_InfiniteGridViewState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">InfiniteGridView</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;IconData&gt; _icons = []; <span class="comment">//保存Icon数据</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    _retrieveIcons();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> GridView.builder(</span><br><span class="line">      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">        crossAxisCount: <span class="number">3</span>, <span class="comment">//每行三列</span></span><br><span class="line">        childAspectRatio: <span class="number">1.0</span>, <span class="comment">//显示区域宽高相等</span></span><br><span class="line">      ),</span><br><span class="line">      itemCount: _icons.length,</span><br><span class="line">      itemBuilder: (context, index) &#123;</span><br><span class="line">        <span class="comment">//如果显示到最后一个并且Icon总数小于200时继续获取数据</span></span><br><span class="line">        <span class="keyword">if</span> (index == _icons.length - <span class="number">1</span> &amp;&amp; _icons.length &lt; <span class="number">200</span>) &#123;</span><br><span class="line">          _retrieveIcons();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Icon(_icons[index]);</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//模拟异步获取数据</span></span><br><span class="line">  <span class="keyword">void</span> _retrieveIcons() &#123;</span><br><span class="line">    Future.delayed(<span class="built_in">Duration</span>(milliseconds: <span class="number">200</span>)).then((e) &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        _icons.addAll([</span><br><span class="line">          Icons.ac_unit,</span><br><span class="line">          Icons.airport_shuttle,</span><br><span class="line">          Icons.all_inclusive,</span><br><span class="line">          Icons.beach_access,</span><br><span class="line">          Icons.cake,</span><br><span class="line">          Icons.free_breakfast,</span><br><span class="line">        ]);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_retrieveIcons() 方法中通过 Future.delayed 模拟异步数据源获取数据，每次获取数据 200 毫秒，调用 setState 重新构建</p>
<h4 id="6-7-PageView-与页面缓存"><a href="#6-7-PageView-与页面缓存" class="headerlink" title="6.7 PageView 与页面缓存"></a>6.7 PageView 与页面缓存</h4><h5 id="6-7-1-PageView"><a href="#6-7-1-PageView" class="headerlink" title="6.7.1 PageView"></a>6.7.1 PageView</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">PageView(&#123;</span><br><span class="line">  Key? key,</span><br><span class="line">  <span class="keyword">this</span>.scrollDirection = Axis.horizontal, <span class="comment">// 滑动方向</span></span><br><span class="line">  <span class="keyword">this</span>.reverse = <span class="keyword">false</span>,</span><br><span class="line">  PageController? controller,</span><br><span class="line">  <span class="keyword">this</span>.physics,</span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">  <span class="keyword">this</span>.onPageChanged,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//每次滑动是否强制切换整个页面，如果为false，则会根据实际的滑动距离显示页面</span></span><br><span class="line">  <span class="keyword">this</span>.pageSnapping = <span class="keyword">true</span>,</span><br><span class="line">  <span class="comment">//主要是配合辅助功能用的，后面解释</span></span><br><span class="line">  <span class="keyword">this</span>.allowImplicitScrolling = <span class="keyword">false</span>,</span><br><span class="line">  <span class="comment">//后面解释</span></span><br><span class="line">  <span class="keyword">this</span>.padEnds = <span class="keyword">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>示例</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Tab 页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Page</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Page(&#123;</span><br><span class="line">    Key? key,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.text,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> text;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _PageState createState() =&gt; _PageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_PageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">Page</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;build <span class="subst">$&#123;widget.text&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Center(child: Text(<span class="string">&#x27;<span class="subst">$&#123;widget.text&#125;</span>&#x27;</span>, textScaleFactor: <span class="number">5</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 PageView</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageViewRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> children = &lt;Widget&gt;[];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123; <span class="comment">//生成6个Tab页面</span></span><br><span class="line">      children.add(Page(text: <span class="string">&#x27;<span class="subst">$i</span>&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">&#x27;标题&#x27;</span>)),</span><br><span class="line">      body: PageView(</span><br><span class="line">        children: children,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后就可以滑动来回切换页面了</p>
<img src="《Flutter实战第二版》六：可滚动组件/WeChat6ff7e4dc572a88cb6f32c91d7b3a5956.png" alt="WeChat6ff7e4dc572a88cb6f32c91d7b3a5956" style="zoom:80%;" />

<h5 id="6-7-2-页面缓存"><a href="#6-7-2-页面缓存" class="headerlink" title="6.7.2 页面缓存"></a>6.7.2 页面缓存</h5><p>上面每当页面切换时都会重新触发 Page 页的 build</p>
<p>allowImplicitScrolling 设置为 true，前后各缓存一个页面宽度 (这属性不知道在哪设置)</p>
<h4 id="6-8-可滚动组件子项缓存-KeepAlive"><a href="#6-8-可滚动组件子项缓存-KeepAlive" class="headerlink" title="6.8 可滚动组件子项缓存 KeepAlive"></a>6.8 可滚动组件子项缓存 KeepAlive</h4><p>ListView 有一个 addAutomaticKeepAlives 属性如果为 true，则 ListView 会为每一个列表项添加一个 AutomaticKeeyAlive 父组件</p>
<h5 id="6-8-1-AutomaticKeeyAlive"><a href="#6-8-1-AutomaticKeeyAlive" class="headerlink" title="6.8.1 AutomaticKeeyAlive"></a>6.8.1 AutomaticKeeyAlive</h5><p>AutomaticKeeyAlive 组件的主要作用是将列表项的 RenderObject 的 keepAlive 按需自动标记为 true 或 false</p>
<p>将列表组件的 Viewport 区域 + cacheExtent（预渲染区域）称为加载区域</p>
<p>keepAlive 标记为 false 时，如果列表项滑出加载区域时，列表组件将会被销毁</p>
<p>keepAlive 标记为 true 时，当列表项滑出加载区域后，Viewport 会将列表组件缓存起来，当列表项进入加载区域时，Viewport 从先缓存中查找是否已缓存，如果有则复用，没有则重新创建列表项</p>
<ul>
<li>让 PageView 示例实现页面缓存 </li>
</ul>
<p>Flutter 提供了一个 AutomaticKeepAliveClientMixin，只需让 PageState 混入这个 mixin，同时添加一些必要操作即可</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_PageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">Page</span>&gt; <span class="title">with</span> <span class="title">AutomaticKeepAliveClientMixin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> wantKeepAlive =&gt; <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">super</span>.build(context);<span class="comment">//必须调用</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;build <span class="subst">$&#123;widget.text&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Center(child: Text(<span class="string">&#x27;<span class="subst">$&#123;widget.text&#125;</span>&#x27;</span>, textScaleFactor: <span class="number">5</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-8-2-KeepAliveWrapper"><a href="#6-8-2-KeepAliveWrapper" class="headerlink" title="6.8.2 KeepAliveWrapper"></a>6.8.2 KeepAliveWrapper</h5><p>作者分装的组件，如果哪个列表项需要缓存，只需要使用 KeepAliveWrapper 包裹下即可</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">var</span> children = &lt;Widget&gt;[];</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">//只需要用 KeepAliveWrapper 包装一下即可</span></span><br><span class="line">    children.add(KeepAliveWrapper(child:Page( text: <span class="string">&#x27;<span class="subst">$i</span>&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> PageView(children: children);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>KeepAliveWrapper 源码 </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeepAliveWrapper</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> KeepAliveWrapper(&#123;</span><br><span class="line">    Key? key,</span><br><span class="line">    <span class="keyword">this</span>.keepAlive = <span class="keyword">true</span>,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.child,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> keepAlive;</span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _KeepAliveWrapperState createState() =&gt; _KeepAliveWrapperState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_KeepAliveWrapperState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">KeepAliveWrapper</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">AutomaticKeepAliveClientMixin</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">super</span>.build(context);</span><br><span class="line">    <span class="keyword">return</span> widget.child;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didUpdateWidget(<span class="keyword">covariant</span> KeepAliveWrapper oldWidget) &#123;</span><br><span class="line">    <span class="keyword">if</span>(oldWidget.keepAlive != widget.keepAlive) &#123;</span><br><span class="line">      <span class="comment">// keepAlive 状态需要更新，实现在 AutomaticKeepAliveClientMixin 中</span></span><br><span class="line">      updateKeepAlive();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.didUpdateWidget(oldWidget);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> wantKeepAlive =&gt; widget.keepAlive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ListView 中测试下 </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeepAliveTest</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> KeepAliveTest(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ListView.builder(itemBuilder: (_, index) &#123;</span><br><span class="line">      <span class="keyword">return</span> KeepAliveWrapper(</span><br><span class="line">        <span class="comment">// 为 true 后会缓存所有的列表项，列表项将不会销毁。</span></span><br><span class="line">        <span class="comment">// 为 false 时，列表项滑出预加载区域后将会别销毁。</span></span><br><span class="line">        <span class="comment">// 使用时一定要注意是否必要，因为对所有列表项都缓存的会导致更多的内存消耗</span></span><br><span class="line">        keepAlive: <span class="keyword">true</span>,</span><br><span class="line">        child: ListItem(index: index),</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListItem</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ListItem(&#123;Key? key, <span class="keyword">required</span> <span class="keyword">this</span>.index&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> index;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ListItemState createState() =&gt; _ListItemState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ListItemState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ListItem</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> ListTile(title: Text(<span class="string">&#x27;<span class="subst">$&#123;widget.index&#125;</span>&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;dispose <span class="subst">$&#123;widget.index&#125;</span>&#x27;</span>);</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-9-TabBarView"><a href="#6-9-TabBarView" class="headerlink" title="6.9 TabBarView"></a>6.9 TabBarView</h4><h5 id="6-9-1-TabBarView"><a href="#6-9-1-TabBarView" class="headerlink" title="6.9.1 TabBarView"></a>6.9.1 TabBarView</h5><p>TabBarView 封装了 PageView </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> TabBarView(&#123;</span><br><span class="line">  Key? key,</span><br><span class="line">  required this.children, &#x2F;&#x2F; tab 页</span><br><span class="line">  this.controller, &#x2F;&#x2F; TabController</span><br><span class="line">  this.physics,</span><br><span class="line">  this.dragStartBehavior &#x3D; DragStartBehavior.start,</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>

<p>TabController 用于监听和控制 TabBarView 的页面切换，通常和 TabBar 联动，如果没有指定，则会在组件树中向上查找并使用最近一个 DefaultTabController</p>
<h5 id="6-9-2-TabBar"><a href="#6-9-2-TabBar" class="headerlink" title="6.9.2 TabBar"></a>6.9.2 TabBar</h5><img src="《Flutter实战第二版》六：可滚动组件/image-20210822144239879.02ae3d67.png" alt="image-20210822144239879.02ae3d67" style="zoom: 67%;" />

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TabBar(&#123;</span><br><span class="line">  Key? key,</span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">this</span>.tabs, <span class="comment">// 具体的 Tabs，需要我们创建</span></span><br><span class="line">  <span class="keyword">this</span>.controller,</span><br><span class="line">  <span class="keyword">this</span>.isScrollable = <span class="keyword">false</span>, <span class="comment">// 是否可以滑动</span></span><br><span class="line">  <span class="keyword">this</span>.padding,</span><br><span class="line">  <span class="keyword">this</span>.indicatorColor,<span class="comment">// 指示器颜色，默认是高度为2的一条下划线</span></span><br><span class="line">  <span class="keyword">this</span>.automaticIndicatorColorAdjustment = <span class="keyword">true</span>,</span><br><span class="line">  <span class="keyword">this</span>.indicatorWeight = <span class="number">2.0</span>,<span class="comment">// 指示器高度</span></span><br><span class="line">  <span class="keyword">this</span>.indicatorPadding = EdgeInsets.zero, <span class="comment">//指示器padding</span></span><br><span class="line">  <span class="keyword">this</span>.indicator, <span class="comment">// 指示器</span></span><br><span class="line">  <span class="keyword">this</span>.indicatorSize, <span class="comment">// 指示器长度，有两个可选值，一个tab的长度，一个是label长度</span></span><br><span class="line">  <span class="keyword">this</span>.labelColor, </span><br><span class="line">  <span class="keyword">this</span>.labelStyle,</span><br><span class="line">  <span class="keyword">this</span>.labelPadding,</span><br><span class="line">  <span class="keyword">this</span>.unselectedLabelColor,</span><br><span class="line">  <span class="keyword">this</span>.unselectedLabelStyle,</span><br><span class="line">  <span class="keyword">this</span>.mouseCursor,</span><br><span class="line">  <span class="keyword">this</span>.onTap,</span><br><span class="line">  ...</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>

<p>TapBar 通常位于 AppBar 底部，也可以接收一个 TabController</p>
<p>Material 组件库中已实现了一个 Tab 组件，一般会直接使用它 </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Tab(&#123;</span><br><span class="line">  Key? key,</span><br><span class="line">  <span class="keyword">this</span>.text, <span class="comment">//文本</span></span><br><span class="line">  <span class="keyword">this</span>.icon, <span class="comment">// 图标</span></span><br><span class="line">  <span class="keyword">this</span>.iconMargin = <span class="keyword">const</span> EdgeInsets.only(bottom: <span class="number">10.0</span>),</span><br><span class="line">  <span class="keyword">this</span>.height,</span><br><span class="line">  <span class="keyword">this</span>.child, <span class="comment">// 自定义 widget</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="6-9-3-示例"><a href="#6-9-3-示例" class="headerlink" title="6.9.3 示例"></a>6.9.3 示例</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TabViewRoute1</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _TabViewRoute1State createState() =&gt; _TabViewRoute1State();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TabViewRoute1State</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TabViewRoute1</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">late</span> TabController _tabController;</span><br><span class="line">  <span class="built_in">List</span> tabs = [<span class="string">&quot;新闻&quot;</span>, <span class="string">&quot;历史&quot;</span>, <span class="string">&quot;图片&quot;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _tabController = TabController(length: tabs.length, vsync: <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&quot;App Name&quot;</span>),</span><br><span class="line">        bottom: TabBar(</span><br><span class="line">          controller: _tabController,</span><br><span class="line">          tabs: tabs.map((e) =&gt; Tab(text: e)).toList(),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      body: TabBarView( <span class="comment">//构建</span></span><br><span class="line">        controller: _tabController,</span><br><span class="line">        children: tabs.map((e) &#123;</span><br><span class="line">          <span class="keyword">return</span> KeepAliveWrapper(</span><br><span class="line">            child: Container(</span><br><span class="line">              alignment: Alignment.center,</span><br><span class="line">              child: Text(e, textScaleFactor: <span class="number">5</span>),</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">        &#125;).toList(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    _tabController.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="《Flutter实战第二版》六：可滚动组件/WeChatfe6ded64a5b41253fae7d920235ca757.png" alt="WeChatfe6ded64a5b41253fae7d920235ca757" style="zoom:80%;" />

<p>为了实现 TabBar 和 TabBarView 的联动，显式创建了一个 TabController，TabController 又需要一个 TickerProvider（vsync参数）我们又混入了 SingleTickerProviderStateMixin ；TabController 中会执行动画，持有一些资源，所以在页面销毁时必须得释放资源</p>
<p>实战中，如果需要 TabBar 和 TabBarView 联动，通常会创建一个 DefaultTabController 作为他们共同的父级组件，这样它们在执行时就会从组件树向上查找，都会使用我们指定的这个 DefaultTabController，修改后如下</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TabViewRoute2</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">List</span> tabs = [<span class="string">&quot;新闻&quot;</span>, <span class="string">&quot;历史&quot;</span>, <span class="string">&quot;图片&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> DefaultTabController(</span><br><span class="line">      length: tabs.length,</span><br><span class="line">      child: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">&quot;App Name&quot;</span>),</span><br><span class="line">          bottom: TabBar(</span><br><span class="line">            tabs: tabs.map((e) =&gt; Tab(text: e)).toList(),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        body: TabBarView( <span class="comment">//构建</span></span><br><span class="line">          children: tabs.map((e) &#123;</span><br><span class="line">            <span class="keyword">return</span> KeepAliveWrapper(</span><br><span class="line">              child: Container(</span><br><span class="line">                alignment: Alignment.center,</span><br><span class="line">                child: Text(e, textScaleFactor: <span class="number">5</span>),</span><br><span class="line">              ),</span><br><span class="line">            );</span><br><span class="line">          &#125;).toList(),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们无需去手动管理Controller的生命周期，也不需要提供 SingleTickerProviderStateMixin，同时也没有其它的状态需要管理，也就不需要用 StatefulWidget 了</p>
<h4 id="6-10-CustomScrollView-和-Slivers"><a href="#6-10-CustomScrollView-和-Slivers" class="headerlink" title="6.10 CustomScrollView 和 Slivers"></a>6.10 CustomScrollView 和 Slivers</h4><h5 id="6-10-1-CustomScrollView"><a href="#6-10-1-CustomScrollView" class="headerlink" title="6.10.1 CustomScrollView"></a>6.10.1 CustomScrollView</h5><p>Flutter 提供了一个 CustomScrollView 组件帮助我们创建一个公共的 Scrollable 和 Viewport，然后它的 slivers 参数接受一个 Sliver 数组</p>
<p>加入我们想要在一个页面中，同时包含多个可滚动组件，且使他们的滑动效果统一起来</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget buildTwoSliverList() &#123;</span><br><span class="line">  <span class="comment">// SliverFixedExtentList 是一个 Sliver，它可以生成高度相同的列表项。</span></span><br><span class="line">  <span class="comment">// 再次提醒，如果列表项高度相同，我们应该优先使用SliverFixedExtentList </span></span><br><span class="line">  <span class="comment">// 和 SliverPrototypeExtentList，如果不同，使用 SliverList.</span></span><br><span class="line">  <span class="keyword">var</span> listView = SliverFixedExtentList(</span><br><span class="line">    itemExtent: <span class="number">56</span>, <span class="comment">//列表项高度固定</span></span><br><span class="line">    delegate: SliverChildBuilderDelegate(</span><br><span class="line">      (_, index) =&gt; ListTile(title: Text(<span class="string">&#x27;<span class="subst">$index</span>&#x27;</span>)),</span><br><span class="line">      childCount: <span class="number">10</span>,</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 使用</span></span><br><span class="line">  <span class="keyword">return</span> CustomScrollView(</span><br><span class="line">    slivers: [</span><br><span class="line">      listView,</span><br><span class="line">      listView,</span><br><span class="line">    ],</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="《Flutter实战第二版》六：可滚动组件/combine-twolist.74a615bf.gif" alt="combine-twolist.74a615bf" style="zoom:80%;" />

<h5 id="6-10-2-Flutter-中常用的Sliver"><a href="#6-10-2-Flutter-中常用的Sliver" class="headerlink" title="6.10.2 Flutter 中常用的Sliver"></a>6.10.2 Flutter 中常用的Sliver</h5><table>
<thead>
<tr>
<th>Sliver名称</th>
<th>功能</th>
<th>对应的可滚动组件</th>
</tr>
</thead>
<tbody><tr>
<td>SliverList</td>
<td>列表</td>
<td>ListView</td>
</tr>
<tr>
<td>SliverFixedExtentList</td>
<td>高度固定的列表</td>
<td>ListView，指定<code>itemExtent</code>时</td>
</tr>
<tr>
<td>SliverAnimatedList</td>
<td>添加/删除列表项可以执行动画</td>
<td>AnimatedList</td>
</tr>
<tr>
<td>SliverGrid</td>
<td>网格</td>
<td>GridView</td>
</tr>
<tr>
<td>SliverPrototypeExtentList</td>
<td>根据原型生成高度固定的列表</td>
<td>ListView，指定<code>prototypeItem</code> 时</td>
</tr>
<tr>
<td>SliverFillViewport</td>
<td>包含多给子组件，每个都可以填满屏幕</td>
<td>PageView</td>
</tr>
</tbody></table>
<p>除了和列表对应的 Sliver 之外还有一些用于对 Sliver 进行布局、装饰的组件，<strong>它们的子组件必须是 Sliver</strong>，我们列举几个常用的</p>
<table>
<thead>
<tr>
<th>Sliver名称</th>
<th>对应 RenderBox</th>
</tr>
</thead>
<tbody><tr>
<td>SliverPadding</td>
<td>Padding</td>
</tr>
<tr>
<td>SliverVisibility、SliverOpacity</td>
<td>Visibility、Opacity</td>
</tr>
<tr>
<td>SliverFadeTransition</td>
<td>FadeTransition</td>
</tr>
<tr>
<td>SliverLayoutBuilder</td>
<td>LayoutBuilder</td>
</tr>
</tbody></table>
<p>还有一些其它常用的 Sliver</p>
<table>
<thead>
<tr>
<th>Sliver名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SliverAppBar</td>
<td>对应 AppBar，主要是为了在 CustomScrollView 中使用。</td>
</tr>
<tr>
<td>SliverToBoxAdapter</td>
<td>一个适配器，可以将 RenderBox 适配为 Sliver，后面介绍。</td>
</tr>
<tr>
<td>SliverPersistentHeader</td>
<td>滑动到顶部时可以固定住，后面介绍。</td>
</tr>
</tbody></table>
<ul>
<li>示例</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为本路由没有使用 Scaffold，为了让子级Widget(如Text)使用</span></span><br><span class="line"><span class="comment">// Material Design 默认的样式风格,我们使用 Material 作为本路由的根。</span></span><br><span class="line">Material(</span><br><span class="line">  child: CustomScrollView(</span><br><span class="line">    slivers: &lt;Widget&gt;[</span><br><span class="line">      <span class="comment">// AppBar，包含一个导航栏.</span></span><br><span class="line">      SliverAppBar(</span><br><span class="line">        pinned: <span class="keyword">true</span>, <span class="comment">// 滑动到顶端时会固定住</span></span><br><span class="line">        expandedHeight: <span class="number">250.0</span>,</span><br><span class="line">        flexibleSpace: FlexibleSpaceBar(</span><br><span class="line">          title: <span class="keyword">const</span> Text(<span class="string">&#x27;Demo&#x27;</span>),</span><br><span class="line">          background: Image.asset(</span><br><span class="line">            <span class="string">&quot;./imgs/sea.png&quot;</span>,</span><br><span class="line">            fit: BoxFit.cover,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      SliverPadding(</span><br><span class="line">        padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">        sliver: SliverGrid(</span><br><span class="line">          <span class="comment">//Grid</span></span><br><span class="line">          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">            crossAxisCount: <span class="number">2</span>, <span class="comment">//Grid按两列显示</span></span><br><span class="line">            mainAxisSpacing: <span class="number">10.0</span>,</span><br><span class="line">            crossAxisSpacing: <span class="number">10.0</span>,</span><br><span class="line">            childAspectRatio: <span class="number">4.0</span>,</span><br><span class="line">          ),</span><br><span class="line">          delegate: SliverChildBuilderDelegate(</span><br><span class="line">            (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">              <span class="comment">//创建子widget</span></span><br><span class="line">              <span class="keyword">return</span> Container(</span><br><span class="line">                alignment: Alignment.center,</span><br><span class="line">                color: Colors.cyan[<span class="number">100</span> * (index % <span class="number">9</span>)],</span><br><span class="line">                child: Text(<span class="string">&#x27;grid item <span class="subst">$index</span>&#x27;</span>),</span><br><span class="line">              );</span><br><span class="line">            &#125;,</span><br><span class="line">            childCount: <span class="number">20</span>,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      SliverFixedExtentList(</span><br><span class="line">        itemExtent: <span class="number">50.0</span>,</span><br><span class="line">        delegate: SliverChildBuilderDelegate(</span><br><span class="line">          (BuildContext context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">            <span class="comment">//创建列表项</span></span><br><span class="line">            <span class="keyword">return</span> Container(</span><br><span class="line">              alignment: Alignment.center,</span><br><span class="line">              color: Colors.lightBlue[<span class="number">100</span> * (index % <span class="number">9</span>)],</span><br><span class="line">              child: Text(<span class="string">&#x27;list item <span class="subst">$index</span>&#x27;</span>),</span><br><span class="line">            );</span><br><span class="line">          &#125;,</span><br><span class="line">          childCount: <span class="number">20</span>,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ],</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>头部 SliverAppBar：SliverAppBar 对应 APPBar，不同之处在于 SliverAppBar 可以集成到 CustomScrollView， SliverAppBar 可以结合 FlexibleSpaceBar 实现Material Design 中头部伸缩的模型</p>
<p>中间 SliverGrid：它用 SliverPadding 包裹以给 SliverGrid 添加补白。SliverGrid 是一个两列，宽高比为4的网格，它有20个子组件</p>
<p>底部SliverFixedExtentList：它是一个所有子元素高度都为50像素的列表</p>
<img src="《Flutter实战第二版》六：可滚动组件/WeChata2a92923087dac38a2ad6c5e16f9cfb4.png" alt="WeChata2a92923087dac38a2ad6c5e16f9cfb4" style="zoom:80%;" />

<ul>
<li>SliverToBoxAdapter</li>
</ul>
<p>实际布局中，通常需要在 CustomScrollView 中添加一些自定义组件，这些组件并非都有 Sliver 版本，为此 Flutter 提供了一个 SliverToBoxAdapter 组件，是一个适配器，可以将 RenderBox 适配为 Sliver。</p>
<p>比如想在列表顶部加一个可以横向滚动的 PageView，可以使用 SliverToBoxAdapter 来适配</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">CustomScrollView(</span><br><span class="line">  slivers: [</span><br><span class="line">    SliverToBoxAdapter(</span><br><span class="line">      child: SizedBox(</span><br><span class="line">        height: <span class="number">300</span>,</span><br><span class="line">        child: PageView(</span><br><span class="line">          children: [Text(<span class="string">&quot;1&quot;</span>), Text(<span class="string">&quot;2&quot;</span>)],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">    buildSliverFixedList(),</span><br><span class="line">  ],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>SliverPersistentHeader</li>
</ul>
<p>SliverPersistentHeader 的功能是当滑动到 CustomScrollView 的顶部时，可以将组件固定在顶部</p>
<h4 id="6-11-自定义-Sliver"><a href="#6-11-自定义-Sliver" class="headerlink" title="6.11 自定义 Sliver"></a>6.11 自定义 Sliver</h4><h4 id="6-12-嵌套可滚动组件-NestedScrollView"><a href="#6-12-嵌套可滚动组件-NestedScrollView" class="headerlink" title="6.12 嵌套可滚动组件 NestedScrollView"></a>6.12 嵌套可滚动组件 NestedScrollView</h4>]]></content>
  </entry>
</search>
